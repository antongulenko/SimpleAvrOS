# 1 "../../../NIBObeeLib/src/nibobee/i2cmaster.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "../../../NIBObeeLib/src/nibobee/i2cmaster.c"
# 33 "../../../NIBObeeLib/src/nibobee/i2cmaster.c"
# 1 "..\\..\\..\\NIBObeeLib\\include/nibobee/iodefs.h" 1
# 44 "..\\..\\..\\NIBObeeLib\\include/nibobee/iodefs.h"
# 1 "..\\..\\..\\NIBObeeLib\\include/nibobee/iodefs_nibobee.h" 1
# 45 "..\\..\\..\\NIBObeeLib\\include/nibobee/iodefs.h" 2
# 62 "..\\..\\..\\NIBObeeLib\\include/nibobee/iodefs.h"
# 1 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/io.h" 1 3
# 99 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/io.h" 3
# 1 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/sfr_defs.h" 1 3
# 126 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/sfr_defs.h" 3
# 1 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/inttypes.h" 1 3
# 37 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/inttypes.h" 3
# 1 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/include/stdint.h" 1 3 4


# 1 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdint.h" 1 3 4
# 121 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdint.h" 3 4
typedef int int8_t __attribute__((__mode__(__QI__)));
typedef unsigned int uint8_t __attribute__((__mode__(__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int uint16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int uint32_t __attribute__ ((__mode__ (__SI__)));

typedef int int64_t __attribute__((__mode__(__DI__)));
typedef unsigned int uint64_t __attribute__((__mode__(__DI__)));
# 142 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdint.h" 3 4
typedef int16_t intptr_t;




typedef uint16_t uintptr_t;
# 159 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdint.h" 3 4
typedef int8_t int_least8_t;




typedef uint8_t uint_least8_t;




typedef int16_t int_least16_t;




typedef uint16_t uint_least16_t;




typedef int32_t int_least32_t;




typedef uint32_t uint_least32_t;







typedef int64_t int_least64_t;






typedef uint64_t uint_least64_t;
# 213 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdint.h" 3 4
typedef int8_t int_fast8_t;




typedef uint8_t uint_fast8_t;




typedef int16_t int_fast16_t;




typedef uint16_t uint_fast16_t;




typedef int32_t int_fast32_t;




typedef uint32_t uint_fast32_t;







typedef int64_t int_fast64_t;






typedef uint64_t uint_fast64_t;
# 273 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdint.h" 3 4
typedef int64_t intmax_t;




typedef uint64_t uintmax_t;
# 4 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/include/stdint.h" 2 3 4
# 38 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/inttypes.h" 2 3
# 77 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/inttypes.h" 3
typedef int32_t int_farptr_t;



typedef uint32_t uint_farptr_t;
# 127 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/sfr_defs.h" 2 3
# 100 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/io.h" 2 3
# 162 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/io.h" 3
# 1 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/iom1284p.h" 1 3
# 163 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/io.h" 2 3
# 520 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/io.h" 3
# 1 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/portpins.h" 1 3
# 521 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/io.h" 2 3

# 1 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/common.h" 1 3
# 523 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/io.h" 2 3

# 1 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/version.h" 1 3
# 525 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/io.h" 2 3


# 1 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/fuse.h" 1 3
# 239 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/fuse.h" 3
typedef struct
{
    unsigned char low;
    unsigned char high;
    unsigned char extended;
} __fuse_t;
# 528 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/io.h" 2 3


# 1 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/lock.h" 1 3
# 531 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/io.h" 2 3
# 63 "..\\..\\..\\NIBObeeLib\\include/nibobee/iodefs.h" 2
# 1 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/interrupt.h" 1 3
# 64 "..\\..\\..\\NIBObeeLib\\include/nibobee/iodefs.h" 2
# 34 "../../../NIBObeeLib/src/nibobee/i2cmaster.c" 2
# 1 "..\\..\\..\\NIBObeeLib\\include/nibobee/base.h" 1
# 56 "..\\..\\..\\NIBObeeLib\\include/nibobee/base.h"
enum {
  NIBOBEE_ANALOG_INITIALIZED = 0x01,
  NIBOBEE_MOTPWM_INITIALIZED = 0x02,
  NIBOBEE_I2C_INITIALIZED = 0x04,
};






extern uint8_t nibobee_initialization;
# 87 "..\\..\\..\\NIBObeeLib\\include/nibobee/base.h"
uint16_t nibobee_getMillivolt();
# 96 "..\\..\\..\\NIBObeeLib\\include/nibobee/base.h"
void nibobee_assertMinVoltage(uint16_t value);
# 35 "../../../NIBObeeLib/src/nibobee/i2cmaster.c" 2
# 1 "..\\..\\..\\NIBObeeLib\\include/nibobee/i2cmaster.h" 1
# 58 "..\\..\\..\\NIBObeeLib\\include/nibobee/i2cmaster.h"
extern volatile uint8_t i2c_tx_size;




extern volatile uint8_t i2c_rx_size;
# 78 "..\\..\\..\\NIBObeeLib\\include/nibobee/i2cmaster.h"
extern uint8_t i2c_buf[0x25];




enum {
  I2C_BUSY,
  I2C_IDLE,
  I2C_SUCCESS,
  I2C_ERROR=0x10
};




void i2c_init(void);




uint8_t i2c_start_transmission(void);




uint8_t i2c_status(void);

extern volatile uint8_t i2c_last_TWSR;
extern volatile uint8_t i2c_pos;




uint8_t i2c_wait_transmission(void);
# 36 "../../../NIBObeeLib/src/nibobee/i2cmaster.c" 2

# 1 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h" 1 3
# 43 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h" 3
# 1 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/delay_basic.h" 1 3
# 40 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/delay_basic.h" 3
static inline void _delay_loop_1(uint8_t __count) __attribute__((always_inline));
static inline void _delay_loop_2(uint16_t __count) __attribute__((always_inline));
# 80 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/delay_basic.h" 3
void
_delay_loop_1(uint8_t __count)
{
 __asm__ volatile (
  "1: dec %0" "\n\t"
  "brne 1b"
  : "=r" (__count)
  : "0" (__count)
 );
}
# 102 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/delay_basic.h" 3
void
_delay_loop_2(uint16_t __count)
{
 __asm__ volatile (
  "1: sbiw %0,1" "\n\t"
  "brne 1b"
  : "=w" (__count)
  : "0" (__count)
 );
}
# 44 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h" 2 3
# 83 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h" 3
static inline void _delay_us(double __us) __attribute__((always_inline));
static inline void _delay_ms(double __ms) __attribute__((always_inline));
# 131 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h" 3
void
_delay_ms(double __ms)
{
 uint16_t __ticks;
 double __tmp ;

 uint32_t __ticks_dc;
 extern void __builtin_avr_delay_cycles(unsigned long);
 __tmp = ((20000000) / 1e3) * __ms;
# 149 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h" 3
  __ticks_dc = (uint32_t)(ceil(fabs(__tmp)));


 __builtin_avr_delay_cycles(__ticks_dc);
# 174 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h" 3
}
# 208 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h" 3
void
_delay_us(double __us)
{
 uint8_t __ticks;
 double __tmp ;

 uint32_t __ticks_dc;
 extern void __builtin_avr_delay_cycles(unsigned long);
 __tmp = ((20000000) / 1e6) * __us;
# 226 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h" 3
  __ticks_dc = (uint32_t)(ceil(fabs(__tmp)));


 __builtin_avr_delay_cycles(__ticks_dc);
# 244 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h" 3
}
# 38 "../../../NIBObeeLib/src/nibobee/i2cmaster.c" 2
# 1 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/twi.h" 1 3
# 39 "../../../NIBObeeLib/src/nibobee/i2cmaster.c" 2






volatile uint8_t i2c_tx_size;
volatile uint8_t i2c_rx_size;


volatile uint8_t i2c_state;

volatile uint8_t i2c_size;
volatile uint8_t i2c_pos;

uint8_t i2c_buf[0x25];
volatile uint8_t i2c_last_TWSR;

enum {
  I2C_Idle,
  I2C_Address,
  I2C_Rx,
  I2C_Rx_Ack,
  I2C_Tx,
  I2C_Tx_Ack,
  I2C_Locked
};



static inline void twi_start() {
  (*(volatile uint8_t *)(0xBC)) = (1 << (2)) | (1 << (7)) | (1 << (0)) | (1 << (5));
}

static inline void twi_send(uint8_t data) {
  (*(volatile uint8_t *)(0xBB)) = data;
  (*(volatile uint8_t *)(0xBC)) = (1 << (2)) | (1 << (7)) | (1 << (0));
}

static inline void twi_ack() {
  (*(volatile uint8_t *)(0xBC)) = (1 << (2)) | (1 << (7)) | (1 << (0)) | (1 << (6));
}

static inline void twi_nak() {
  (*(volatile uint8_t *)(0xBC)) = (1 << (2)) | (1 << (7)) | (1 << (0));
}

static inline void twi_stop() {
  (*(volatile uint8_t *)(0xBC)) = (1 << (2)) | (1 << (7)) | (1 << (4));
}

static inline void twi_abort() {
  (*(volatile uint8_t *)(0xBC)) = (1 << (2)) | (1 << (7));
}



uint8_t i2c_start_transmission(void) {
  uint8_t res = 0;
  __asm__ __volatile__ ("cli" ::: "memory");
  do {
    if (i2c_state == I2C_BUSY) {
      i2c_state = I2C_ERROR+1;
      break;
    }

    if ((*(volatile uint8_t *)(0xBC)) & (1 << (4))) {
      i2c_state = I2C_ERROR+2;
      break;
    }
    if ((*(volatile uint8_t *)(0xBC)) & (1 << (5))) {
      (*(volatile uint8_t *)(0xBC)) = 0;
      (*(volatile uint8_t *)(0xBC)) = (1 << (2));
      i2c_state = I2C_ERROR+8;
      break;
    }
    i2c_state = I2C_BUSY;

    i2c_size = i2c_tx_size;

    twi_start();
    res = 1;
  } while(0);
  __asm__ __volatile__ ("sei" ::: "memory");
  return res;
}

uint8_t i2c_wait_transmission(void) {
  uint16_t i = 50000;
  while (i--) {
    if (((*(volatile uint8_t *)(0xBC)) & (1 << (0)))||((*(volatile uint8_t *)(0xBC)) & (1 << (4)))) {
      _delay_us(1);
    } else {

      return 1;
    }
  }
  __asm__ __volatile__ ("cli" ::: "memory");
  (*(volatile uint8_t *)(0xBC)) = 0;
  (*(volatile uint8_t *)(0xBC)) = (1 << (2));
  if (i2c_state < I2C_ERROR) {
    i2c_state = I2C_ERROR+3;
  }
  __asm__ __volatile__ ("sei" ::: "memory");
  return 0;
}


uint8_t i2c_status(void) {
  uint8_t res = i2c_state;
  return res;
}


void i2c_init(void) {
  (*(volatile uint8_t *)(0xBC)) = 0;
  (*(volatile uint8_t *)(0xB8)) = 100;
  (*(volatile uint8_t *)(0xBB)) = 0xff;
  (*(volatile uint8_t *)(0xBC)) = (1 << (2));
  i2c_state = I2C_IDLE;
  nibobee_initialization |= NIBOBEE_I2C_INITIALIZED;
}


void __vector_26 (void) __attribute__ ((signal,used, externally_visible)) ; void __vector_26 (void) {
  uint8_t res = (*(volatile uint8_t *)(0xB9)) & ((1 << (7))|(1 << (6))|(1 << (5))|(1 << (4))| (1 << (3)));
  i2c_last_TWSR = res;
  switch (res) {
    case 0x08:
    case 0x10:
      i2c_pos=0;
    case 0x18:
    case 0x28:
      if (i2c_pos<i2c_size) {
        twi_send(i2c_buf[i2c_pos++]);
      } else {

        if (i2c_rx_size) {
          i2c_size = i2c_rx_size;
          i2c_buf[0] |= 0x01;
          twi_start();
          break;
        }

        i2c_state = I2C_SUCCESS;
        twi_stop();
      }
      break;

    case 0x50:
      i2c_buf[i2c_pos++] = (*(volatile uint8_t *)(0xBB));
    case 0x40:
      if (i2c_pos+1<i2c_size) {

        twi_ack();
      } else {

        twi_nak();
      }
      break;

    case 0x58:

      i2c_buf[i2c_pos] = (*(volatile uint8_t *)(0xBB));
      i2c_state = I2C_SUCCESS;
      twi_stop();
      break;

    case 0x38:
      twi_abort();
      i2c_state = I2C_ERROR+5;
      break;

    case 0x00:
    case 0x20:
    case 0x48:
    case 0x30:
      twi_stop();
      i2c_state = I2C_ERROR+6;
      break;

    default:
      twi_abort();
      i2c_state = I2C_ERROR+7;
  }
}
