# 1 "../../../NIBObeeLib/src/nibobee/motpid.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "../../../NIBObeeLib/src/nibobee/motpid.c"
# 39 "../../../NIBObeeLib/src/nibobee/motpid.c"
# 1 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/interrupt.h" 1 3
# 38 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/interrupt.h" 3
# 1 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/io.h" 1 3
# 99 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/io.h" 3
# 1 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/sfr_defs.h" 1 3
# 126 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/sfr_defs.h" 3
# 1 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/inttypes.h" 1 3
# 37 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/inttypes.h" 3
# 1 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/include/stdint.h" 1 3 4


# 1 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdint.h" 1 3 4
# 121 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdint.h" 3 4
typedef int int8_t __attribute__((__mode__(__QI__)));
typedef unsigned int uint8_t __attribute__((__mode__(__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int uint16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int uint32_t __attribute__ ((__mode__ (__SI__)));

typedef int int64_t __attribute__((__mode__(__DI__)));
typedef unsigned int uint64_t __attribute__((__mode__(__DI__)));
# 142 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdint.h" 3 4
typedef int16_t intptr_t;




typedef uint16_t uintptr_t;
# 159 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdint.h" 3 4
typedef int8_t int_least8_t;




typedef uint8_t uint_least8_t;




typedef int16_t int_least16_t;




typedef uint16_t uint_least16_t;




typedef int32_t int_least32_t;




typedef uint32_t uint_least32_t;







typedef int64_t int_least64_t;






typedef uint64_t uint_least64_t;
# 213 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdint.h" 3 4
typedef int8_t int_fast8_t;




typedef uint8_t uint_fast8_t;




typedef int16_t int_fast16_t;




typedef uint16_t uint_fast16_t;




typedef int32_t int_fast32_t;




typedef uint32_t uint_fast32_t;







typedef int64_t int_fast64_t;






typedef uint64_t uint_fast64_t;
# 273 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdint.h" 3 4
typedef int64_t intmax_t;




typedef uint64_t uintmax_t;
# 4 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/include/stdint.h" 2 3 4
# 38 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/inttypes.h" 2 3
# 77 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/inttypes.h" 3
typedef int32_t int_farptr_t;



typedef uint32_t uint_farptr_t;
# 127 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/sfr_defs.h" 2 3
# 100 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/io.h" 2 3
# 162 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/io.h" 3
# 1 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/iom1284p.h" 1 3
# 163 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/io.h" 2 3
# 520 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/io.h" 3
# 1 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/portpins.h" 1 3
# 521 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/io.h" 2 3

# 1 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/common.h" 1 3
# 523 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/io.h" 2 3

# 1 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/version.h" 1 3
# 525 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/io.h" 2 3


# 1 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/fuse.h" 1 3
# 239 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/fuse.h" 3
typedef struct
{
    unsigned char low;
    unsigned char high;
    unsigned char extended;
} __fuse_t;
# 528 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/io.h" 2 3


# 1 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/lock.h" 1 3
# 531 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/io.h" 2 3
# 39 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/interrupt.h" 2 3
# 40 "../../../NIBObeeLib/src/nibobee/motpid.c" 2
# 1 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/atomic.h" 1 3
# 42 "c:\\program files (x86)\\atmel\\avr studio 5.0\\avr toolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/atomic.h" 3
static __inline__ uint8_t __iSeiRetVal(void)
{
    __asm__ __volatile__ ("sei" ::: "memory");
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    __asm__ __volatile__ ("cli" ::: "memory");
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    __asm__ __volatile__ ("sei" ::: "memory");
    __asm__ volatile ("" ::: "memory");
    (void)__s;
}

static __inline__ void __iCliParam(const uint8_t *__s)
{
    __asm__ __volatile__ ("cli" ::: "memory");
    __asm__ volatile ("" ::: "memory");
    (void)__s;
}

static __inline__ void __iRestore(const uint8_t *__s)
{
    (*(volatile uint8_t *)((0x3F) + 0x20)) = *__s;
    __asm__ volatile ("" ::: "memory");
}
# 41 "../../../NIBObeeLib/src/nibobee/motpid.c" 2
# 1 "..\\..\\..\\NIBObeeLib\\include/nibobee/iodefs.h" 1
# 44 "..\\..\\..\\NIBObeeLib\\include/nibobee/iodefs.h"
# 1 "..\\..\\..\\NIBObeeLib\\include/nibobee/iodefs_nibobee.h" 1
# 45 "..\\..\\..\\NIBObeeLib\\include/nibobee/iodefs.h" 2
# 42 "../../../NIBObeeLib/src/nibobee/motpid.c" 2
# 1 "..\\..\\..\\NIBObeeLib\\include/nibobee/base.h" 1
# 56 "..\\..\\..\\NIBObeeLib\\include/nibobee/base.h"
enum {
  NIBOBEE_ANALOG_INITIALIZED = 0x01,
  NIBOBEE_MOTPWM_INITIALIZED = 0x02,
  NIBOBEE_I2C_INITIALIZED = 0x04,
};






extern uint8_t nibobee_initialization;
# 87 "..\\..\\..\\NIBObeeLib\\include/nibobee/base.h"
uint16_t nibobee_getMillivolt();
# 96 "..\\..\\..\\NIBObeeLib\\include/nibobee/base.h"
void nibobee_assertMinVoltage(uint16_t value);
# 43 "../../../NIBObeeLib/src/nibobee/motpid.c" 2
# 1 "..\\..\\..\\NIBObeeLib\\include/nibobee/motpwm.h" 1
# 51 "..\\..\\..\\NIBObeeLib\\include/nibobee/motpwm.h"
void motpwm_init();





void motpwm_stop();






void motpwm_setLeft(int16_t value);






void motpwm_setRight(int16_t value);
# 44 "../../../NIBObeeLib/src/nibobee/motpid.c" 2
# 1 "..\\..\\..\\NIBObeeLib\\include/nibobee/motpid.h" 1
# 51 "..\\..\\..\\NIBObeeLib\\include/nibobee/motpid.h"
void motpid_init();






void motpid_release();







void motpid_stop(uint8_t immediate);
# 76 "..\\..\\..\\NIBObeeLib\\include/nibobee/motpid.h"
void motpid_setSpeed(int16_t left, int16_t right);
# 86 "..\\..\\..\\NIBObeeLib\\include/nibobee/motpid.h"
void motpid_setTarget(int16_t left, int16_t right, uint16_t speed);
# 96 "..\\..\\..\\NIBObeeLib\\include/nibobee/motpid.h"
void motpid_setTargetRel(int16_t left, int16_t right, uint16_t speed);
# 45 "../../../NIBObeeLib/src/nibobee/motpid.c" 2


# 1 "..\\..\\..\\NIBObeeLib\\include/nibobee/clock.h" 1
# 59 "..\\..\\..\\NIBObeeLib\\include/nibobee/clock.h"
void clock_inc_irq(uint8_t ms, uint16_t us);






void clock_sleep(uint16_t ms);





extern volatile uint16_t clock_ms;





extern volatile uint32_t clock_sec;





void clock_sec_irq_hook();




void clock_hundredth_irq_hook();
# 48 "../../../NIBObeeLib/src/nibobee/motpid.c" 2
# 77 "../../../NIBObeeLib/src/nibobee/motpid.c"
uint8_t motpid_cnt;

extern volatile int8_t odometry_pid_left;
extern volatile int8_t odometry_pid_right;
extern volatile int16_t odometry_left;
extern volatile int16_t odometry_right;

enum {
  MOTPID_MODE_OFF = 0x00,
  MOTPID_MODE_SPEED = 0x03,
  MOTPID_MODE_POS = 0x04
};


int16_t motpid_left_speed;
int16_t motpid_right_speed;
int16_t motpid_left_speed2;
int16_t motpid_right_speed2;

int16_t motpid_position_speed=20;

int16_t motpid_left_value;
int16_t motpid_right_value;

int8_t motpid_left_cnt;
int8_t motpid_right_cnt;

uint8_t motpid_mode;

typedef struct {
  int16_t a2;
  int16_t a1;
  int16_t o1;
}
motpid_dyndata_t;

static motpid_dyndata_t motpid_dyndata_left;
static motpid_dyndata_t motpid_dyndata_right;


void motpid_reset(void) {
  motpid_dyndata_left.a2 = 0;
  motpid_dyndata_left.a1 = 0;
  motpid_dyndata_left.o1 = 0;
  motpid_dyndata_right.a2 = 0;
  motpid_dyndata_right.a1 = 0;
  motpid_dyndata_right.o1 = 0;
}


void motpid_change_mode(uint8_t new_mode) {
  if (motpid_mode==new_mode)
    return;
  motpid_reset();
  motpid_mode=new_mode;
}


static int16_t motpid_calculate_single(int16_t a2, int16_t a1, int16_t o1, int16_t setpoint, int16_t reading) {
  int16_t temp = o1;
  if (temp >= +16384) temp = +16384;
  if (temp <= -16384) temp = -16384;
  temp += 6 * (setpoint - reading);
  temp += 7 * (2*a1 - a2 - reading);
  temp += 5 * (a1 - reading);
  return temp;
}


void motpid_left_timer_int(void) {
  motpid_left_speed = (3*motpid_left_speed + (100/2)*odometry_pid_left)/4;
  motpid_left_speed2 = (3*motpid_left_speed2 + motpid_left_speed)/4;
  if (motpid_mode) {
    int16_t value = motpid_left_speed;
    int16_t setpoint = motpid_left_value;
    if (motpid_mode==MOTPID_MODE_POS) {
      setpoint -= odometry_left;
      if (setpoint>motpid_position_speed) setpoint=motpid_position_speed;
      if (setpoint<-motpid_position_speed) setpoint=-motpid_position_speed;
      if (setpoint==0) {
        motpid_dyndata_left.a2 = motpid_dyndata_left.a1 = motpid_dyndata_left.o1 = 0;
      }
    }

    motpid_dyndata_left.o1 = motpid_calculate_single(motpid_dyndata_left.a2, motpid_dyndata_left.a1,
        motpid_dyndata_left.o1, setpoint, value);
    motpid_dyndata_left.a2 = motpid_dyndata_left.a1;
    motpid_dyndata_left.a1 = value;

    motpwm_setLeft(motpid_dyndata_left.o1 / 16);
  }
  odometry_pid_left = 0;
}


void motpid_right_timer_int(void) {
  motpid_right_speed = (3*motpid_right_speed + (100/2)*odometry_pid_right)/4;
  motpid_right_speed2 = (3*motpid_right_speed2 + motpid_right_speed)/4;
  if (motpid_mode) {
    int16_t value = motpid_right_speed;
    int16_t setpoint = motpid_right_value;
    if (motpid_mode==MOTPID_MODE_POS) {
      setpoint -= odometry_right;
      if (setpoint>motpid_position_speed) setpoint=motpid_position_speed;
      if (setpoint<-motpid_position_speed) setpoint=-motpid_position_speed;
      if (setpoint==0) {
        motpid_dyndata_right.a2 = motpid_dyndata_right.a1 = motpid_dyndata_right.o1 = 0;
      }
    }

    motpid_dyndata_right.o1 = motpid_calculate_single(motpid_dyndata_right.a2, motpid_dyndata_right.a1,
        motpid_dyndata_right.o1, setpoint, value);
    motpid_dyndata_right.a2 = motpid_dyndata_right.a1;
    motpid_dyndata_right.a1 = value;

    motpwm_setRight(motpid_dyndata_right.o1 / 16);
  }
  odometry_pid_right = 0;
}


void __vector_15 (void) __attribute__ ((signal,used, externally_visible)) ; void __vector_15 (void) {
  static uint8_t counter=0;
  static uint8_t running=0;
  counter++;
  if (running) {
    return;
  }
  running=1;
  if (counter>=15) {
    counter-=15;
    clock_inc_irq(1, 22);
  }

  motpid_cnt++;
  if (motpid_cnt>=147) {
    motpid_left_timer_int();

    motpid_right_timer_int();


    motpid_cnt=0;
  }
  running = 0;
}


void motpid_init() {
  if (!(nibobee_initialization&NIBOBEE_MOTPWM_INITIALIZED)) {
    motpwm_init();
  }
  (*(volatile uint8_t *)(0x6F)) |= (1 << (0));
  motpid_reset();
  motpid_mode = MOTPID_MODE_OFF;
}


void motpid_release() {
  motpid_change_mode(MOTPID_MODE_OFF);
}


void motpid_stop(uint8_t immediate) {
  if (immediate) {
    motpid_change_mode(MOTPID_MODE_OFF);
    motpwm_setRight(0);
    motpwm_setLeft(0);
  } else {
    motpid_setSpeed(0, 0);
  }
}


void motpid_setSpeed(int16_t left, int16_t right) {
    motpid_change_mode(MOTPID_MODE_SPEED);
    motpid_left_value = left;
    motpid_right_value = right;
}


void motpid_setTarget(int16_t left, int16_t right, uint16_t speed) {
    motpid_change_mode(MOTPID_MODE_POS);
    motpid_position_speed = speed;
    motpid_left_value = left;
    motpid_right_value = right;
}


void motpid_setTargetRel(int16_t left, int16_t right, uint16_t speed) {
    motpid_change_mode(MOTPID_MODE_POS);
    motpid_position_speed = speed;
    motpid_left_value = odometry_left + left;
    motpid_right_value = odometry_right + right;
}
