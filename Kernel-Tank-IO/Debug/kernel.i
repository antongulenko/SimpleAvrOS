# 1 ".././kernel.c"
# 1 "C:\\Dev\\NIBObee\\NIBObee\\Kernel-Tank-IO\\Debug//"
# 1 "<built-in>"
#define __STDC__ 1
#define __STDC_VERSION__ 199901L
#define __STDC_HOSTED__ 1
#define __GNUC__ 4
#define __GNUC_MINOR__ 5
#define __GNUC_PATCHLEVEL__ 1
#define __SIZE_TYPE__ unsigned int
#define __PTRDIFF_TYPE__ int
#define __WCHAR_TYPE__ int
#define __WINT_TYPE__ unsigned int
#define __INTMAX_TYPE__ long long int
#define __UINTMAX_TYPE__ long long unsigned int
#define __CHAR16_TYPE__ short unsigned int
#define __CHAR32_TYPE__ long unsigned int
#define __SIG_ATOMIC_TYPE__ int
#define __INT8_TYPE__ signed char
#define __INT16_TYPE__ short int
#define __INT32_TYPE__ long int
#define __INT64_TYPE__ long long int
#define __UINT8_TYPE__ unsigned char
#define __UINT16_TYPE__ short unsigned int
#define __UINT32_TYPE__ long unsigned int
#define __UINT64_TYPE__ long long unsigned int
#define __INT_LEAST8_TYPE__ signed char
#define __INT_LEAST16_TYPE__ short int
#define __INT_LEAST32_TYPE__ long int
#define __INT_LEAST64_TYPE__ long long int
#define __UINT_LEAST8_TYPE__ unsigned char
#define __UINT_LEAST16_TYPE__ short unsigned int
#define __UINT_LEAST32_TYPE__ long unsigned int
#define __UINT_LEAST64_TYPE__ long long unsigned int
#define __INT_FAST8_TYPE__ int
#define __INT_FAST16_TYPE__ int
#define __INT_FAST32_TYPE__ long int
#define __INT_FAST64_TYPE__ long long int
#define __UINT_FAST8_TYPE__ unsigned int
#define __UINT_FAST16_TYPE__ unsigned int
#define __UINT_FAST32_TYPE__ long unsigned int
#define __UINT_FAST64_TYPE__ long long unsigned int
#define __INTPTR_TYPE__ int
#define __UINTPTR_TYPE__ unsigned int
#define __GXX_ABI_VERSION 1002
#define __USING_SJLJ_EXCEPTIONS__ 1
#define __SCHAR_MAX__ 127
#define __SHRT_MAX__ 32767
#define __INT_MAX__ 32767
#define __LONG_MAX__ 2147483647L
#define __LONG_LONG_MAX__ 9223372036854775807LL
#define __WCHAR_MAX__ 32767
#define __WCHAR_MIN__ (-__WCHAR_MAX__ - 1)
#define __WINT_MAX__ 65535U
#define __WINT_MIN__ 0U
#define __PTRDIFF_MAX__ 32767
#define __SIZE_MAX__ 65535U
#define __CHAR_BIT__ 8
#define __INTMAX_MAX__ 9223372036854775807LL
#define __INTMAX_C(c) c ## LL
#define __UINTMAX_MAX__ 18446744073709551615ULL
#define __UINTMAX_C(c) c ## ULL
#define __SIG_ATOMIC_MAX__ 32767
#define __SIG_ATOMIC_MIN__ (-__SIG_ATOMIC_MAX__ - 1)
#define __INT8_MAX__ 127
#define __INT16_MAX__ 32767
#define __INT32_MAX__ 2147483647L
#define __INT64_MAX__ 9223372036854775807LL
#define __UINT8_MAX__ 255
#define __UINT16_MAX__ 65535U
#define __UINT32_MAX__ 4294967295UL
#define __UINT64_MAX__ 18446744073709551615ULL
#define __INT_LEAST8_MAX__ 127
#define __INT8_C(c) c
#define __INT_LEAST16_MAX__ 32767
#define __INT16_C(c) c
#define __INT_LEAST32_MAX__ 2147483647L
#define __INT32_C(c) c ## L
#define __INT_LEAST64_MAX__ 9223372036854775807LL
#define __INT64_C(c) c ## LL
#define __UINT_LEAST8_MAX__ 255
#define __UINT8_C(c) c
#define __UINT_LEAST16_MAX__ 65535U
#define __UINT16_C(c) c ## U
#define __UINT_LEAST32_MAX__ 4294967295UL
#define __UINT32_C(c) c ## UL
#define __UINT_LEAST64_MAX__ 18446744073709551615ULL
#define __UINT64_C(c) c ## ULL
#define __INT_FAST8_MAX__ 32767
#define __INT_FAST16_MAX__ 32767
#define __INT_FAST32_MAX__ 2147483647L
#define __INT_FAST64_MAX__ 9223372036854775807LL
#define __UINT_FAST8_MAX__ 65535U
#define __UINT_FAST16_MAX__ 65535U
#define __UINT_FAST32_MAX__ 4294967295UL
#define __UINT_FAST64_MAX__ 18446744073709551615ULL
#define __INTPTR_MAX__ 32767
#define __UINTPTR_MAX__ 65535U
#define __FLT_EVAL_METHOD__ 0
#define __DEC_EVAL_METHOD__ 2
#define __FLT_RADIX__ 2
#define __FLT_MANT_DIG__ 24
#define __FLT_DIG__ 6
#define __FLT_MIN_EXP__ (-125)
#define __FLT_MIN_10_EXP__ (-37)
#define __FLT_MAX_EXP__ 128
#define __FLT_MAX_10_EXP__ 38
#define __FLT_MAX__ 3.40282347e+38F
#define __FLT_MIN__ 1.17549435e-38F
#define __FLT_EPSILON__ 1.19209290e-7F
#define __FLT_DENORM_MIN__ 1.40129846e-45F
#define __FLT_HAS_DENORM__ 1
#define __FLT_HAS_INFINITY__ 1
#define __FLT_HAS_QUIET_NAN__ 1
#define __DBL_MANT_DIG__ 24
#define __DBL_DIG__ 6
#define __DBL_MIN_EXP__ (-125)
#define __DBL_MIN_10_EXP__ (-37)
#define __DBL_MAX_EXP__ 128
#define __DBL_MAX_10_EXP__ 38
#define __DBL_MAX__ ((double)3.40282347e+38L)
#define __DBL_MIN__ ((double)1.17549435e-38L)
#define __DBL_EPSILON__ ((double)1.19209290e-7L)
#define __DBL_DENORM_MIN__ ((double)1.40129846e-45L)
#define __DBL_HAS_DENORM__ 1
#define __DBL_HAS_INFINITY__ 1
#define __DBL_HAS_QUIET_NAN__ 1
#define __LDBL_MANT_DIG__ 24
#define __LDBL_DIG__ 6
#define __LDBL_MIN_EXP__ (-125)
#define __LDBL_MIN_10_EXP__ (-37)
#define __LDBL_MAX_EXP__ 128
#define __LDBL_MAX_10_EXP__ 38
#define __DECIMAL_DIG__ 9
#define __LDBL_MAX__ 3.40282347e+38L
#define __LDBL_MIN__ 1.17549435e-38L
#define __LDBL_EPSILON__ 1.19209290e-7L
#define __LDBL_DENORM_MIN__ 1.40129846e-45L
#define __LDBL_HAS_DENORM__ 1
#define __LDBL_HAS_INFINITY__ 1
#define __LDBL_HAS_QUIET_NAN__ 1
#define __DEC32_MANT_DIG__ 7
#define __DEC32_MIN_EXP__ (-94)
#define __DEC32_MAX_EXP__ 97
#define __DEC32_MIN__ 1E-95DF
#define __DEC32_MAX__ 9.999999E96DF
#define __DEC32_EPSILON__ 1E-6DF
#define __DEC32_SUBNORMAL_MIN__ 0.000001E-95DF
#define __DEC64_MANT_DIG__ 16
#define __DEC64_MIN_EXP__ (-382)
#define __DEC64_MAX_EXP__ 385
#define __DEC64_MIN__ 1E-383DD
#define __DEC64_MAX__ 9.999999999999999E384DD
#define __DEC64_EPSILON__ 1E-15DD
#define __DEC64_SUBNORMAL_MIN__ 0.000000000000001E-383DD
#define __DEC128_MANT_DIG__ 34
#define __DEC128_MIN_EXP__ (-6142)
#define __DEC128_MAX_EXP__ 6145
#define __DEC128_MIN__ 1E-6143DL
#define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL
#define __DEC128_EPSILON__ 1E-33DL
#define __DEC128_SUBNORMAL_MIN__ 0.000000000000000000000000000000001E-6143DL
#define __SFRACT_FBIT__ 7
#define __SFRACT_IBIT__ 0
#define __SFRACT_MIN__ (-0.5HR-0.5HR)
#define __SFRACT_MAX__ 0X7FP-7HR
#define __SFRACT_EPSILON__ 0x1P-7HR
#define __USFRACT_FBIT__ 8
#define __USFRACT_IBIT__ 0
#define __USFRACT_MIN__ 0.0UHR
#define __USFRACT_MAX__ 0XFFP-8UHR
#define __USFRACT_EPSILON__ 0x1P-8UHR
#define __FRACT_FBIT__ 15
#define __FRACT_IBIT__ 0
#define __FRACT_MIN__ (-0.5R-0.5R)
#define __FRACT_MAX__ 0X7FFFP-15R
#define __FRACT_EPSILON__ 0x1P-15R
#define __UFRACT_FBIT__ 16
#define __UFRACT_IBIT__ 0
#define __UFRACT_MIN__ 0.0UR
#define __UFRACT_MAX__ 0XFFFFP-16UR
#define __UFRACT_EPSILON__ 0x1P-16UR
#define __LFRACT_FBIT__ 31
#define __LFRACT_IBIT__ 0
#define __LFRACT_MIN__ (-0.5LR-0.5LR)
#define __LFRACT_MAX__ 0X7FFFFFFFP-31LR
#define __LFRACT_EPSILON__ 0x1P-31LR
#define __ULFRACT_FBIT__ 32
#define __ULFRACT_IBIT__ 0
#define __ULFRACT_MIN__ 0.0ULR
#define __ULFRACT_MAX__ 0XFFFFFFFFP-32ULR
#define __ULFRACT_EPSILON__ 0x1P-32ULR
#define __LLFRACT_FBIT__ 63
#define __LLFRACT_IBIT__ 0
#define __LLFRACT_MIN__ (-0.5LLR-0.5LLR)
#define __LLFRACT_MAX__ 0X7FFFFFFFFFFFFFFFP-63LLR
#define __LLFRACT_EPSILON__ 0x1P-63LLR
#define __ULLFRACT_FBIT__ 64
#define __ULLFRACT_IBIT__ 0
#define __ULLFRACT_MIN__ 0.0ULLR
#define __ULLFRACT_MAX__ 0XFFFFFFFFFFFFFFFFP-64ULLR
#define __ULLFRACT_EPSILON__ 0x1P-64ULLR
#define __SACCUM_FBIT__ 8
#define __SACCUM_IBIT__ 7
#define __SACCUM_MIN__ (-0X1P6HK-0X1P6HK)
#define __SACCUM_MAX__ 0X7FFFP-8HK
#define __SACCUM_EPSILON__ 0x1P-8HK
#define __USACCUM_FBIT__ 8
#define __USACCUM_IBIT__ 8
#define __USACCUM_MIN__ 0.0UHK
#define __USACCUM_MAX__ 0XFFFFP-8UHK
#define __USACCUM_EPSILON__ 0x1P-8UHK
#define __ACCUM_FBIT__ 16
#define __ACCUM_IBIT__ 15
#define __ACCUM_MIN__ (-0X1P14K-0X1P14K)
#define __ACCUM_MAX__ 0X7FFFFFFFP-16K
#define __ACCUM_EPSILON__ 0x1P-16K
#define __UACCUM_FBIT__ 16
#define __UACCUM_IBIT__ 16
#define __UACCUM_MIN__ 0.0UK
#define __UACCUM_MAX__ 0XFFFFFFFFP-16UK
#define __UACCUM_EPSILON__ 0x1P-16UK
#define __LACCUM_FBIT__ 32
#define __LACCUM_IBIT__ 31
#define __LACCUM_MIN__ (-0X1P30LK-0X1P30LK)
#define __LACCUM_MAX__ 0X7FFFFFFFFFFFFFFFP-32LK
#define __LACCUM_EPSILON__ 0x1P-32LK
#define __ULACCUM_FBIT__ 32
#define __ULACCUM_IBIT__ 32
#define __ULACCUM_MIN__ 0.0ULK
#define __ULACCUM_MAX__ 0XFFFFFFFFFFFFFFFFP-32ULK
#define __ULACCUM_EPSILON__ 0x1P-32ULK
#define __LLACCUM_FBIT__ 64
#define __LLACCUM_IBIT__ 63
#define __LLACCUM_MIN__ (-0X1P62LLK-0X1P62LLK)
#define __LLACCUM_MAX__ 0X7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFP-64LLK
#define __LLACCUM_EPSILON__ 0x1P-64LLK
#define __ULLACCUM_FBIT__ 64
#define __ULLACCUM_IBIT__ 64
#define __ULLACCUM_MIN__ 0.0ULLK
#define __ULLACCUM_MAX__ 0XFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFP-64ULLK
#define __ULLACCUM_EPSILON__ 0x1P-64ULLK
#define __QQ_FBIT__ 7
#define __QQ_IBIT__ 0
#define __HQ_FBIT__ 15
#define __HQ_IBIT__ 0
#define __SQ_FBIT__ 31
#define __SQ_IBIT__ 0
#define __DQ_FBIT__ 63
#define __DQ_IBIT__ 0
#define __TQ_FBIT__ 127
#define __TQ_IBIT__ 0
#define __UQQ_FBIT__ 8
#define __UQQ_IBIT__ 0
#define __UHQ_FBIT__ 16
#define __UHQ_IBIT__ 0
#define __USQ_FBIT__ 32
#define __USQ_IBIT__ 0
#define __UDQ_FBIT__ 64
#define __UDQ_IBIT__ 0
#define __UTQ_FBIT__ 128
#define __UTQ_IBIT__ 0
#define __HA_FBIT__ 8
#define __HA_IBIT__ 7
#define __SA_FBIT__ 16
#define __SA_IBIT__ 15
#define __DA_FBIT__ 32
#define __DA_IBIT__ 31
#define __TA_FBIT__ 64
#define __TA_IBIT__ 63
#define __UHA_FBIT__ 8
#define __UHA_IBIT__ 8
#define __USA_FBIT__ 16
#define __USA_IBIT__ 16
#define __UDA_FBIT__ 32
#define __UDA_IBIT__ 32
#define __UTA_FBIT__ 64
#define __UTA_IBIT__ 64
#define __REGISTER_PREFIX__ 
#define __USER_LABEL_PREFIX__ 
#define __VERSION__ "4.5.1"
#define __GNUC_STDC_INLINE__ 1
#define __OPTIMIZE_SIZE__ 1
#define __OPTIMIZE__ 1
#define __FINITE_MATH_ONLY__ 0
#define __PRAGMA_REDEFINE_EXTNAME 1
#define __SIZEOF_INT__ 2
#define __SIZEOF_LONG__ 4
#define __SIZEOF_LONG_LONG__ 8
#define __SIZEOF_SHORT__ 2
#define __SIZEOF_FLOAT__ 4
#define __SIZEOF_DOUBLE__ 4
#define __SIZEOF_LONG_DOUBLE__ 4
#define __SIZEOF_SIZE_T__ 2
#define __SIZEOF_WCHAR_T__ 2
#define __SIZEOF_WINT_T__ 2
#define __SIZEOF_PTRDIFF_T__ 2
#define __SIZEOF_POINTER__ 2
#define __AVR 1
#define __AVR__ 1
#define AVR 1
#define __AVR_ARCH__ 51
#define __AVR_ATmega1284P__ 1
#define __AVR_HAVE_RAMPZ__ 1
#define __AVR_HAVE_ELPM__ 1
#define __AVR_HAVE_ELPMX__ 1
#define __AVR_HAVE_MOVW__ 1
#define __AVR_HAVE_LPMX__ 1
#define __AVR_ENHANCED__ 1
#define __AVR_HAVE_MUL__ 1
#define __AVR_MEGA__ 1
#define __AVR_HAVE_JMP_CALL__ 1
#define __AVR_2_BYTE_PC__ 1
#define __AVR_HAVE_16BIT_SP__ 1
#define __BIGGEST_ALIGNMENT__ 1
# 1 "<command-line>"
#define AVR 1
#define F_CPU 20000000
# 1 ".././kernel.c"
# 9 ".././kernel.c"
# 1 "..\\..\\AntonAvrLib/kernel/reset_condition.kernel.h" 1

#define _INIT_RESET_CONDITION_KERNEL_ 
# 12 "..\\..\\AntonAvrLib/kernel/reset_condition.kernel.h"
# 1 "..\\..\\AntonAvrLib/kernel/kernel_init.h" 1

#define _KERNEL_INIT_H_ 



#define _KERNEL_ 


# 1 "..\\..\\AntonAvrLib/kernel/../anton_std.h" 1
# 12 "..\\..\\AntonAvrLib/kernel/../anton_std.h"
#define ANTON_STD_H_ 

# 1 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/include/stdint.h" 1 3 4


# 1 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdint.h" 1 3 4
# 40 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdint.h" 3 4
#define __STDINT_H_ 
# 57 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdint.h" 3 4
#define __USING_MINT8 0
# 121 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdint.h" 3 4
typedef int int8_t __attribute__((__mode__(__QI__)));
typedef unsigned int uint8_t __attribute__((__mode__(__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int uint16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int uint32_t __attribute__ ((__mode__ (__SI__)));

typedef int int64_t __attribute__((__mode__(__DI__)));
typedef unsigned int uint64_t __attribute__((__mode__(__DI__)));
# 142 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdint.h" 3 4
typedef int16_t intptr_t;




typedef uint16_t uintptr_t;
# 159 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdint.h" 3 4
typedef int8_t int_least8_t;




typedef uint8_t uint_least8_t;




typedef int16_t int_least16_t;




typedef uint16_t uint_least16_t;




typedef int32_t int_least32_t;




typedef uint32_t uint_least32_t;







typedef int64_t int_least64_t;






typedef uint64_t uint_least64_t;
# 213 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdint.h" 3 4
typedef int8_t int_fast8_t;




typedef uint8_t uint_fast8_t;




typedef int16_t int_fast16_t;




typedef uint16_t uint_fast16_t;




typedef int32_t int_fast32_t;




typedef uint32_t uint_fast32_t;







typedef int64_t int_fast64_t;






typedef uint64_t uint_fast64_t;
# 273 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdint.h" 3 4
typedef int64_t intmax_t;




typedef uint64_t uintmax_t;






#define __CONCATenate(left,right) left ## right
#define __CONCAT(left,right) __CONCATenate(left, right)
# 300 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdint.h" 3 4
#define INT8_MAX 0x7f




#define INT8_MIN (-INT8_MAX - 1)




#define UINT8_MAX (__CONCAT(INT8_MAX, U) * 2U + 1U)
# 327 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdint.h" 3 4
#define INT16_MAX 0x7fff




#define INT16_MIN (-INT16_MAX - 1)




#define UINT16_MAX (__CONCAT(INT16_MAX, U) * 2U + 1U)




#define INT32_MAX 0x7fffffffL




#define INT32_MIN (-INT32_MAX - 1L)




#define UINT32_MAX (__CONCAT(INT32_MAX, U) * 2UL + 1UL)






#define INT64_MAX 0x7fffffffffffffffLL




#define INT64_MIN (-INT64_MAX - 1LL)




#define UINT64_MAX (__CONCAT(INT64_MAX, U) * 2ULL + 1ULL)
# 379 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdint.h" 3 4
#define INT_LEAST8_MAX INT8_MAX




#define INT_LEAST8_MIN INT8_MIN




#define UINT_LEAST8_MAX UINT8_MAX




#define INT_LEAST16_MAX INT16_MAX




#define INT_LEAST16_MIN INT16_MIN




#define UINT_LEAST16_MAX UINT16_MAX




#define INT_LEAST32_MAX INT32_MAX




#define INT_LEAST32_MIN INT32_MIN




#define UINT_LEAST32_MAX UINT32_MAX




#define INT_LEAST64_MAX INT64_MAX




#define INT_LEAST64_MIN INT64_MIN




#define UINT_LEAST64_MAX UINT64_MAX
# 445 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdint.h" 3 4
#define INT_FAST8_MAX INT8_MAX




#define INT_FAST8_MIN INT8_MIN




#define UINT_FAST8_MAX UINT8_MAX




#define INT_FAST16_MAX INT16_MAX




#define INT_FAST16_MIN INT16_MIN




#define UINT_FAST16_MAX UINT16_MAX




#define INT_FAST32_MAX INT32_MAX




#define INT_FAST32_MIN INT32_MIN




#define UINT_FAST32_MAX UINT32_MAX




#define INT_FAST64_MAX INT64_MAX




#define INT_FAST64_MIN INT64_MIN




#define UINT_FAST64_MAX UINT64_MAX
# 511 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdint.h" 3 4
#define INTPTR_MAX INT16_MAX




#define INTPTR_MIN INT16_MIN




#define UINTPTR_MAX UINT16_MAX
# 532 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdint.h" 3 4
#define INTMAX_MAX INT64_MAX




#define INTMAX_MIN INT64_MIN




#define UINTMAX_MAX UINT64_MAX
# 555 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdint.h" 3 4
#define PTRDIFF_MAX INT16_MAX




#define PTRDIFF_MIN INT16_MIN
# 569 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdint.h" 3 4
#define SIG_ATOMIC_MAX INT8_MAX




#define SIG_ATOMIC_MIN INT8_MIN





#define SIZE_MAX (__CONCAT(INT16_MAX, U))
# 609 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdint.h" 3 4
#define INT8_C(value) ((int8_t) value)




#define UINT8_C(value) ((uint8_t) __CONCAT(value, U))
# 629 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdint.h" 3 4
#define INT16_C(value) value




#define UINT16_C(value) __CONCAT(value, U)




#define INT32_C(value) __CONCAT(value, L)




#define UINT32_C(value) __CONCAT(value, UL)






#define INT64_C(value) __CONCAT(value, LL)




#define UINT64_C(value) __CONCAT(value, ULL)




#define INTMAX_C(value) __CONCAT(value, LL)




#define UINTMAX_C(value) __CONCAT(value, ULL)
# 4 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/include/stdint.h" 2 3 4



#define _GCC_WRAP_STDINT_H 
# 15 "..\\..\\AntonAvrLib/kernel/../anton_std.h" 2
# 1 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdlib.h" 1 3
# 40 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdlib.h" 3
#define _STDLIB_H_ 1



#define __need_NULL 
#define __need_size_t 
#define __need_wchar_t 
# 1 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/include/stddef.h" 1 3 4
# 186 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/include/stddef.h" 3 4
#define __size_t__ 
#define __SIZE_T__ 
#define _SIZE_T 
#define _SYS_SIZE_T_H 
#define _T_SIZE_ 
#define _T_SIZE 
#define __SIZE_T 
#define _SIZE_T_ 
#define _BSD_SIZE_T_ 
#define _SIZE_T_DEFINED_ 
#define _SIZE_T_DEFINED 
#define _BSD_SIZE_T_DEFINED_ 
#define _SIZE_T_DECLARED 
#define ___int_size_t_h 
#define _GCC_SIZE_T 
#define _SIZET_ 



#define __size_t 





typedef unsigned int size_t;
# 233 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/include/stddef.h" 3 4
#undef __need_size_t
# 262 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/include/stddef.h" 3 4
#define __wchar_t__ 
#define __WCHAR_T__ 
#define _WCHAR_T 
#define _T_WCHAR_ 
#define _T_WCHAR 
#define __WCHAR_T 
#define _WCHAR_T_ 
#define _BSD_WCHAR_T_ 
#define _WCHAR_T_DEFINED_ 
#define _WCHAR_T_DEFINED 
#define _WCHAR_T_H 
#define ___int_wchar_t_h 
#define __INT_WCHAR_T_H 
#define _GCC_WCHAR_T 
#define _WCHAR_T_DECLARED 
# 289 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/include/stddef.h" 3 4
#undef _BSD_WCHAR_T_
# 323 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/include/stddef.h" 3 4
typedef int wchar_t;
# 342 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/include/stddef.h" 3 4
#undef __need_wchar_t
# 395 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/include/stddef.h" 3 4
#undef NULL




#define NULL ((void *)0)





#undef __need_NULL
# 48 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdlib.h" 2 3


#define __ptr_t void *
# 68 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdlib.h" 3
typedef struct {
 int quot;
 int rem;
} div_t;


typedef struct {
 long quot;
 long rem;
} ldiv_t;


typedef int (*__compar_fn_t)(const void *, const void *);




#define __ATTR_CONST__ __attribute__((__const__))



#define __ATTR_MALLOC__ __attribute__((__malloc__))



#define __ATTR_NORETURN__ __attribute__((__noreturn__))



#define __ATTR_PURE__ __attribute__((__pure__))
# 106 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdlib.h" 3
extern void abort(void) __attribute__((__noreturn__));




extern int abs(int __i) __attribute__((__const__));

#define abs(__i) __builtin_abs(__i)






extern long labs(long __i) __attribute__((__const__));

#define labs(__i) __builtin_labs(__i)
# 143 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdlib.h" 3
extern void *bsearch(const void *__key, const void *__base, size_t __nmemb,
       size_t __size, int (*__compar)(const void *, const void *));







extern div_t div(int __num, int __denom) __asm__("__divmodhi4") __attribute__((__const__));





extern ldiv_t ldiv(long __num, long __denom) __asm__("__divmodsi4") __attribute__((__const__));
# 175 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdlib.h" 3
extern void qsort(void *__base, size_t __nmemb, size_t __size,
    __compar_fn_t __compar);
# 208 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdlib.h" 3
extern long strtol(const char *__nptr, char **__endptr, int __base);
# 242 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdlib.h" 3
extern unsigned long strtoul(const char *__nptr, char **__endptr, int __base);
# 254 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdlib.h" 3
extern long atol(const char *__s) __attribute__((__pure__));
# 266 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdlib.h" 3
extern int atoi(const char *__s) __attribute__((__pure__));
# 278 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdlib.h" 3
extern void exit(int __status) __attribute__((__noreturn__));
# 290 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdlib.h" 3
extern void *malloc(size_t __size) __attribute__((__malloc__));






extern void free(void *__ptr);




extern size_t __malloc_margin;




extern char *__malloc_heap_start;




extern char *__malloc_heap_end;






extern void *calloc(size_t __nele, size_t __size) __attribute__((__malloc__));
# 338 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdlib.h" 3
extern void *realloc(void *__ptr, size_t __size) __attribute__((__malloc__));

extern double strtod(const char *__nptr, char **__endptr);

extern double atof(const char *__nptr);


#define RAND_MAX 0x7FFF
# 364 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdlib.h" 3
extern int rand(void);



extern void srand(unsigned int __seed);






extern int rand_r(unsigned long *__ctx);
# 406 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdlib.h" 3
extern char *itoa(int __val, char *__s, int __radix);
# 434 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdlib.h" 3
extern char *ltoa(long int __val, char *__s, int __radix);
# 460 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdlib.h" 3
extern char *utoa(unsigned int __val, char *__s, int __radix);
# 486 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdlib.h" 3
extern char *ultoa(unsigned long int __val, char *__s, int __radix);



#define RANDOM_MAX 0x7FFFFFFF
# 504 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdlib.h" 3
extern long random(void);




extern void srandom(unsigned long __seed);







extern long random_r(unsigned long *__ctx);
# 531 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdlib.h" 3
#define DTOSTR_ALWAYS_SIGN 0x01


#define DTOSTR_PLUS_SIGN 0x02


#define DTOSTR_UPPERCASE 0x04
# 563 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdlib.h" 3
extern char *dtostre(double __val, char *__s, unsigned char __prec,
       unsigned char __flags);
# 580 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/stdlib.h" 3
extern char *dtostrf(double __val, signed char __width,
                     unsigned char __prec, char *__s);
# 16 "..\\..\\AntonAvrLib/kernel/../anton_std.h" 2
# 1 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h" 1 3
# 36 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h" 3
#define _UTIL_DELAY_H_ 1


#define __HAS_DELAY_CYCLES 1


# 1 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/inttypes.h" 1 3
# 35 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/inttypes.h" 3
#define __INTTYPES_H_ 
# 77 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/inttypes.h" 3
typedef int32_t int_farptr_t;



typedef uint32_t uint_farptr_t;
# 96 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/inttypes.h" 3
#define PRId8 "d"


#define PRIdLEAST8 "d"


#define PRIdFAST8 "d"



#define PRIi8 "i"


#define PRIiLEAST8 "i"


#define PRIiFAST8 "i"




#define PRId16 "d"


#define PRIdLEAST16 "d"


#define PRIdFAST16 "d"



#define PRIi16 "i"


#define PRIiLEAST16 "i"


#define PRIiFAST16 "i"




#define PRId32 "ld"


#define PRIdLEAST32 "ld"


#define PRIdFAST32 "ld"



#define PRIi32 "li"


#define PRIiLEAST32 "li"


#define PRIiFAST32 "li"
# 175 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/inttypes.h" 3
#define PRIdPTR PRId16


#define PRIiPTR PRIi16



#define PRIo8 "o"


#define PRIoLEAST8 "o"


#define PRIoFAST8 "o"



#define PRIu8 "u"


#define PRIuLEAST8 "u"


#define PRIuFAST8 "u"



#define PRIx8 "x"


#define PRIxLEAST8 "x"


#define PRIxFAST8 "x"



#define PRIX8 "X"


#define PRIXLEAST8 "X"


#define PRIXFAST8 "X"




#define PRIo16 "o"


#define PRIoLEAST16 "o"


#define PRIoFAST16 "o"



#define PRIu16 "u"


#define PRIuLEAST16 "u"


#define PRIuFAST16 "u"



#define PRIx16 "x"


#define PRIxLEAST16 "x"


#define PRIxFAST16 "x"



#define PRIX16 "X"


#define PRIXLEAST16 "X"


#define PRIXFAST16 "X"




#define PRIo32 "lo"


#define PRIoLEAST32 "lo"


#define PRIoFAST32 "lo"



#define PRIu32 "lu"


#define PRIuLEAST32 "lu"


#define PRIuFAST32 "lu"



#define PRIx32 "lx"


#define PRIxLEAST32 "lx"


#define PRIxFAST32 "lx"



#define PRIX32 "lX"


#define PRIXLEAST32 "lX"


#define PRIXFAST32 "lX"
# 330 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/inttypes.h" 3
#define PRIoPTR PRIo16


#define PRIuPTR PRIu16


#define PRIxPTR PRIx16


#define PRIXPTR PRIX16
# 357 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/inttypes.h" 3
#define SCNd16 "d"


#define SCNdLEAST16 "d"


#define SCNdFAST16 "d"



#define SCNi16 "i"


#define SCNiLEAST16 "i"


#define SCNiFAST16 "i"




#define SCNd32 "ld"


#define SCNdLEAST32 "ld"


#define SCNdFAST32 "ld"



#define SCNi32 "li"


#define SCNiLEAST32 "li"


#define SCNiFAST32 "li"
# 414 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/inttypes.h" 3
#define SCNdPTR SCNd16


#define SCNiPTR SCNi16
# 437 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/inttypes.h" 3
#define SCNo16 "o"


#define SCNoLEAST16 "o"


#define SCNoFAST16 "o"



#define SCNu16 "u"


#define SCNuLEAST16 "u"


#define SCNuFAST16 "u"



#define SCNx16 "x"


#define SCNxLEAST16 "x"


#define SCNxFAST16 "x"




#define SCNo32 "lo"


#define SCNoLEAST32 "lo"


#define SCNoFAST32 "lo"



#define SCNu32 "lu"


#define SCNuLEAST32 "lu"


#define SCNuFAST32 "lu"



#define SCNx32 "lx"


#define SCNxLEAST32 "lx"


#define SCNxFAST32 "lx"
# 519 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/inttypes.h" 3
#define SCNoPTR SCNo16


#define SCNuPTR SCNu16


#define SCNxPTR SCNx16
# 43 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h" 2 3
# 1 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/delay_basic.h" 1 3
# 35 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/delay_basic.h" 3
#define _UTIL_DELAY_BASIC_H_ 1




static inline void _delay_loop_1(uint8_t __count) __attribute__((always_inline));
static inline void _delay_loop_2(uint16_t __count) __attribute__((always_inline));
# 80 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/delay_basic.h" 3
void
_delay_loop_1(uint8_t __count)
{
 __asm__ volatile (
  "1: dec %0" "\n\t"
  "brne 1b"
  : "=r" (__count)
  : "0" (__count)
 );
}
# 102 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/delay_basic.h" 3
void
_delay_loop_2(uint16_t __count)
{
 __asm__ volatile (
  "1: sbiw %0,1" "\n\t"
  "brne 1b"
  : "=w" (__count)
  : "0" (__count)
 );
}
# 44 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h" 2 3
# 83 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h" 3
static inline void _delay_us(double __us) __attribute__((always_inline));
static inline void _delay_ms(double __ms) __attribute__((always_inline));
# 131 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h" 3
void
_delay_ms(double __ms)
{
 uint16_t __ticks;
 double __tmp ;

 uint32_t __ticks_dc;
 extern void __builtin_avr_delay_cycles(unsigned long);
 __tmp = ((20000000) / 1e3) * __ms;
# 149 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h" 3
  __ticks_dc = (uint32_t)(ceil(fabs(__tmp)));


 __builtin_avr_delay_cycles(__ticks_dc);
# 174 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h" 3
}
# 208 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h" 3
void
_delay_us(double __us)
{
 uint8_t __ticks;
 double __tmp ;

 uint32_t __ticks_dc;
 extern void __builtin_avr_delay_cycles(unsigned long);
 __tmp = ((20000000) / 1e6) * __us;
# 226 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h" 3
  __ticks_dc = (uint32_t)(ceil(fabs(__tmp)));


 __builtin_avr_delay_cycles(__ticks_dc);
# 244 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h" 3
}
# 17 "..\\..\\AntonAvrLib/kernel/../anton_std.h" 2
# 1 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/io.h" 1 3
# 97 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/io.h" 3
#define _AVR_IO_H_ 

# 1 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/sfr_defs.h" 1 3
# 36 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/sfr_defs.h" 3
#define _AVR_SFR_DEFS_H_ 1
# 121 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/sfr_defs.h" 3
#define _SFR_ASM_COMPAT 0






#define _MMIO_BYTE(mem_addr) (*(volatile uint8_t *)(mem_addr))
#define _MMIO_WORD(mem_addr) (*(volatile uint16_t *)(mem_addr))
#define _MMIO_DWORD(mem_addr) (*(volatile uint32_t *)(mem_addr))
# 172 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/sfr_defs.h" 3
#define __SFR_OFFSET 0x20



#define _SFR_MEM8(mem_addr) _MMIO_BYTE(mem_addr)
#define _SFR_MEM16(mem_addr) _MMIO_WORD(mem_addr)
#define _SFR_MEM32(mem_addr) _MMIO_DWORD(mem_addr)
#define _SFR_IO8(io_addr) _MMIO_BYTE((io_addr) + __SFR_OFFSET)
#define _SFR_IO16(io_addr) _MMIO_WORD((io_addr) + __SFR_OFFSET)

#define _SFR_MEM_ADDR(sfr) ((uint16_t) &(sfr))
#define _SFR_IO_ADDR(sfr) (_SFR_MEM_ADDR(sfr) - __SFR_OFFSET)
#define _SFR_IO_REG_P(sfr) (_SFR_MEM_ADDR(sfr) < 0x40 + __SFR_OFFSET)

#define _SFR_ADDR(sfr) _SFR_MEM_ADDR(sfr)



#define _SFR_BYTE(sfr) _MMIO_BYTE(_SFR_ADDR(sfr))
#define _SFR_WORD(sfr) _MMIO_WORD(_SFR_ADDR(sfr))
#define _SFR_DWORD(sfr) _MMIO_DWORD(_SFR_ADDR(sfr))
# 208 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/sfr_defs.h" 3
#define _BV(bit) (1 << (bit))




#define _VECTOR(N) __vector_ ## N
# 234 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/sfr_defs.h" 3
#define bit_is_set(sfr,bit) (_SFR_BYTE(sfr) & _BV(bit))
# 245 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/sfr_defs.h" 3
#define bit_is_clear(sfr,bit) (!(_SFR_BYTE(sfr) & _BV(bit)))
# 254 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/sfr_defs.h" 3
#define loop_until_bit_is_set(sfr,bit) do { } while (bit_is_clear(sfr, bit))
# 263 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/sfr_defs.h" 3
#define loop_until_bit_is_clear(sfr,bit) do { } while (bit_is_set(sfr, bit))
# 100 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/io.h" 2 3
# 162 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/io.h" 3
# 1 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/iom1284p.h" 1 3
# 43 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/iom1284p.h" 3
#define _AVR_IOXXX_H_ "iom1284p.h"






#define _AVR_IOM1284P_H_ 1




#define PINA _SFR_IO8(0x00)
#define PINA0 0
#define PINA1 1
#define PINA2 2
#define PINA3 3
#define PINA4 4
#define PINA5 5
#define PINA6 6
#define PINA7 7

#define DDRA _SFR_IO8(0x01)
#define DDA0 0
#define DDA1 1
#define DDA2 2
#define DDA3 3
#define DDA4 4
#define DDA5 5
#define DDA6 6
#define DDA7 7

#define PORTA _SFR_IO8(0x02)
#define PORTA0 0
#define PORTA1 1
#define PORTA2 2
#define PORTA3 3
#define PORTA4 4
#define PORTA5 5
#define PORTA6 6
#define PORTA7 7

#define PINB _SFR_IO8(0x03)
#define PINB0 0
#define PINB1 1
#define PINB2 2
#define PINB3 3
#define PINB4 4
#define PINB5 5
#define PINB6 6
#define PINB7 7

#define DDRB _SFR_IO8(0x04)
#define DDB0 0
#define DDB1 1
#define DDB2 2
#define DDB3 3
#define DDB4 4
#define DDB5 5
#define DDB6 6
#define DDB7 7

#define PORTB _SFR_IO8(0x05)
#define PORTB0 0
#define PORTB1 1
#define PORTB2 2
#define PORTB3 3
#define PORTB4 4
#define PORTB5 5
#define PORTB6 6
#define PORTB7 7

#define PINC _SFR_IO8(0x06)
#define PINC0 0
#define PINC1 1
#define PINC2 2
#define PINC3 3
#define PINC4 4
#define PINC5 5
#define PINC6 6
#define PINC7 7

#define DDRC _SFR_IO8(0x07)
#define DDC0 0
#define DDC1 1
#define DDC2 2
#define DDC3 3
#define DDC4 4
#define DDC5 5
#define DDC6 6
#define DDC7 7

#define PORTC _SFR_IO8(0x08)
#define PORTC0 0
#define PORTC1 1
#define PORTC2 2
#define PORTC3 3
#define PORTC4 4
#define PORTC5 5
#define PORTC6 6
#define PORTC7 7

#define PIND _SFR_IO8(0x09)
#define PIND0 0
#define PIND1 1
#define PIND2 2
#define PIND3 3
#define PIND4 4
#define PIND5 5
#define PIND6 6
#define PIND7 7

#define DDRD _SFR_IO8(0x0A)
#define DDD0 0
#define DDD1 1
#define DDD2 2
#define DDD3 3
#define DDD4 4
#define DDD5 5
#define DDD6 6
#define DDD7 7

#define PORTD _SFR_IO8(0x0B)
#define PORTD0 0
#define PORTD1 1
#define PORTD2 2
#define PORTD3 3
#define PORTD4 4
#define PORTD5 5
#define PORTD6 6
#define PORTD7 7

#define TIFR0 _SFR_IO8(0x15)
#define TOV0 0
#define OCF0A 1
#define OCF0B 2

#define TIFR1 _SFR_IO8(0x16)
#define TOV1 0
#define OCF1A 1
#define OCF1B 2
#define ICF1 5

#define TIFR2 _SFR_IO8(0x17)
#define TOV2 0
#define OCF2A 1
#define OCF2B 2

#define TIFR3 _SFR_IO8(0x18)
#define TOV3 0
#define OCF3A 1
#define OCF3B 2
#define ICF3 5

#define PCIFR _SFR_IO8(0x1B)
#define PCIF0 0
#define PCIF1 1
#define PCIF2 2
#define PCIF3 3

#define EIFR _SFR_IO8(0x1C)
#define INTF0 0
#define INTF1 1
#define INTF2 2

#define EIMSK _SFR_IO8(0x1D)
#define INT0 0
#define INT1 1
#define INT2 2

#define GPIOR0 _SFR_IO8(0x1E)
#define GPIOR00 0
#define GPIOR01 1
#define GPIOR02 2
#define GPIOR03 3
#define GPIOR04 4
#define GPIOR05 5
#define GPIOR06 6
#define GPIOR07 7

#define EECR _SFR_IO8(0x1F)
#define EERE 0
#define EEPE 1
#define EEMPE 2
#define EERIE 3
#define EEPM0 4
#define EEPM1 5

#define EEDR _SFR_IO8(0x20)
#define EEDR0 0
#define EEDR1 1
#define EEDR2 2
#define EEDR3 3
#define EEDR4 4
#define EEDR5 5
#define EEDR6 6
#define EEDR7 7

#define EEAR _SFR_IO16(0x21)

#define EEARL _SFR_IO8(0x21)
#define EEAR0 0
#define EEAR1 1
#define EEAR2 2
#define EEAR3 3
#define EEAR4 4
#define EEAR5 5
#define EEAR6 6
#define EEAR7 7

#define EEARH _SFR_IO8(0x22)
#define EEAR8 0
#define EEAR9 1
#define EEAR10 2
#define EEAR11 3

#define GTCCR _SFR_IO8(0x23)
#define PSRSYNC 0
#define PSRASY 1
#define TSM 7

#define TCCR0A _SFR_IO8(0x24)
#define WGM00 0
#define WGM01 1
#define COM0B0 4
#define COM0B1 5
#define COM0A0 6
#define COM0A1 7

#define TCCR0B _SFR_IO8(0x25)
#define CS00 0
#define CS01 1
#define CS02 2
#define WGM02 3
#define FOC0B 6
#define FOC0A 7

#define TCNT0 _SFR_IO8(0x26)
#define TCNT0_0 0
#define TCNT0_1 1
#define TCNT0_2 2
#define TCNT0_3 3
#define TCNT0_4 4
#define TCNT0_5 5
#define TCNT0_6 6
#define TCNT0_7 7

#define OCR0A _SFR_IO8(0x27)
#define OCR0A_0 0
#define OCR0A_1 1
#define OCR0A_2 2
#define OCR0A_3 3
#define OCR0A_4 4
#define OCR0A_5 5
#define OCR0A_6 6
#define OCR0A_7 7

#define OCR0B _SFR_IO8(0x28)
#define OCR0B_0 0
#define OCR0B_1 1
#define OCR0B_2 2
#define OCR0B_3 3
#define OCR0B_4 4
#define OCR0B_5 5
#define OCR0B_6 6
#define OCR0B_7 7

#define GPIOR1 _SFR_IO8(0x2A)
#define GPIOR10 0
#define GPIOR11 1
#define GPIOR12 2
#define GPIOR13 3
#define GPIOR14 4
#define GPIOR15 5
#define GPIOR16 6
#define GPIOR17 7

#define GPIOR2 _SFR_IO8(0x2B)
#define GPIOR20 0
#define GPIOR21 1
#define GPIOR22 2
#define GPIOR23 3
#define GPIOR24 4
#define GPIOR25 5
#define GPIOR26 6
#define GPIOR27 7

#define SPCR _SFR_IO8(0x2C)
#define SPR0 0
#define SPR1 1
#define CPHA 2
#define CPOL 3
#define MSTR 4
#define DORD 5
#define SPE 6
#define SPIE 7

#define SPSR _SFR_IO8(0x2D)
#define SPI2X 0
#define WCOL 6
#define SPIF 7

#define SPDR _SFR_IO8(0x2E)
#define SPDR0 0
#define SPDR1 1
#define SPDR2 2
#define SPDR3 3
#define SPDR4 4
#define SPDR5 5
#define SPDR6 6
#define SPDR7 7

#define ACSR _SFR_IO8(0x30)
#define ACIS0 0
#define ACIS1 1
#define ACIC 2
#define ACIE 3
#define ACI 4
#define ACO 5
#define ACBG 6
#define ACD 7

#define OCDR _SFR_IO8(0x31)
#define OCDR0 0
#define OCDR1 1
#define OCDR2 2
#define OCDR3 3
#define OCDR4 4
#define OCDR5 5
#define OCDR6 6
#define OCDR7 7

#define SMCR _SFR_IO8(0x33)
#define SE 0
#define SM0 1
#define SM1 2
#define SM2 3

#define MCUSR _SFR_IO8(0x34)
#define PORF 0
#define EXTRF 1
#define BORF 2
#define WDRF 3
#define JTRF 4

#define MCUCR _SFR_IO8(0x35)
#define IVCE 0
#define IVSEL 1
#define PUD 4
#define BODSE 5
#define BODS 6
#define JTD 7

#define SPMCSR _SFR_IO8(0x37)
#define SPMEN 0
#define PGERS 1
#define PGWRT 2
#define BLBSET 3
#define RWWSRE 4
#define SIGRD 5
#define RWWSB 6
#define SPMIE 7

#define RAMPZ _SFR_IO8(0x3B)
#define RAMPZ0 0

#define WDTCSR _SFR_MEM8(0x60)
#define WDP0 0
#define WDP1 1
#define WDP2 2
#define WDE 3
#define WDCE 4
#define WDP3 5
#define WDIE 6
#define WDIF 7

#define CLKPR _SFR_MEM8(0x61)
#define CLKPS0 0
#define CLKPS1 1
#define CLKPS2 2
#define CLKPS3 3
#define CLKPCE 7

#define PRR0 _SFR_MEM8(0x64)
#define PRADC 0
#define PRUSART0 1
#define PRSPI 2
#define PRTIM1 3
#define PRUSART1 4
#define PRTIM0 5
#define PRTIM2 6
#define PRTWI 7

#define PRR1 _SFR_MEM8(0x65)
#define PRTIM3 0

#define OSCCAL _SFR_MEM8(0x66)
#define CAL0 0
#define CAL1 1
#define CAL2 2
#define CAL3 3
#define CAL4 4
#define CAL5 5
#define CAL6 6
#define CAL7 7

#define PCICR _SFR_MEM8(0x68)
#define PCIE0 0
#define PCIE1 1
#define PCIE2 2
#define PCIE3 3

#define EICRA _SFR_MEM8(0x69)
#define ISC00 0
#define ISC01 1
#define ISC10 2
#define ISC11 3
#define ISC20 4
#define ISC21 5

#define PCMSK0 _SFR_MEM8(0x6B)
#define PCINT0 0
#define PCINT1 1
#define PCINT2 2
#define PCINT3 3
#define PCINT4 4
#define PCINT5 5
#define PCINT6 6
#define PCINT7 7

#define PCMSK1 _SFR_MEM8(0x6C)
#define PCINT8 0
#define PCINT9 1
#define PCINT10 2
#define PCINT11 3
#define PCINT12 4
#define PCINT13 5
#define PCINT14 6
#define PCINT15 7

#define PCMSK2 _SFR_MEM8(0x6D)
#define PCINT16 0
#define PCINT17 1
#define PCINT18 2
#define PCINT19 3
#define PCINT20 4
#define PCINT21 5
#define PCINT22 6
#define PCINT23 7

#define TIMSK0 _SFR_MEM8(0x6E)
#define TOIE0 0
#define OCIE0A 1
#define OCIE0B 2

#define TIMSK1 _SFR_MEM8(0x6F)
#define TOIE1 0
#define OCIE1A 1
#define OCIE1B 2
#define ICIE1 5

#define TIMSK2 _SFR_MEM8(0x70)
#define TOIE2 0
#define OCIE2A 1
#define OCIE2B 2

#define TIMSK3 _SFR_MEM8(0x71)
#define TOIE3 0
#define OCIE3A 1
#define OCIE3B 2
#define ICIE3 5

#define PCMSK3 _SFR_MEM8(0x73)
#define PCINT24 0
#define PCINT25 1
#define PCINT26 2
#define PCINT27 3
#define PCINT28 4
#define PCINT29 5
#define PCINT30 6
#define PCINT31 7


#define ADC _SFR_MEM16(0x78)

#define ADCW _SFR_MEM16(0x78)

#define ADCL _SFR_MEM8(0x78)
#define ADCL0 0
#define ADCL1 1
#define ADCL2 2
#define ADCL3 3
#define ADCL4 4
#define ADCL5 5
#define ADCL6 6
#define ADCL7 7

#define ADCH _SFR_MEM8(0x79)
#define ADCH0 0
#define ADCH1 1
#define ADCH2 2
#define ADCH3 3
#define ADCH4 4
#define ADCH5 5
#define ADCH6 6
#define ADCH7 7

#define ADCSRA _SFR_MEM8(0x7A)
#define ADPS0 0
#define ADPS1 1
#define ADPS2 2
#define ADIE 3
#define ADIF 4
#define ADATE 5
#define ADSC 6
#define ADEN 7

#define ADCSRB _SFR_MEM8(0x7B)
#define ADTS0 0
#define ADTS1 1
#define ADTS2 2
#define ACME 6

#define ADMUX _SFR_MEM8(0x7C)
#define MUX0 0
#define MUX1 1
#define MUX2 2
#define MUX3 3
#define MUX4 4
#define ADLAR 5
#define REFS0 6
#define REFS1 7

#define DIDR0 _SFR_MEM8(0x7E)
#define ADC0D 0
#define ADC1D 1
#define ADC2D 2
#define ADC3D 3
#define ADC4D 4
#define ADC5D 5
#define ADC6D 6
#define ADC7D 7

#define DIDR1 _SFR_MEM8(0x7F)
#define AIN0D 0
#define AIN1D 1

#define TCCR1A _SFR_MEM8(0x80)
#define WGM10 0
#define WGM11 1
#define COM1B0 4
#define COM1B1 5
#define COM1A0 6
#define COM1A1 7

#define TCCR1B _SFR_MEM8(0x81)
#define CS10 0
#define CS11 1
#define CS12 2
#define WGM12 3
#define WGM13 4
#define ICES1 6
#define ICNC1 7

#define TCCR1C _SFR_MEM8(0x82)
#define FOC1B 6
#define FOC1A 7

#define TCNT1 _SFR_MEM16(0x84)

#define TCNT1L _SFR_MEM8(0x84)
#define TCNT1L0 0
#define TCNT1L1 1
#define TCNT1L2 2
#define TCNT1L3 3
#define TCNT1L4 4
#define TCNT1L5 5
#define TCNT1L6 6
#define TCNT1L7 7

#define TCNT1H _SFR_MEM8(0x85)
#define TCNT1H0 0
#define TCNT1H1 1
#define TCNT1H2 2
#define TCNT1H3 3
#define TCNT1H4 4
#define TCNT1H5 5
#define TCNT1H6 6
#define TCNT1H7 7

#define ICR1 _SFR_MEM16(0x86)

#define ICR1L _SFR_MEM8(0x86)
#define ICR1L0 0
#define ICR1L1 1
#define ICR1L2 2
#define ICR1L3 3
#define ICR1L4 4
#define ICR1L5 5
#define ICR1L6 6
#define ICR1L7 7

#define ICR1H _SFR_MEM8(0x87)
#define ICR1H0 0
#define ICR1H1 1
#define ICR1H2 2
#define ICR1H3 3
#define ICR1H4 4
#define ICR1H5 5
#define ICR1H6 6
#define ICR1H7 7

#define OCR1A _SFR_MEM16(0x88)

#define OCR1AL _SFR_MEM8(0x88)
#define OCR1AL0 0
#define OCR1AL1 1
#define OCR1AL2 2
#define OCR1AL3 3
#define OCR1AL4 4
#define OCR1AL5 5
#define OCR1AL6 6
#define OCR1AL7 7

#define OCR1AH _SFR_MEM8(0x89)
#define OCR1AH0 0
#define OCR1AH1 1
#define OCR1AH2 2
#define OCR1AH3 3
#define OCR1AH4 4
#define OCR1AH5 5
#define OCR1AH6 6
#define OCR1AH7 7

#define OCR1B _SFR_MEM16(0x8A)

#define OCR1BL _SFR_MEM8(0x8A)
#define OCR1AL0 0
#define OCR1AL1 1
#define OCR1AL2 2
#define OCR1AL3 3
#define OCR1AL4 4
#define OCR1AL5 5
#define OCR1AL6 6
#define OCR1AL7 7

#define OCR1BH _SFR_MEM8(0x8B)
#define OCR1AH0 0
#define OCR1AH1 1
#define OCR1AH2 2
#define OCR1AH3 3
#define OCR1AH4 4
#define OCR1AH5 5
#define OCR1AH6 6
#define OCR1AH7 7

#define TCCR3A _SFR_MEM8(0x90)
#define WGM30 0
#define WGM31 1
#define COM3B0 4
#define COM3B1 5
#define COM3A0 6
#define COM3A1 7

#define TCCR3B _SFR_MEM8(0x91)
#define CS30 0
#define CS31 1
#define CS32 2
#define WGM32 3
#define WGM33 4
#define ICES3 6
#define ICNC3 7

#define TCCR3C _SFR_MEM8(0x92)
#define FOC3B 6
#define FOC3A 7

#define TCNT3 _SFR_MEM16(0x94)

#define TCNT3L _SFR_MEM8(0x94)
#define TCNT3L0 0
#define TCNT3L1 1
#define TCNT3L2 2
#define TCNT3L3 3
#define TCNT3L4 4
#define TCNT3L5 5
#define TCNT3L6 6
#define TCNT3L7 7

#define TCNT3H _SFR_MEM8(0x95)
#define TCNT3H0 0
#define TCNT3H1 1
#define TCNT3H2 2
#define TCNT3H3 3
#define TCNT3H4 4
#define TCNT3H5 5
#define TCNT3H6 6
#define TCNT3H7 7

#define ICR3 _SFR_MEM16(0x96)

#define ICR3L _SFR_MEM8(0x96)
#define ICR3L0 0
#define ICR3L1 1
#define ICR3L2 2
#define ICR3L3 3
#define ICR3L4 4
#define ICR3L5 5
#define ICR3L6 6
#define ICR3L7 7

#define ICR3H _SFR_MEM8(0x97)
#define ICR3H0 0
#define ICR3H1 1
#define ICR3H2 2
#define ICR3H3 3
#define ICR3H4 4
#define ICR3H5 5
#define ICR3H6 6
#define ICR3H7 7

#define OCR3A _SFR_MEM16(0x98)

#define OCR3AL _SFR_MEM8(0x98)
#define OCR3AL0 0
#define OCR3AL1 1
#define OCR3AL2 2
#define OCR3AL3 3
#define OCR3AL4 4
#define OCR3AL5 5
#define OCR3AL6 6
#define OCR3AL7 7

#define OCR3AH _SFR_MEM8(0x99)
#define OCR3AH0 0
#define OCR3AH1 1
#define OCR3AH2 2
#define OCR3AH3 3
#define OCR3AH4 4
#define OCR3AH5 5
#define OCR3AH6 6
#define OCR3AH7 7

#define OCR3B _SFR_MEM16(0x9A)

#define OCR3BL _SFR_MEM8(0x9A)
#define OCR3AL0 0
#define OCR3AL1 1
#define OCR3AL2 2
#define OCR3AL3 3
#define OCR3AL4 4
#define OCR3AL5 5
#define OCR3AL6 6
#define OCR3AL7 7

#define OCR3BH _SFR_MEM8(0x9B)
#define OCR3AH0 0
#define OCR3AH1 1
#define OCR3AH2 2
#define OCR3AH3 3
#define OCR3AH4 4
#define OCR3AH5 5
#define OCR3AH6 6
#define OCR3AH7 7

#define TCCR2A _SFR_MEM8(0xB0)
#define WGM20 0
#define WGM21 1
#define COM2B0 4
#define COM2B1 5
#define COM2A0 6
#define COM2A1 7

#define TCCR2B _SFR_MEM8(0xB1)
#define CS20 0
#define CS21 1
#define CS22 2
#define WGM22 3
#define FOC2B 6
#define FOC2A 7

#define TCNT2 _SFR_MEM8(0xB2)
#define TCNT2_0 0
#define TCNT2_1 1
#define TCNT2_2 2
#define TCNT2_3 3
#define TCNT2_4 4
#define TCNT2_5 5
#define TCNT2_6 6
#define TCNT2_7 7

#define OCR2A _SFR_MEM8(0xB3)
#define OCR2_0 0
#define OCR2_1 1
#define OCR2_2 2
#define OCR2_3 3
#define OCR2_4 4
#define OCR2_5 5
#define OCR2_6 6
#define OCR2_7 7

#define OCR2B _SFR_MEM8(0xB4)
#define OCR2_0 0
#define OCR2_1 1
#define OCR2_2 2
#define OCR2_3 3
#define OCR2_4 4
#define OCR2_5 5
#define OCR2_6 6
#define OCR2_7 7

#define ASSR _SFR_MEM8(0xB6)
#define TCR2BUB 0
#define TCR2AUB 1
#define OCR2BUB 2
#define OCR2AUB 3
#define TCN2UB 4
#define AS2 5
#define EXCLK 6

#define TWBR _SFR_MEM8(0xB8)
#define TWBR0 0
#define TWBR1 1
#define TWBR2 2
#define TWBR3 3
#define TWBR4 4
#define TWBR5 5
#define TWBR6 6
#define TWBR7 7

#define TWSR _SFR_MEM8(0xB9)
#define TWPS0 0
#define TWPS1 1
#define TWS3 3
#define TWS4 4
#define TWS5 5
#define TWS6 6
#define TWS7 7

#define TWAR _SFR_MEM8(0xBA)
#define TWGCE 0
#define TWA0 1
#define TWA1 2
#define TWA2 3
#define TWA3 4
#define TWA4 5
#define TWA5 6
#define TWA6 7

#define TWDR _SFR_MEM8(0xBB)
#define TWD0 0
#define TWD1 1
#define TWD2 2
#define TWD3 3
#define TWD4 4
#define TWD5 5
#define TWD6 6
#define TWD7 7

#define TWCR _SFR_MEM8(0xBC)
#define TWIE 0
#define TWEN 2
#define TWWC 3
#define TWSTO 4
#define TWSTA 5
#define TWEA 6
#define TWINT 7

#define TWAMR _SFR_MEM8(0xBD)
#define TWAM0 1
#define TWAM1 2
#define TWAM2 3
#define TWAM3 4
#define TWAM4 5
#define TWAM5 6
#define TWAM6 7

#define UCSR0A _SFR_MEM8(0xC0)
#define MPCM0 0
#define U2X0 1
#define UPE0 2
#define DOR0 3
#define FE0 4
#define UDRE0 5
#define TXC0 6
#define RXC0 7

#define UCSR0B _SFR_MEM8(0xC1)
#define TXB80 0
#define RXB80 1
#define UCSZ02 2
#define TXEN0 3
#define RXEN0 4
#define UDRIE0 5
#define TXCIE0 6
#define RXCIE0 7

#define UCSR0C _SFR_MEM8(0xC2)
#define UCPOL0 0
#define UCSZ00 1
#define UCSZ01 2
#define USBS0 3
#define UPM00 4
#define UPM01 5
#define UMSEL00 6
#define UMSEL01 7

#define UBRR0 _SFR_MEM16(0xC4)

#define UBRR0L _SFR_MEM8(0xC4)
#define UBRR0_0 0
#define UBRR0_1 1
#define UBRR0_2 2
#define UBRR0_3 3
#define UBRR0_4 4
#define UBRR0_5 5
#define UBRR0_6 6
#define UBRR0_7 7

#define UBRR0H _SFR_MEM8(0xC5)
#define UBRR0_8 0
#define UBRR0_9 1
#define UBRR0_10 2
#define UBRR0_11 3

#define UDR0 _SFR_MEM8(0xC6)
#define UDR0_0 0
#define UDR0_1 1
#define UDR0_2 2
#define UDR0_3 3
#define UDR0_4 4
#define UDR0_5 5
#define UDR0_6 6
#define UDR0_7 7

#define UCSR1A _SFR_MEM8(0xC8)
#define MPCM1 0
#define U2X1 1
#define UPE1 2
#define DOR1 3
#define FE1 4
#define UDRE1 5
#define TXC1 6
#define RXC1 7

#define UCSR1B _SFR_MEM8(0xC9)
#define TXB81 0
#define RXB81 1
#define UCSZ12 2
#define TXEN1 3
#define RXEN1 4
#define UDRIE1 5
#define TXCIE1 6
#define RXCIE1 7

#define UCSR1C _SFR_MEM8(0xCA)
#define UCPOL1 0
#define UCSZ10 1
#define UCSZ11 2
#define USBS1 3
#define UPM10 4
#define UPM11 5
#define UMSEL10 6
#define UMSEL11 7

#define UBRR1 _SFR_MEM16(0xCC)

#define UBRR1L _SFR_MEM8(0xCC)
#define UBRR1_0 0
#define UBRR1_1 1
#define UBRR1_2 2
#define UBRR1_3 3
#define UBRR1_4 4
#define UBRR1_5 5
#define UBRR1_6 6
#define UBRR1_7 7

#define UBRR1H _SFR_MEM8(0xCD)
#define UBRR1_8 0
#define UBRR1_9 1
#define UBRR1_10 2
#define UBRR1_11 3

#define UDR1 _SFR_MEM8(0xCE)
#define UDR1_0 0
#define UDR1_1 1
#define UDR1_2 2
#define UDR1_3 3
#define UDR1_4 4
#define UDR1_5 5
#define UDR1_6 6
#define UDR1_7 7





#define INT0_vect _VECTOR(1)
#define INT1_vect _VECTOR(2)
#define INT2_vect _VECTOR(3)
#define PCINT0_vect _VECTOR(4)
#define PCINT1_vect _VECTOR(5)
#define PCINT2_vect _VECTOR(6)
#define PCINT3_vect _VECTOR(7)
#define WDT_vect _VECTOR(8)
#define TIMER2_COMPA_vect _VECTOR(9)
#define TIMER2_COMPB_vect _VECTOR(10)
#define TIMER2_OVF_vect _VECTOR(11)
#define TIMER1_CAPT_vect _VECTOR(12)
#define TIMER1_COMPA_vect _VECTOR(13)
#define TIMER1_COMPB_vect _VECTOR(14)
#define TIMER1_OVF_vect _VECTOR(15)
#define TIMER0_COMPA_vect _VECTOR(16)
#define TIMER0_COMPB_vect _VECTOR(17)
#define TIMER0_OVF_vect _VECTOR(18)
#define SPI_STC_vect _VECTOR(19)
#define USART0_RX_vect _VECTOR(20)
#define USART0_UDRE_vect _VECTOR(21)
#define USART0_TX_vect _VECTOR(22)
#define ANALOG_COMP_vect _VECTOR(23)
#define ADC_vect _VECTOR(24)
#define EE_READY_vect _VECTOR(25)
#define TWI_vect _VECTOR(26)
#define SPM_READY_vect _VECTOR(27)
#define USART1_RX_vect _VECTOR(28)
#define USART1_UDRE_vect _VECTOR(29)
#define USART1_TX_vect _VECTOR(30)
#define TIMER3_CAPT_vect _VECTOR(31)
#define TIMER3_COMPA_vect _VECTOR(32)
#define TIMER3_COMPB_vect _VECTOR(33)
#define TIMER3_OVF_vect _VECTOR(34)

#define _VECTORS_SIZE (35 * 4)



#define SPM_PAGESIZE 256
#define RAMSTART (0x100)
#define RAMEND 0x40FF
#define XRAMSIZE 0
#define XRAMEND RAMEND
#define E2END 0xFFF
#define E2PAGESIZE 8
#define FLASHEND 0x1FFFF



#define FUSE_MEMORY_SIZE 3


#define FUSE_CKSEL0 (unsigned char)~_BV(0)
#define FUSE_CKSEL1 (unsigned char)~_BV(1)
#define FUSE_CKSEL2 (unsigned char)~_BV(2)
#define FUSE_CKSEL3 (unsigned char)~_BV(3)
#define FUSE_SUT0 (unsigned char)~_BV(4)
#define FUSE_SUT1 (unsigned char)~_BV(5)
#define FUSE_CKOUT (unsigned char)~_BV(6)
#define FUSE_CKDIV8 (unsigned char)~_BV(7)
#define LFUSE_DEFAULT (FUSE_CKSEL0 & FUSE_CKSEL2 & FUSE_CKSEL3 & FUSE_SUT0 & FUSE_SUT1 & FUSE_CKDIV8)


#define FUSE_BOOTRST (unsigned char)~_BV(0)
#define FUSE_BOOTSZ0 (unsigned char)~_BV(1)
#define FUSE_BOOTSZ1 (unsigned char)~_BV(2)
#define FUSE_EESAVE (unsigned char)~_BV(3)
#define FUSE_WDTON (unsigned char)~_BV(4)
#define FUSE_SPIEN (unsigned char)~_BV(5)
#define FUSE_JTAGEN (unsigned char)~_BV(6)
#define FUSE_OCDEN (unsigned char)~_BV(7)
#define HFUSE_DEFAULT (FUSE_BOOTSZ0 & FUSE_SPIEN & FUSE_JTAGEN)


#define FUSE_BODLEVEL0 (unsigned char)~_BV(0)
#define FUSE_BODLEVEL1 (unsigned char)~_BV(1)
#define FUSE_BODLEVEL2 (unsigned char)~_BV(2)
#define EFUSE_DEFAULT (0xFF)



#define __LOCK_BITS_EXIST 
#define __BOOT_LOCK_BITS_0_EXIST 
#define __BOOT_LOCK_BITS_1_EXIST 



#define SIGNATURE_0 0x1E
#define SIGNATURE_1 0x97
#define SIGNATURE_2 0x05
# 163 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/io.h" 2 3
# 534 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/io.h" 3
# 1 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/portpins.h" 1 3
# 34 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/portpins.h" 3
#define _AVR_PORTPINS_H_ 1
# 45 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/portpins.h" 3
#define PORT7 7
#define PORT6 6
#define PORT5 5
#define PORT4 4
#define PORT3 3
#define PORT2 2
#define PORT1 1
#define PORT0 0


#define DD7 7
#define DD6 6
#define DD5 5
#define DD4 4
#define DD3 3
#define DD2 2
#define DD1 1
#define DD0 0


#define PIN7 7
#define PIN6 6
#define PIN5 5
#define PIN4 4
#define PIN3 3
#define PIN2 2
#define PIN1 1
#define PIN0 0
# 81 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/portpins.h" 3
#define PA0 PORTA0




#define PA1 PORTA1




#define PA2 PORTA2




#define PA3 PORTA3




#define PA4 PORTA4




#define PA5 PORTA5




#define PA6 PORTA6




#define PA7 PORTA7







#define PB0 PORTB0




#define PB1 PORTB1




#define PB2 PORTB2




#define PB3 PORTB3




#define PB4 PORTB4




#define PB5 PORTB5




#define PB6 PORTB6




#define PB7 PORTB7







#define PC0 PORTC0




#define PC1 PORTC1




#define PC2 PORTC2




#define PC3 PORTC3




#define PC4 PORTC4




#define PC5 PORTC5




#define PC6 PORTC6




#define PC7 PORTC7







#define PD0 PORTD0




#define PD1 PORTD1




#define PD2 PORTD2




#define PD3 PORTD3




#define PD4 PORTD4




#define PD5 PORTD5




#define PD6 PORTD6




#define PD7 PORTD7
# 535 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/io.h" 2 3

# 1 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/common.h" 1 3
# 35 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/common.h" 3
#define _AVR_COMMON_H 
# 81 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/common.h" 3
#define SPL _SFR_IO8(0x3D)







#define SP _SFR_IO16(0x3D)


#define SPH _SFR_IO8(0x3E)
# 103 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/common.h" 3
#define SREG _SFR_IO8(0x3F)






#define SREG_C (0)


#define SREG_Z (1)


#define SREG_N (2)


#define SREG_V (3)


#define SREG_S (4)


#define SREG_H (5)


#define SREG_T (6)


#define SREG_I (7)
# 203 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/common.h" 3
#define XL r26
#define XH r27
#define YL r28
#define YH r29

#define ZL r30
#define ZH r31




#define AVR_STATUS_REG SREG



#define AVR_STATUS_ADDR _SFR_IO_ADDR(SREG)





#define AVR_STACK_POINTER_REG SP



#define AVR_STACK_POINTER_ADDR _SFR_IO_ADDR(SP)





#define _HAVE_AVR_STACK_POINTER_HI 1
#define AVR_STACK_POINTER_HI_REG SPH



#define AVR_STACK_POINTER_HI_ADDR _SFR_IO_ADDR(SPH)





#define AVR_STACK_POINTER_LO_REG SPL



#define AVR_STACK_POINTER_LO_ADDR _SFR_IO_ADDR(SPL)
# 285 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/common.h" 3
#define AVR_RAMPZ_REG RAMPZ



#define AVR_RAMPZ_ADDR _SFR_IO_ADDR(RAMPZ)
# 537 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/io.h" 2 3

# 1 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/version.h" 1 3
# 54 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/version.h" 3
#define _AVR_VERSION_H_ 



#define __AVR_LIBC_VERSION_STRING__ "1.7.1"
# 68 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/version.h" 3
#define __AVR_LIBC_VERSION__ 10701UL



#define __AVR_LIBC_DATE_STRING__ "20110216"



#define __AVR_LIBC_DATE_ 20110216UL



#define __AVR_LIBC_MAJOR__ 1



#define __AVR_LIBC_MINOR__ 7



#define __AVR_LIBC_REVISION__ 1
# 539 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/io.h" 2 3


# 1 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/fuse.h" 1 3
# 36 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/fuse.h" 3
#define _AVR_FUSE_H_ 1
# 226 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/fuse.h" 3
#define FUSEMEM __attribute__((section (".fuse")))
# 239 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/fuse.h" 3
typedef struct
{
    unsigned char low;
    unsigned char high;
    unsigned char extended;
} __fuse_t;
# 267 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/fuse.h" 3
#define FUSES __fuse_t __fuse FUSEMEM
# 542 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/io.h" 2 3


# 1 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/lock.h" 1 3
# 36 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/lock.h" 3
#define _AVR_LOCK_H_ 1
# 190 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/lock.h" 3
#define LOCKMEM __attribute__((section (".lock")))



#define LOCKBITS unsigned char __lock LOCKMEM







#define LB_MODE_1 (0xFF)
#define LB_MODE_2 (0xFE)
#define LB_MODE_3 (0xFC)



#define BLB0_MODE_1 (0xFF)
#define BLB0_MODE_2 (0xFB)
#define BLB0_MODE_3 (0xF3)
#define BLB0_MODE_4 (0xF7)



#define BLB1_MODE_1 (0xFF)
#define BLB1_MODE_2 (0xEF)
#define BLB1_MODE_3 (0xCF)
#define BLB1_MODE_4 (0xDF)
# 237 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/lock.h" 3
#define LOCKBITS_DEFAULT (0xFF)
# 545 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/io.h" 2 3
# 18 "..\\..\\AntonAvrLib/kernel/../anton_std.h" 2
# 1 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/interrupt.h" 1 3
# 36 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/interrupt.h" 3
#define _AVR_INTERRUPT_H_ 





#define __STRINGIFY(x) #x
# 83 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/interrupt.h" 3
#define sei() __asm__ __volatile__ ("sei" ::: "memory")
# 103 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/interrupt.h" 3
#define cli() __asm__ __volatile__ ("cli" ::: "memory")
# 135 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/interrupt.h" 3
#define __INTR_ATTRS used, externally_visible
# 145 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/interrupt.h" 3
#define ISR(vector,...) void vector (void) __attribute__ ((signal,__INTR_ATTRS)) __VA_ARGS__; void vector (void)
# 172 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/interrupt.h" 3
#define SIGNAL(vector) void vector (void) __attribute__ ((signal, __INTR_ATTRS)); void vector (void)
# 198 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/interrupt.h" 3
#define EMPTY_INTERRUPT(vector) void vector (void) __attribute__ ((signal,naked,__INTR_ATTRS)); void vector (void) { __asm__ __volatile__ ("reti" ::); }
# 250 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/interrupt.h" 3
#define ISR_ALIAS(vector,tgt) void vector (void) __attribute__((signal, naked, __INTR_ATTRS)); void vector (void) { asm volatile ("jmp " __STRINGIFY(tgt) ::); }
# 277 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/interrupt.h" 3
#define reti() __asm__ __volatile__ ("reti" ::)
# 293 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/interrupt.h" 3
#define BADISR_vect __vector_default
# 357 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/interrupt.h" 3
#define ISR_BLOCK 
#define ISR_NOBLOCK __attribute__((interrupt))
#define ISR_NAKED __attribute__((naked))
#define ISR_ALIASOF(v) __attribute__((alias(__STRINGIFY(v))))
# 19 "..\\..\\AntonAvrLib/kernel/../anton_std.h" 2

typedef enum {
 FALSE,
 TRUE
} BOOL;

typedef uint8_t byte;

asm ("__RAMPZ__ = 0x3b");

#define ZERO_STRUCT(variableName,structName) uint8_t *___tmpStructContent = variableName; for (int __i = 0; __i < sizeof(structName); __i++) { ___tmpStructContent[i] = 0; }





#define __CONCAT__(A,B) A ##B


#define DEFINE_HANDLE(name) typedef struct name ##__ { uint16_t unused; } *name;


#define LOBYTE(x) (uint8_t)((uint16_t)x)
#define HIBYTE(x) (uint8_t)(((uint16_t)x)>>8)
#define MAKE_WORD(hi,lo) ((hi*0x100)+lo)
#define AS_WORD(b) MAKE_WORD(b, 0)

#define enable_interrupts() sei()
#define disable_interrupts() cli()

#define delay(x) _delay_ms(x)
# 10 "..\\..\\AntonAvrLib/kernel/kernel_init.h" 2
# 18 "..\\..\\AntonAvrLib/kernel/kernel_init.h"
#define KERNEL_INIT(functionName) void functionName ##_kernel_init() __attribute__((naked, section(".init8"))); void functionName ##_kernel_init() { functionName(); }
# 13 "..\\..\\AntonAvrLib/kernel/reset_condition.kernel.h" 2
# 1 "..\\..\\AntonAvrLib/kernel/reset_condition.h" 1
# 9 "..\\..\\AntonAvrLib/kernel/reset_condition.h"
#define RESET_CONDITION_H_ 

# 1 "..\\..\\AntonAvrLib/kernel/devices/led.h" 1
# 9 "..\\..\\AntonAvrLib/kernel/devices/led.h"
#define LED_H_ 

# 1 "..\\..\\AntonAvrLib/kernel/devices/port.h" 1
# 9 "..\\..\\AntonAvrLib/kernel/devices/port.h"
#define PORT_H_ 

# 1 "..\\..\\AntonAvrLib/kernel/devices/../../anton_std.h" 1
# 12 "..\\..\\AntonAvrLib/kernel/devices/port.h" 2

typedef struct {
 volatile uint8_t *port;
 volatile uint8_t *pin;
 volatile uint8_t *ddr;
} Port, *PPort;

typedef struct {
 PPort port;
 uint8_t mask;
} Pin, *PPin;

void setPortOutput(PPort port);
void setPortInput(PPort port);

void setPinOutput(PPin pin);
void setPinInput(PPin pin);

void writePort(PPort port, uint8_t value);
uint8_t readPort(PPort port);

void writePin(PPin pin, BOOL value);
void setPinOne(PPin pin);
void setPinZero(PPin pin);

BOOL readPin(PPin pin);


#define DEFINE_PIN(port,pin) Pin Pin ##port ##pin ##_; const PPin Pin ##port ##pin = &Pin ##port ##pin ##_;


#define DEFINE_PORT(port) Port Port ##port ##_; const PPort Port ##port = &Port ##port ##_;


#define INIT_PIN(port,pin) Pin ##port ##pin ##_ = (Pin) { Port ##port, _BV(PIN ##port ##pin) };

#define INIT_PORT(port) Port ##port ##_ = (Port) { &PORT ##port, &PIN ##port, &DDR ##port };

#define INIT_PORT_AND_PINS(port) INIT_PORT(port) INIT_PIN(port,0) INIT_PIN(port,1) INIT_PIN(port,2) INIT_PIN(port,3) INIT_PIN(port,4) INIT_PIN(port,5) INIT_PIN(port,6) INIT_PIN(port,7)
# 67 "..\\..\\AntonAvrLib/kernel/devices/port.h"
#define DEFINE_PORT_AND_PINS(port) DEFINE_PORT(port) DEFINE_PIN(port,0) DEFINE_PIN(port,1) DEFINE_PIN(port,2) DEFINE_PIN(port,3) DEFINE_PIN(port,4) DEFINE_PIN(port,5) DEFINE_PIN(port,6) DEFINE_PIN(port,7)
# 12 "..\\..\\AntonAvrLib/kernel/devices/led.h" 2


typedef struct {
 PPin pin;
} Led, *PLed;

typedef struct {
 PLed *leds;
 uint8_t count;
} LedGroup, *PLedGroup;

void enableLed(PLed led);
void disableLed(PLed led);
void setLed(PLed led, BOOL value);


void setLeds(PLedGroup leds, uint16_t mask);

void enableLeds(PLedGroup leds);
void disableLeds(PLedGroup leds);

void blinkLed(PLed led, const uint8_t times);
void blinkLeds(PLedGroup leds, uint16_t ledMask, uint8_t times);
void blinkAllLeds(PLedGroup leds, uint8_t times);

void flashLed(PLed led, const uint16_t millis);
void flashLeds(PLedGroup leds, uint16_t ledMask, uint16_t millis);
void flashAllLeds(PLedGroup leds, uint16_t millis);



void blinkByte(PLedGroup display, PLedGroup notifier, byte data);


#define DEFINE_LED(ledName) Led ledName ##_; const PLed ledName = &ledName ##_;


#define DEFINE_LED_GROUP(groupName) LedGroup groupName ##_; const PLedGroup groupName = &groupName ##_;


#define INIT_LED(ledName,pinName) ledName ##_ = (Led) { pinName }; initLed(ledName);


#define INIT_LED_GROUP(groupName,groupArrayPointer,count) groupName ##_ = (LedGroup) { groupArrayPointer, count };
# 12 "..\\..\\AntonAvrLib/kernel/reset_condition.h" 2


uint8_t getResetStatus();


uint16_t resetStatusBitmask();





void blink_reset_condition(PLedGroup leds);


void blink_reset_condition_byte(PLedGroup blinker, PLedGroup notifier);
# 14 "..\\..\\AntonAvrLib/kernel/reset_condition.kernel.h" 2
# 1 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/wdt.h" 1 3
# 39 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/wdt.h" 3
#define _AVR_WDT_H_ 
# 99 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/wdt.h" 3
#define wdt_reset() __asm__ __volatile__ ("wdr")



#define _WD_PS3_MASK _BV(WDP3)





#define _WD_CONTROL_REG WDTCSR







#define _WD_CHANGE_BIT WDCE
# 326 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/wdt.h" 3
#define wdt_enable(value) __asm__ __volatile__ ( "in __tmp_reg__,__SREG__" "\n\t" "cli" "\n\t" "wdr" "\n\t" "sts %0,%1" "\n\t" "out __SREG__,__tmp_reg__" "\n\t" "sts %0,%2" "\n\t" : : "M" (_SFR_MEM_ADDR(_WD_CONTROL_REG)), "r" (_BV(_WD_CHANGE_BIT) | _BV(WDE)), "r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) | _BV(WDE) | (value & 0x07)) ) : "r0" )
# 342 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/wdt.h" 3
#define wdt_disable() __asm__ __volatile__ ( "in __tmp_reg__, __SREG__" "\n\t" "cli" "\n\t" "sts %0, %1" "\n\t" "sts %0, __zero_reg__" "\n\t" "out __SREG__,__tmp_reg__" "\n\t" : : "M" (_SFR_MEM_ADDR(_WD_CONTROL_REG)), "r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))) : "r0" )
# 421 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/wdt.h" 3
#define WDTO_15MS 0



#define WDTO_30MS 1



#define WDTO_60MS 2



#define WDTO_120MS 3



#define WDTO_250MS 4



#define WDTO_500MS 5



#define WDTO_1S 6



#define WDTO_2S 7
# 472 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/wdt.h" 3
#define WDTO_4S 8
# 497 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/wdt.h" 3
#define WDTO_8S 9
# 15 "..\\..\\AntonAvrLib/kernel/reset_condition.kernel.h" 2

uint8_t current_reset_status = 0;

void init_reset_condition() {



 current_reset_status = (*(volatile uint8_t *)((0x34) + 0x20));
 (*(volatile uint8_t *)((0x34) + 0x20)) = 0;

  __asm__ __volatile__ ( "in __tmp_reg__, __SREG__" "\n\t" "cli" "\n\t" "sts %0, %1" "\n\t" "sts %0, __zero_reg__" "\n\t" "out __SREG__,__tmp_reg__" "\n\t" : : "M" (((uint16_t) &((*(volatile uint8_t *)(0x60))))), "r" ((uint8_t)((1 << (4)) | (1 << (3)))) : "r0" );

}
void init_reset_condition_kernel_init() __attribute__((naked, section(".init8"))); void init_reset_condition_kernel_init() { init_reset_condition(); }

uint8_t getResetStatus() {
 return current_reset_status;
}
# 10 ".././kernel.c" 2
# 1 ".././shared/base_before.kernel.h" 1
# 9 ".././shared/base_before.kernel.h"
#define _BASE_BEFORE_KERNEL_ 


# 1 "..\\..\\AntonAvrLib/kernel/kernel_init.h" 1
# 13 ".././shared/base_before.kernel.h" 2
# 1 ".././shared/../kernel.h" 1
# 9 ".././shared/../kernel.h"
#define KERNEL_H_ 
# 18 ".././shared/../kernel.h"
# 1 ".././shared/../shared/kernel_base.h" 1
# 9 ".././shared/../shared/kernel_base.h"
#define KERNEL_BASE_H_ 


# 1 "..\\..\\AntonAvrLib/kernel/millisecond_clock.h" 1
# 9 "..\\..\\AntonAvrLib/kernel/millisecond_clock.h"
#define MILLISECOND_CLOCK_H_ 





 uint32_t volatile milliseconds_running = 0;






uint32_t get_milliseconds_running();
# 13 ".././shared/../shared/kernel_base.h" 2
# 1 "..\\..\\AntonAvrLib/kernel/reset_condition.h" 1
# 14 ".././shared/../shared/kernel_base.h" 2
# 1 "..\\..\\AntonAvrLib/kernel/processes/mutex/mutex.h" 1
# 9 "..\\..\\AntonAvrLib/kernel/processes/mutex/mutex.h"
#define MUTEX_H_ 

# 1 "..\\..\\AntonAvrLib/kernel/processes/mutex/../../../anton_std.h" 1
# 12 "..\\..\\AntonAvrLib/kernel/processes/mutex/mutex.h" 2


typedef struct Mutex__ { uint16_t unused; } *Mutex;

Mutex mutex_create();

void mutex_lock(Mutex mutex);
BOOL mutex_trylock(Mutex mutex);
void mutex_release(Mutex mutex);
# 15 ".././shared/../shared/kernel_base.h" 2
# 1 "..\\..\\AntonAvrLib/anton_std.h" 1
# 16 ".././shared/../shared/kernel_base.h" 2
# 19 ".././shared/../kernel.h" 2
# 1 ".././shared/../tank_button.h" 1
# 9 ".././shared/../tank_button.h"
#define TANK_BUTTON_H_ 

# 1 "..\\..\\AntonAvrLib/kernel/devices/button.h" 1
# 9 "..\\..\\AntonAvrLib/kernel/devices/button.h"
#define BUTTON_H_ 




#define BUTTON_NORMAL 0
#define BUTTON_INVERTED _BV(0)
#define BUTTON_NEEDS_PULLUP _BV(1)
#define BUTTON_USE_PIN_CHANGE_INTERRUPT _BV(2)

typedef struct {
 uint8_t flags;
 PPin pin;
 uint8_t pinChangeInterruptNumber;
} Button, *PButton;


BOOL buttonStatus(PButton button);


#define DEFINE_BUTTON(buttonName) Button buttonName ##_; const PButton buttonName = &buttonName ##_;


#define INIT_BUTTON(buttonName,pinName,flags,interruptNumber) buttonName ##_ = (Button) { flags, pinName, interruptNumber }; initButton(buttonName);
# 12 ".././shared/../tank_button.h" 2
# 1 ".././shared/../shared/tank_IO_protocol.h" 1

#define TANK_IO_PROTOCOL_H_ 

#define TANK_IO_ADDRESS (11 << 2)



#define TANK_IO_INITIALIZED 214

typedef enum {
 LEDS_ALL,
 LEDS_LEFT,
 LEDS_RIGHT,
 LEDS_MIDDLE,
 LEDS_RED,
 LEDS_YELLOW,
 LEDS_WHITE,
 LEDS_GREEN
} TankIoLeds;


typedef enum {
 BUTTON_1 = (1 << (0)),
 BUTTON_2 = (1 << (1)),
 BUTTON_3 = (1 << (2)),
 BUTTON_4 = (1 << (3)),
 BUTTON_SWITCH = (1 << (4))
} TankButton;

typedef struct {
 TankIoLeds leds;
 uint16_t mask;
} MaskedLeds;

typedef struct {
 TankIoLeds leds;
 uint8_t index;
} SingleLed;

typedef struct {
 SingleLed led;
 BOOL value;
} SetLedParam;

typedef struct {
 SingleLed led;
 uint8_t times;
} BlinkLedParam;

typedef struct {
 MaskedLeds leds;
 uint8_t times;
} BlinkLedsParam;

typedef struct {
 TankIoLeds leds;
 uint8_t times;
} BlinkAllLedsParam;

typedef struct {
 SingleLed led;
 uint16_t milliseconds;
} FlashLedParam;

typedef struct {
 MaskedLeds leds;
 uint16_t milliseconds;
} FlashLedsParam;

typedef struct {
 TankIoLeds leds;
 uint16_t milliseconds;
} FlashAllLedsParam;

typedef struct {
 TankIoLeds display;
 TankIoLeds notifier;
 byte data;
} BlinkByteParam;

enum {


 TANK_IO_reset = 0xA0,

 TANK_IO_isInitialized = 0xA1,


 TANK_IO_buttonStatus = 0xA2,

 TANK_IO_pressedButtons = 0xA3,


 TANK_IO_enableLed = 0xA4,
 TANK_IO_disableLed = 0xA5,
 TANK_IO_setLed = 0xA6,

 TANK_IO_setLeds = 0xA7,
 TANK_IO_enableLeds = 0xA8,
 TANK_IO_disableLeds = 0xA9,

 TANK_IO_blinkLed = 0xAA,
 TANK_IO_blinkLeds = 0xAB,
 TANK_IO_blinkAllLeds = 0xAC,

 TANK_IO_flashLed = 0xAD,
 TANK_IO_flashLeds = 0xAE,
 TANK_IO_flashAllLeds = 0xAF,

 TANK_IO_blinkByte = 0xB0,
};
# 13 ".././shared/../tank_button.h" 2

Button Button1_; const PButton Button1 = &Button1_;
Button Button2_; const PButton Button2 = &Button2_;
Button Button3_; const PButton Button3 = &Button3_;
Button Button4_; const PButton Button4 = &Button4_;
Button ButtonSwitch_; const PButton ButtonSwitch = &ButtonSwitch_;

uint8_t buttonStatusMask();



void updateButtonStatus();



uint8_t pressedButtons();
# 20 ".././shared/../kernel.h" 2
# 1 ".././shared/../tank_led.h" 1
# 9 ".././shared/../tank_led.h"
#define NIBOBEE_LED_H_ 

# 1 "..\\..\\AntonAvrLib/kernel/devices/led.h" 1
# 12 ".././shared/../tank_led.h" 2

Led White1_; const PLed White1 = &White1_;
Led White2_; const PLed White2 = &White2_;
Led White3_; const PLed White3 = &White3_;
Led White4_; const PLed White4 = &White4_;
Led White5_; const PLed White5 = &White5_;

Led Red1_; const PLed Red1 = &Red1_;
Led Red2_; const PLed Red2 = &Red2_;
Led Red3_; const PLed Red3 = &Red3_;
Led Red4_; const PLed Red4 = &Red4_;
Led Red5_; const PLed Red5 = &Red5_;

Led Green1_; const PLed Green1 = &Green1_;
Led Green2_; const PLed Green2 = &Green2_;
Led Green3_; const PLed Green3 = &Green3_;
Led Yellow1_; const PLed Yellow1 = &Yellow1_;
Led Yellow2_; const PLed Yellow2 = &Yellow2_;

LedGroup RedLeds_; const PLedGroup RedLeds = &RedLeds_;
LedGroup YellowLeds_; const PLedGroup YellowLeds = &YellowLeds_;
LedGroup WhiteLeds_; const PLedGroup WhiteLeds = &WhiteLeds_;
LedGroup GreenLeds_; const PLedGroup GreenLeds = &GreenLeds_;
LedGroup MiddleLeds_; const PLedGroup MiddleLeds = &MiddleLeds_;
LedGroup AllLeds_; const PLedGroup AllLeds = &AllLeds_;

#define LeftLeds WhiteLeds
#define RightLeds RedLeds
# 21 ".././shared/../kernel.h" 2
# 1 ".././shared/../shared/twi_bgx1.h" 1

#define TWI_BGX1_H_ 

# 1 "..\\..\\AntonAvrLib/kernel/TWI/twi_raw.h" 1

#define TWI_RAW_H_ 

# 1 "..\\..\\AntonAvrLib/kernel/TWI/../../anton_std.h" 1
# 5 "..\\..\\AntonAvrLib/kernel/TWI/twi_raw.h" 2


typedef struct {
 uint8_t address;
} TWIDevice;

extern TWIDevice TWIBroadcast;

typedef struct {
 byte *data;
 uint16_t size;
} TWIBuffer;

typedef struct {
 TWIBuffer buffer;
 TWIDevice device;
 enum {
  TWI_IllegalOperation,
  TWI_Receive,
  TWI_Send
 } operationMode;
} TWIOperation;

typedef enum {
 TWI_No_Error,

 TWI_No_Info_Interrupt,
 TWI_Bus_Error,
 TWI_Illegal_Status,

 TWI_SlaveAddress_NoAck,
 TWI_Arbitration_Lost,

 TWI_Master_TooMuchDataTransmitted,






 TWI_Slave_NotEnoughDataTransmitted,
 TWI_Slave_TooMuchDataTransmitted,
 TWI_Slave_NotEnoughDataReceived


} TWIError;


extern volatile BOOL twi_running;
extern TWIError twi_error;





void WAIT_FOR_TWI();



void twiSend(TWIDevice targetDevice, TWIBuffer data);
void twiReceive(TWIDevice targetDevice, TWIBuffer receiveBuffer);
void twiSendReceive(TWIDevice targetDevice, TWIBuffer sendData, TWIBuffer receiveBuffer);

#define NUM_TWI_OPERATIONS 3




void twiMultipleOperations(int count, TWIOperation *operations);



void turn_word(uint16_t *word);
# 5 ".././shared/../shared/twi_bgx1.h" 2

TWIDevice bgx1 = { 11 << 1 };






#define TWI_DEVICE bgx1

# 1 "..\\..\\AntonAvrLib/kernel/TWI/twi_rpc_client.h" 1

#define TWI_RPC_CLIENT_H_ 




# 1 "..\\..\\AntonAvrLib/kernel/TWI/twi_rpc.h" 1

#define TWI_RPC_H_ 

# 1 "..\\..\\AntonAvrLib/kernel/TWI/twi_raw.h" 1
# 5 "..\\..\\AntonAvrLib/kernel/TWI/twi_rpc.h" 2




void twi_rpc_oneway(TWIDevice device, byte operation, TWIBuffer parameters);
void twi_rpc(TWIDevice device, byte operation, TWIBuffer parameters, TWIBuffer resultBuffer);




void twi_rpc_pseudo_oneway(TWIDevice device, byte operation, TWIBuffer parameters);
# 8 "..\\..\\AntonAvrLib/kernel/TWI/twi_rpc_client.h" 2
# 26 "..\\..\\AntonAvrLib/kernel/TWI/twi_rpc_client.h"
#define TWI_RPC_FUNCTION_VAR(funcName,operationByte,ArgStruct,ResStruct) void funcName(ArgStruct *parameters, uint16_t argSize, ResStruct *out_result, uint16_t resultSize) { TWIBuffer argBuf = (TWIBuffer) { (byte*) parameters, argSize }; TWIBuffer resBuf = (TWIBuffer) { (byte*) out_result, resultSize }; twi_rpc(TWI_DEVICE, operationByte, argBuf, resBuf); WAIT_FOR_TWI(); }







#define TWI_RPC_FUNCTION_VARARGS(funcName,operationByte,ArgStruct,ResStruct) ResStruct funcName(ArgStruct *parameters, uint16_t argSize) { TWIBuffer argBuf = (TWIBuffer) { (byte*) parameters, argSize }; ResStruct result; TWIBuffer resBuf = (TWIBuffer) { (byte*) &result, sizeof(ResStruct) }; twi_rpc(TWI_DEVICE, operationByte, argBuf, resBuf); WAIT_FOR_TWI(); return result; }
# 44 "..\\..\\AntonAvrLib/kernel/TWI/twi_rpc_client.h"
#define TWI_RPC_FUNCTION_VARRES(funcName,operationByte,ArgStruct,ResStruct) void funcName(ArgStruct parameters, ResStruct *out_result, uint16_t resultSize) { TWIBuffer argBuf = (TWIBuffer) { (byte*) &parameters, sizeof(ArgStruct) }; TWIBuffer resBuf = (TWIBuffer) { (byte*) out_result, resultSize }; twi_rpc(TWI_DEVICE, operationByte, argBuf, resBuf); WAIT_FOR_TWI(); }







#define TWI_RPC_FUNCTION(funcName,operationByte,ArgStruct,ResStruct) ResStruct funcName(ArgStruct parameters) { TWIBuffer argBuf = (TWIBuffer) { (byte*) &parameters, sizeof(ArgStruct) }; ResStruct result; TWIBuffer resBuf = (TWIBuffer) { (byte*) &result, sizeof(ResStruct) }; twi_rpc(TWI_DEVICE, operationByte, argBuf, resBuf); WAIT_FOR_TWI(); return result; }
# 66 "..\\..\\AntonAvrLib/kernel/TWI/twi_rpc_client.h"
#define TWI_RPC_FUNCTION_VOID_VAR(funcName,operationByte,ArgStruct) void funcName(ArgStruct *parameters, uint16_t argSize) { TWIBuffer buf = (TWIBuffer) { (byte*) parameters, argSize }; twi_rpc_oneway(TWI_DEVICE, operationByte, buf); WAIT_FOR_TWI(); }






#define TWI_RPC_FUNCTION_VOID(funcName,operationByte,ArgStruct) void funcName(ArgStruct parameters) { TWIBuffer buf = (TWIBuffer) { (byte*) &parameters, sizeof(ArgStruct) }; twi_rpc_oneway(TWI_DEVICE, operationByte, buf); WAIT_FOR_TWI(); }






#define TWI_RPC_FUNCTION_PVOID(funcName,operationByte,ArgStruct) void funcName(ArgStruct parameters) { TWIBuffer buf = (TWIBuffer) { (byte*) &parameters, sizeof(ArgStruct) }; twi_rpc_pseudo_oneway(TWI_DEVICE, operationByte, buf); WAIT_FOR_TWI(); }






#define TWI_RPC_FUNCTION_PVOID_VAR(funcName,operationByte,ArgStruct) void funcName(ArgStruct *parameters, uint16_t argSize) { TWIBuffer buf = (TWIBuffer) { (byte*) parameters, argSize }; twi_rpc_pseudo_oneway(TWI_DEVICE, operationByte, buf); WAIT_FOR_TWI(); }
# 99 "..\\..\\AntonAvrLib/kernel/TWI/twi_rpc_client.h"
#define TWI_RPC_FUNCTION_NOARGS(funcName,operationByte,ResStruct) ResStruct funcName() { ResStruct result; TWIBuffer argBuf = (TWIBuffer) { (byte*) NULL, 0 }; TWIBuffer resBuf = (TWIBuffer) { (byte*) &result, sizeof(ResStruct) }; twi_rpc(TWI_DEVICE, operationByte, argBuf, resBuf); WAIT_FOR_TWI(); return result; }
# 109 "..\\..\\AntonAvrLib/kernel/TWI/twi_rpc_client.h"
#define TWI_RPC_FUNCTION_NOARGS_VAR(funcName,operationByte,ResStruct) void funcName(ResStruct *out_result, uint16_t resultSize) { TWIBuffer argBuf = (TWIBuffer) { (byte*) NULL, 0 }; TWIBuffer resBuf = (TWIBuffer) { (byte*) out_result, resultSize }; twi_rpc(TWI_DEVICE, operationByte, argBuf, resBuf); WAIT_FOR_TWI(); }
# 121 "..\\..\\AntonAvrLib/kernel/TWI/twi_rpc_client.h"
#define TWI_RPC_FUNCTION_NOTIFY(funcName,operationByte) void funcName() { TWIBuffer argBuf = (TWIBuffer) { (byte*) NULL, 0 }; twi_rpc_oneway(TWI_DEVICE, operationByte, argBuf); WAIT_FOR_TWI(); }






#define TWI_RPC_FUNCTION_PNOTIFY(funcName,operationByte) void funcName() { TWIBuffer argBuf = (TWIBuffer) { (byte*) NULL, 0 }; twi_rpc_pseudo_oneway(TWI_DEVICE, operationByte, argBuf); WAIT_FOR_TWI(); }
# 16 ".././shared/../shared/twi_bgx1.h" 2
# 1 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/pgmspace.h" 1 3
# 83 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/pgmspace.h" 3
#define __PGMSPACE_H_ 1

#define __need_size_t 

# 1 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/include/stddef.h" 1 3 4
# 233 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/include/stddef.h" 3 4
#undef __need_size_t
# 406 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/include/stddef.h" 3 4
#undef __need_NULL
# 88 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/pgmspace.h" 2 3







#define __ATTR_PROGMEM__ __attribute__((__progmem__))
# 109 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/pgmspace.h" 3
#define PROGMEM __ATTR_PROGMEM__
# 217 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/pgmspace.h" 3
typedef void prog_void __attribute__((__progmem__));
typedef char prog_char __attribute__((__progmem__));
typedef unsigned char prog_uchar __attribute__((__progmem__));

typedef int8_t prog_int8_t __attribute__((__progmem__));
typedef uint8_t prog_uint8_t __attribute__((__progmem__));
typedef int16_t prog_int16_t __attribute__((__progmem__));
typedef uint16_t prog_uint16_t __attribute__((__progmem__));
typedef int32_t prog_int32_t __attribute__((__progmem__));
typedef uint32_t prog_uint32_t __attribute__((__progmem__));

typedef int64_t prog_int64_t __attribute__((__progmem__));
typedef uint64_t prog_uint64_t __attribute__((__progmem__));
# 255 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/pgmspace.h" 3
#define PSTR(s) (__extension__({static const char __c[] PROGMEM = (s); &__c[0];}))


#define __LPM_classic__(addr) (__extension__({ uint16_t __addr16 = (uint16_t)(addr); uint8_t __result; __asm__ ( "lpm" "\n\t" "mov %0, r0" "\n\t" : "=r" (__result) : "z" (__addr16) : "r0" ); __result; }))
# 273 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/pgmspace.h" 3
#define __LPM_enhanced__(addr) (__extension__({ uint16_t __addr16 = (uint16_t)(addr); uint8_t __result; __asm__ ( "lpm %0, Z" "\n\t" : "=r" (__result) : "z" (__addr16) ); __result; }))
# 286 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/pgmspace.h" 3
#define __LPM_word_classic__(addr) (__extension__({ uint16_t __addr16 = (uint16_t)(addr); uint16_t __result; __asm__ ( "lpm" "\n\t" "mov %A0, r0" "\n\t" "adiw r30, 1" "\n\t" "lpm" "\n\t" "mov %B0, r0" "\n\t" : "=r" (__result), "=z" (__addr16) : "1" (__addr16) : "r0" ); __result; }))
# 304 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/pgmspace.h" 3
#define __LPM_word_enhanced__(addr) (__extension__({ uint16_t __addr16 = (uint16_t)(addr); uint16_t __result; __asm__ ( "lpm %A0, Z+" "\n\t" "lpm %B0, Z" "\n\t" : "=r" (__result), "=z" (__addr16) : "1" (__addr16) ); __result; }))
# 318 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/pgmspace.h" 3
#define __LPM_dword_classic__(addr) (__extension__({ uint16_t __addr16 = (uint16_t)(addr); uint32_t __result; __asm__ ( "lpm" "\n\t" "mov %A0, r0" "\n\t" "adiw r30, 1" "\n\t" "lpm" "\n\t" "mov %B0, r0" "\n\t" "adiw r30, 1" "\n\t" "lpm" "\n\t" "mov %C0, r0" "\n\t" "adiw r30, 1" "\n\t" "lpm" "\n\t" "mov %D0, r0" "\n\t" : "=r" (__result), "=z" (__addr16) : "1" (__addr16) : "r0" ); __result; }))
# 342 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/pgmspace.h" 3
#define __LPM_dword_enhanced__(addr) (__extension__({ uint16_t __addr16 = (uint16_t)(addr); uint32_t __result; __asm__ ( "lpm %A0, Z+" "\n\t" "lpm %B0, Z+" "\n\t" "lpm %C0, Z+" "\n\t" "lpm %D0, Z" "\n\t" : "=r" (__result), "=z" (__addr16) : "1" (__addr16) ); __result; }))
# 358 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/pgmspace.h" 3
#define __LPM_float_classic__(addr) (__extension__({ uint16_t __addr16 = (uint16_t)(addr); float __result; __asm__ ( "lpm" "\n\t" "mov %A0, r0" "\n\t" "adiw r30, 1" "\n\t" "lpm" "\n\t" "mov %B0, r0" "\n\t" "adiw r30, 1" "\n\t" "lpm" "\n\t" "mov %C0, r0" "\n\t" "adiw r30, 1" "\n\t" "lpm" "\n\t" "mov %D0, r0" "\n\t" : "=r" (__result), "=z" (__addr16) : "1" (__addr16) : "r0" ); __result; }))
# 382 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/pgmspace.h" 3
#define __LPM_float_enhanced__(addr) (__extension__({ uint16_t __addr16 = (uint16_t)(addr); float __result; __asm__ ( "lpm %A0, Z+" "\n\t" "lpm %B0, Z+" "\n\t" "lpm %C0, Z+" "\n\t" "lpm %D0, Z" "\n\t" : "=r" (__result), "=z" (__addr16) : "1" (__addr16) ); __result; }))
# 399 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/pgmspace.h" 3
#define __LPM(addr) __LPM_enhanced__(addr)
#define __LPM_word(addr) __LPM_word_enhanced__(addr)
#define __LPM_dword(addr) __LPM_dword_enhanced__(addr)
#define __LPM_float(addr) __LPM_float_enhanced__(addr)
# 416 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/pgmspace.h" 3
#define pgm_read_byte_near(address_short) __LPM((uint16_t)(address_short))







#define pgm_read_word_near(address_short) __LPM_word((uint16_t)(address_short))







#define pgm_read_dword_near(address_short) __LPM_dword((uint16_t)(address_short))
# 441 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/pgmspace.h" 3
#define pgm_read_float_near(address_short) __LPM_float((uint16_t)(address_short))
# 452 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/pgmspace.h" 3
#define __ELPM_classic__(addr) (__extension__({ uint32_t __addr32 = (uint32_t)(addr); uint8_t __result; __asm__ ( "out %2, %C1" "\n\t" "mov r31, %B1" "\n\t" "mov r30, %A1" "\n\t" "elpm" "\n\t" "mov %0, r0" "\n\t" : "=r" (__result) : "r" (__addr32), "I" (_SFR_IO_ADDR(RAMPZ)) : "r0", "r30", "r31" ); __result; }))
# 471 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/pgmspace.h" 3
#define __ELPM_enhanced__(addr) (__extension__({ uint32_t __addr32 = (uint32_t)(addr); uint8_t __result; __asm__ ( "out %2, %C1" "\n\t" "movw r30, %1" "\n\t" "elpm %0, Z+" "\n\t" : "=r" (__result) : "r" (__addr32), "I" (_SFR_IO_ADDR(RAMPZ)) : "r30", "r31" ); __result; }))
# 488 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/pgmspace.h" 3
#define __ELPM_xmega__(addr) (__extension__({ uint32_t __addr32 = (uint32_t)(addr); uint8_t __result; __asm__ ( "in __tmp_reg__, %2" "\n\t" "out %2, %C1" "\n\t" "movw r30, %1" "\n\t" "elpm %0, Z+" "\n\t" "out %2, __tmp_reg__" : "=r" (__result) : "r" (__addr32), "I" (_SFR_IO_ADDR(RAMPZ)) : "r30", "r31" ); __result; }))
# 507 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/pgmspace.h" 3
#define __ELPM_word_classic__(addr) (__extension__({ uint32_t __addr32 = (uint32_t)(addr); uint16_t __result; __asm__ ( "out %2, %C1" "\n\t" "mov r31, %B1" "\n\t" "mov r30, %A1" "\n\t" "elpm" "\n\t" "mov %A0, r0" "\n\t" "in r0, %2" "\n\t" "adiw r30, 1" "\n\t" "adc r0, __zero_reg__" "\n\t" "out %2, r0" "\n\t" "elpm" "\n\t" "mov %B0, r0" "\n\t" : "=r" (__result) : "r" (__addr32), "I" (_SFR_IO_ADDR(RAMPZ)) : "r0", "r30", "r31" ); __result; }))
# 532 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/pgmspace.h" 3
#define __ELPM_word_enhanced__(addr) (__extension__({ uint32_t __addr32 = (uint32_t)(addr); uint16_t __result; __asm__ ( "out %2, %C1" "\n\t" "movw r30, %1" "\n\t" "elpm %A0, Z+" "\n\t" "elpm %B0, Z" "\n\t" : "=r" (__result) : "r" (__addr32), "I" (_SFR_IO_ADDR(RAMPZ)) : "r30", "r31" ); __result; }))
# 550 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/pgmspace.h" 3
#define __ELPM_word_xmega__(addr) (__extension__({ uint32_t __addr32 = (uint32_t)(addr); uint16_t __result; __asm__ ( "in __tmp_reg__, %2" "\n\t" "out %2, %C1" "\n\t" "movw r30, %1" "\n\t" "elpm %A0, Z+" "\n\t" "elpm %B0, Z" "\n\t" "out %2, __tmp_reg__" : "=r" (__result) : "r" (__addr32), "I" (_SFR_IO_ADDR(RAMPZ)) : "r30", "r31" ); __result; }))
# 570 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/pgmspace.h" 3
#define __ELPM_dword_classic__(addr) (__extension__({ uint32_t __addr32 = (uint32_t)(addr); uint32_t __result; __asm__ ( "out %2, %C1" "\n\t" "mov r31, %B1" "\n\t" "mov r30, %A1" "\n\t" "elpm" "\n\t" "mov %A0, r0" "\n\t" "in r0, %2" "\n\t" "adiw r30, 1" "\n\t" "adc r0, __zero_reg__" "\n\t" "out %2, r0" "\n\t" "elpm" "\n\t" "mov %B0, r0" "\n\t" "in r0, %2" "\n\t" "adiw r30, 1" "\n\t" "adc r0, __zero_reg__" "\n\t" "out %2, r0" "\n\t" "elpm" "\n\t" "mov %C0, r0" "\n\t" "in r0, %2" "\n\t" "adiw r30, 1" "\n\t" "adc r0, __zero_reg__" "\n\t" "out %2, r0" "\n\t" "elpm" "\n\t" "mov %D0, r0" "\n\t" : "=r" (__result) : "r" (__addr32), "I" (_SFR_IO_ADDR(RAMPZ)) : "r0", "r30", "r31" ); __result; }))
# 607 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/pgmspace.h" 3
#define __ELPM_dword_enhanced__(addr) (__extension__({ uint32_t __addr32 = (uint32_t)(addr); uint32_t __result; __asm__ ( "out %2, %C1" "\n\t" "movw r30, %1" "\n\t" "elpm %A0, Z+" "\n\t" "elpm %B0, Z+" "\n\t" "elpm %C0, Z+" "\n\t" "elpm %D0, Z" "\n\t" : "=r" (__result) : "r" (__addr32), "I" (_SFR_IO_ADDR(RAMPZ)) : "r30", "r31" ); __result; }))
# 627 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/pgmspace.h" 3
#define __ELPM_dword_xmega__(addr) (__extension__({ uint32_t __addr32 = (uint32_t)(addr); uint32_t __result; __asm__ ( "in __tmp_reg__, %2" "\n\t" "out %2, %C1" "\n\t" "movw r30, %1" "\n\t" "elpm %A0, Z+" "\n\t" "elpm %B0, Z+" "\n\t" "elpm %C0, Z+" "\n\t" "elpm %D0, Z" "\n\t" "out %2, __tmp_reg__" : "=r" (__result) : "r" (__addr32), "I" (_SFR_IO_ADDR(RAMPZ)) : "r30", "r31" ); __result; }))
# 649 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/pgmspace.h" 3
#define __ELPM_float_classic__(addr) (__extension__({ uint32_t __addr32 = (uint32_t)(addr); float __result; __asm__ ( "out %2, %C1" "\n\t" "mov r31, %B1" "\n\t" "mov r30, %A1" "\n\t" "elpm" "\n\t" "mov %A0, r0" "\n\t" "in r0, %2" "\n\t" "adiw r30, 1" "\n\t" "adc r0, __zero_reg__" "\n\t" "out %2, r0" "\n\t" "elpm" "\n\t" "mov %B0, r0" "\n\t" "in r0, %2" "\n\t" "adiw r30, 1" "\n\t" "adc r0, __zero_reg__" "\n\t" "out %2, r0" "\n\t" "elpm" "\n\t" "mov %C0, r0" "\n\t" "in r0, %2" "\n\t" "adiw r30, 1" "\n\t" "adc r0, __zero_reg__" "\n\t" "out %2, r0" "\n\t" "elpm" "\n\t" "mov %D0, r0" "\n\t" : "=r" (__result) : "r" (__addr32), "I" (_SFR_IO_ADDR(RAMPZ)) : "r0", "r30", "r31" ); __result; }))
# 686 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/pgmspace.h" 3
#define __ELPM_float_enhanced__(addr) (__extension__({ uint32_t __addr32 = (uint32_t)(addr); float __result; __asm__ ( "out %2, %C1" "\n\t" "movw r30, %1" "\n\t" "elpm %A0, Z+" "\n\t" "elpm %B0, Z+" "\n\t" "elpm %C0, Z+" "\n\t" "elpm %D0, Z" "\n\t" : "=r" (__result) : "r" (__addr32), "I" (_SFR_IO_ADDR(RAMPZ)) : "r30", "r31" ); __result; }))
# 706 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/pgmspace.h" 3
#define __ELPM_float_xmega__(addr) (__extension__({ uint32_t __addr32 = (uint32_t)(addr); float __result; __asm__ ( "in __tmp_reg__, %2" "\n\t" "out %2, %C1" "\n\t" "movw r30, %1" "\n\t" "elpm %A0, Z+" "\n\t" "elpm %B0, Z+" "\n\t" "elpm %C0, Z+" "\n\t" "elpm %D0, Z" "\n\t" "out %2, __tmp_reg__" : "=r" (__result) : "r" (__addr32), "I" (_SFR_IO_ADDR(RAMPZ)) : "r30", "r31" ); __result; }))
# 744 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/pgmspace.h" 3
#define __ELPM(addr) __ELPM_enhanced__(addr)
#define __ELPM_word(addr) __ELPM_word_enhanced__(addr)
#define __ELPM_dword(addr) __ELPM_dword_enhanced__(addr)
#define __ELPM_float(addr) __ELPM_float_enhanced__(addr)
# 768 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/pgmspace.h" 3
#define pgm_read_byte_far(address_long) __ELPM((uint32_t)(address_long))
# 777 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/pgmspace.h" 3
#define pgm_read_word_far(address_long) __ELPM_word((uint32_t)(address_long))
# 786 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/pgmspace.h" 3
#define pgm_read_dword_far(address_long) __ELPM_dword((uint32_t)(address_long))
# 795 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/pgmspace.h" 3
#define pgm_read_float_far(address_long) __ELPM_float((uint32_t)(address_long))
# 806 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/pgmspace.h" 3
#define pgm_read_byte(address_short) pgm_read_byte_near(address_short)
# 815 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/pgmspace.h" 3
#define pgm_read_word(address_short) pgm_read_word_near(address_short)
# 824 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/pgmspace.h" 3
#define pgm_read_dword(address_short) pgm_read_dword_near(address_short)
# 833 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/pgmspace.h" 3
#define pgm_read_float(address_short) pgm_read_float_near(address_short)
# 842 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/pgmspace.h" 3
#define PGM_P const prog_char *
# 851 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/pgmspace.h" 3
#define PGM_VOID_P const prog_void *
# 888 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/pgmspace.h" 3
#define pgm_get_far_address(var) ({ uint_farptr_t tmp; __asm__ __volatile__( "ldi	%A0, lo8(%1)" "\n\t" "ldi	%B0, hi8(%1)" "\n\t" "ldi	%C0, hh8(%1)" "\n\t" "clr	%D0" "\n\t" : "=d" (tmp) : "p" (&(var)) ); tmp; })
# 907 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/avr/pgmspace.h" 3
extern const prog_void * memchr_P(const prog_void *, int __val, size_t __len) __attribute__((__const__));
extern int memcmp_P(const void *, const prog_void *, size_t) __attribute__((__pure__));
extern void *memccpy_P(void *, const prog_void *, int __val, size_t);
extern void *memcpy_P(void *, const prog_void *, size_t);
extern void *memmem_P(const void *, size_t, const prog_void *, size_t) __attribute__((__pure__));
extern const prog_void * memrchr_P(const prog_void *, int __val, size_t __len) __attribute__((__const__));
extern char *strcat_P(char *, const prog_char *);
extern const prog_char * strchr_P(const prog_char *, int __val) __attribute__((__const__));
extern const prog_char * strchrnul_P(const prog_char *, int __val) __attribute__((__const__));
extern int strcmp_P(const char *, const prog_char *) __attribute__((__pure__));
extern char *strcpy_P(char *, const prog_char *);
extern int strcasecmp_P(const char *, const prog_char *) __attribute__((__pure__));
extern char *strcasestr_P(const char *, const prog_char *) __attribute__((__pure__));
extern size_t strcspn_P(const char *__s, const prog_char * __reject) __attribute__((__pure__));
extern size_t strlcat_P (char *, const prog_char *, size_t );
extern size_t strlcpy_P (char *, const prog_char *, size_t );
extern size_t strlen_P(const prog_char *) __attribute__((__const__));
extern size_t strnlen_P(const prog_char *, size_t) __attribute__((__const__));
extern int strncmp_P(const char *, const prog_char *, size_t) __attribute__((__pure__));
extern int strncasecmp_P(const char *, const prog_char *, size_t) __attribute__((__pure__));
extern char *strncat_P(char *, const prog_char *, size_t);
extern char *strncpy_P(char *, const prog_char *, size_t);
extern char *strpbrk_P(const char *__s, const prog_char * __accept) __attribute__((__pure__));
extern const prog_char * strrchr_P(const prog_char *, int __val) __attribute__((__const__));
extern char *strsep_P(char **__sp, const prog_char * __delim);
extern size_t strspn_P(const char *__s, const prog_char * __accept) __attribute__((__pure__));
extern char *strstr_P(const char *, const prog_char *) __attribute__((__pure__));
extern char *strtok_P(char *__s, const prog_char * __delim);
extern char *strtok_rP(char *__s, const prog_char * __delim, char **__last);

extern size_t strlen_PF (uint_farptr_t src) __attribute__((__const__));
extern size_t strnlen_PF (uint_farptr_t src, size_t len) __attribute__((__const__));
extern void *memcpy_PF (void *dest, uint_farptr_t src, size_t len);
extern char *strcpy_PF (char *dest, uint_farptr_t src);
extern char *strncpy_PF (char *dest, uint_farptr_t src, size_t len);
extern char *strcat_PF (char *dest, uint_farptr_t src);
extern size_t strlcat_PF (char *dst, uint_farptr_t src, size_t siz);
extern char *strncat_PF (char *dest, uint_farptr_t src, size_t len);
extern int strcmp_PF (const char *s1, uint_farptr_t s2) __attribute__((__pure__));
extern int strncmp_PF (const char *s1, uint_farptr_t s2, size_t n) __attribute__((__pure__));
extern int strcasecmp_PF (const char *s1, uint_farptr_t s2) __attribute__((__pure__));
extern int strncasecmp_PF (const char *s1, uint_farptr_t s2, size_t n) __attribute__((__pure__));
extern char *strstr_PF (const char *s1, uint_farptr_t s2);
extern size_t strlcpy_PF (char *dst, uint_farptr_t src, size_t siz);
extern int memcmp_PF(const void *, uint_farptr_t, size_t) __attribute__((__pure__));
# 17 ".././shared/../shared/twi_bgx1.h" 2

#define BGX1_VERSION 0x0103


enum {

  CMD_Reset = 0x00,
  CMD_GetVersion = 0x01,
  CMD_GetStatus = 0x02,
  CMD_SetStatus = 0x03,




  CMD_Move = 0x10,
  CMD_Mode = 0x11,
  CMD_FillAll = 0x12,
  CMD_Print = 0x13,
  CMD_TextWidth = 0x14,
  CMD_SelectFont = 0x15,
  CMD_HLine = 0x16,
  CMD_VLine = 0x17,
  CMD_Box = 0x18,
  CMD_Bitmap = 0x19,
  CMD_EmbeddedImage = 0x1a,
  CMD_LineTo = 0x1b,


  CMD_TermClear = 0x30,
  CMD_TermGoto = 0x31,
  CMD_TermScroll = 0x32,
  CMD_TermPrint = 0x33,


  CMD_SyncPort = 0x40,
  CMD_GetAnalog = 0x41,
  CMD_SyncInterface = 0x42,
  CMD_SetIllumination = 0x43,

  CMD_INVALID = 0xff
};


void bgx1_reset() { TWIBuffer argBuf = (TWIBuffer) { (byte*) ((void *)0), 0 }; twi_rpc_pseudo_oneway(bgx1, CMD_Reset, argBuf); WAIT_FOR_TWI(); }
uint16_t bgx1_getVersion_base() { uint16_t result; TWIBuffer argBuf = (TWIBuffer) { (byte*) ((void *)0), 0 }; TWIBuffer resBuf = (TWIBuffer) { (byte*) &result, sizeof(uint16_t) }; twi_rpc(bgx1, CMD_GetVersion, argBuf, resBuf); WAIT_FOR_TWI(); return result; }
uint8_t bgx1_getStatus() { uint8_t result; TWIBuffer argBuf = (TWIBuffer) { (byte*) ((void *)0), 0 }; TWIBuffer resBuf = (TWIBuffer) { (byte*) &result, sizeof(uint8_t) }; twi_rpc(bgx1, CMD_GetStatus, argBuf, resBuf); WAIT_FOR_TWI(); return result; }
void bgx1_setStatus(uint8_t parameters) { TWIBuffer buf = (TWIBuffer) { (byte*) &parameters, sizeof(uint8_t) }; twi_rpc_pseudo_oneway(bgx1, CMD_SetStatus, buf); WAIT_FOR_TWI(); }

typedef struct {
 uint8_t x;
 uint8_t y;
} Point, *PPoint, Rect, *PRect;

typedef struct {
 uint8_t width;
 uint8_t height;


} BitmapArguments, *PBitmapArguments;


typedef char StringArg;


void bgx1_move_base(Point parameters) { TWIBuffer buf = (TWIBuffer) { (byte*) &parameters, sizeof(Point) }; twi_rpc_pseudo_oneway(bgx1, CMD_Move, buf); WAIT_FOR_TWI(); }
void bgx1_mode(uint8_t parameters) { TWIBuffer buf = (TWIBuffer) { (byte*) &parameters, sizeof(uint8_t) }; twi_rpc_pseudo_oneway(bgx1, CMD_Mode, buf); WAIT_FOR_TWI(); }
void bgx1_fillAll(uint8_t parameters) { TWIBuffer buf = (TWIBuffer) { (byte*) &parameters, sizeof(uint8_t) }; twi_rpc_pseudo_oneway(bgx1, CMD_FillAll, buf); WAIT_FOR_TWI(); }
Point bgx1_print_base(StringArg *parameters, uint16_t argSize) { TWIBuffer argBuf = (TWIBuffer) { (byte*) parameters, argSize }; Point result; TWIBuffer resBuf = (TWIBuffer) { (byte*) &result, sizeof(Point) }; twi_rpc(bgx1, CMD_Print, argBuf, resBuf); WAIT_FOR_TWI(); return result; }
uint8_t bgx1_textWidth_base(StringArg *parameters, uint16_t argSize) { TWIBuffer argBuf = (TWIBuffer) { (byte*) parameters, argSize }; uint8_t result; TWIBuffer resBuf = (TWIBuffer) { (byte*) &result, sizeof(uint8_t) }; twi_rpc(bgx1, CMD_TextWidth, argBuf, resBuf); WAIT_FOR_TWI(); return result; }
void bgx1_selectFont(uint8_t parameters) { TWIBuffer buf = (TWIBuffer) { (byte*) &parameters, sizeof(uint8_t) }; twi_rpc_pseudo_oneway(bgx1, CMD_SelectFont, buf); WAIT_FOR_TWI(); }
Point bgx1_hLine(uint8_t parameters) { TWIBuffer argBuf = (TWIBuffer) { (byte*) &parameters, sizeof(uint8_t) }; Point result; TWIBuffer resBuf = (TWIBuffer) { (byte*) &result, sizeof(Point) }; twi_rpc(bgx1, CMD_HLine, argBuf, resBuf); WAIT_FOR_TWI(); return result; }
Point bgx1_vLine(uint8_t parameters) { TWIBuffer argBuf = (TWIBuffer) { (byte*) &parameters, sizeof(uint8_t) }; Point result; TWIBuffer resBuf = (TWIBuffer) { (byte*) &result, sizeof(Point) }; twi_rpc(bgx1, CMD_VLine, argBuf, resBuf); WAIT_FOR_TWI(); return result; }
Point bgx1_box_base(Rect parameters) { TWIBuffer argBuf = (TWIBuffer) { (byte*) &parameters, sizeof(Rect) }; Point result; TWIBuffer resBuf = (TWIBuffer) { (byte*) &result, sizeof(Point) }; twi_rpc(bgx1, CMD_Box, argBuf, resBuf); WAIT_FOR_TWI(); return result; }
Point bgx1_drawBitmap_base(BitmapArguments *parameters, uint16_t argSize) { TWIBuffer argBuf = (TWIBuffer) { (byte*) parameters, argSize }; Point result; TWIBuffer resBuf = (TWIBuffer) { (byte*) &result, sizeof(Point) }; twi_rpc(bgx1, CMD_Bitmap, argBuf, resBuf); WAIT_FOR_TWI(); return result; }
Point bgx1_embeddedImage(uint8_t parameters) { TWIBuffer argBuf = (TWIBuffer) { (byte*) &parameters, sizeof(uint8_t) }; Point result; TWIBuffer resBuf = (TWIBuffer) { (byte*) &result, sizeof(Point) }; twi_rpc(bgx1, CMD_EmbeddedImage, argBuf, resBuf); WAIT_FOR_TWI(); return result; }
Point bgx1_lineTo_base(Point parameters) { TWIBuffer argBuf = (TWIBuffer) { (byte*) &parameters, sizeof(Point) }; Point result; TWIBuffer resBuf = (TWIBuffer) { (byte*) &result, sizeof(Point) }; twi_rpc(bgx1, CMD_LineTo, argBuf, resBuf); WAIT_FOR_TWI(); return result; }


void bgx1_termClear() { TWIBuffer argBuf = (TWIBuffer) { (byte*) ((void *)0), 0 }; twi_rpc_pseudo_oneway(bgx1, CMD_TermClear, argBuf); WAIT_FOR_TWI(); }
void bgx1_termGoto_base(Point parameters) { TWIBuffer buf = (TWIBuffer) { (byte*) &parameters, sizeof(Point) }; twi_rpc_pseudo_oneway(bgx1, CMD_TermGoto, buf); WAIT_FOR_TWI(); }
void bgx1_termScroll(int8_t parameters) { TWIBuffer buf = (TWIBuffer) { (byte*) &parameters, sizeof(int8_t) }; twi_rpc_pseudo_oneway(bgx1, CMD_TermScroll, buf); WAIT_FOR_TWI(); }


byte bgx1_termPrint_base(StringArg *parameters, uint16_t argSize) { TWIBuffer argBuf = (TWIBuffer) { (byte*) parameters, argSize }; byte result; TWIBuffer resBuf = (TWIBuffer) { (byte*) &result, sizeof(byte) }; twi_rpc(bgx1, CMD_TermPrint, argBuf, resBuf); WAIT_FOR_TWI(); return result; }

typedef struct {
 uint8_t ddr;
 uint8_t port;
} SyncPortArgs, *PSyncPortArgs;


uint8_t bgx1_syncPort_base(SyncPortArgs parameters) { TWIBuffer argBuf = (TWIBuffer) { (byte*) &parameters, sizeof(SyncPortArgs) }; uint8_t result; TWIBuffer resBuf = (TWIBuffer) { (byte*) &result, sizeof(uint8_t) }; twi_rpc(bgx1, CMD_SyncPort, argBuf, resBuf); WAIT_FOR_TWI(); return result; }
uint16_t bgx1_getAnalog_base(uint8_t parameters) { TWIBuffer argBuf = (TWIBuffer) { (byte*) &parameters, sizeof(uint8_t) }; uint16_t result; TWIBuffer resBuf = (TWIBuffer) { (byte*) &result, sizeof(uint16_t) }; twi_rpc(bgx1, CMD_GetAnalog, argBuf, resBuf); WAIT_FOR_TWI(); return result; }
uint8_t bgx1_syncInterface(uint8_t parameters) { TWIBuffer argBuf = (TWIBuffer) { (byte*) &parameters, sizeof(uint8_t) }; uint8_t result; TWIBuffer resBuf = (TWIBuffer) { (byte*) &result, sizeof(uint8_t) }; twi_rpc(bgx1, CMD_SyncInterface, argBuf, resBuf); WAIT_FOR_TWI(); return result; }
void bgx1_setIllumination(uint16_t parameters) { TWIBuffer buf = (TWIBuffer) { (byte*) &parameters, sizeof(uint16_t) }; twi_rpc_pseudo_oneway(bgx1, CMD_SetIllumination, buf); WAIT_FOR_TWI(); }

#define BGX1_BTN_1 _BV(0)
#define BGX1_BTN_2 _BV(1)
#define BGX1_BTN_3 _BV(2)
#define BGX1_BTN_4 _BV(3)

#define BGX1_LED_1 _BV(0)
#define BGX1_LED_2 _BV(1)
#define BGX1_LED_3 _BV(2)
#define BGX1_LED_4 _BV(3)

Point bgx1_print(char *argument);
Point bgx1_print_P(const prog_char * argument);
uint8_t bgx1_textWidth(char *argument);
uint8_t bgx1_textWidth_P(const prog_char * argument);
byte bgx1_termPrint(char *argument);
byte bgx1_termPrint_P(const prog_char * argument);


Point bgx1_drawTile(uint8_t width, uint8_t height, const uint8_t *bitmap);
Point bgx1_drawTile_P(uint8_t width, uint8_t height, const prog_char * bitmap);



Point bgx1_drawBitmap(uint8_t width, uint8_t height, const uint8_t *bitmap);
Point bgx1_drawBitmap_P(uint8_t width, uint8_t height, const prog_char * bitmap);

void bgx1_move(uint8_t x, uint8_t y);
Point bgx1_box(uint8_t width, uint8_t height);
void bgx1_lineTo(uint8_t x, uint8_t y);
void bgx1_termGoto(uint8_t x, uint8_t y);
uint8_t bgx1_syncPort(uint8_t ddr, uint8_t port);

uint16_t bgx1_getAnalog(uint8_t index);
uint16_t bgx1_getVersion();



BOOL bgx1_initialized();
# 22 ".././shared/../kernel.h" 2


# 1 "..\\..\\AntonAvrLib/kernel/TWI/commandQueueExecuter.h" 1

#define COMMAND_QUEUE_EXECUTOR_LOOP_H_ 



void loopCommandQueue();
# 25 ".././shared/../kernel.h" 2
# 14 ".././shared/base_before.kernel.h" 2



#define TWI_BIT_RATE_VALUE 17


#define TWI_PRESCALER_MASK 0
#define TWI_Buffer_Size 255





# 1 ".././shared/timer.kernel.h" 1

#define _TIMER_KERNEL_KERNEL_ 




# 1 "..\\..\\AntonAvrLib/kernel/devices/timer_m1284P.kernel.h" 1
# 9 "..\\..\\AntonAvrLib/kernel/devices/timer_m1284P.kernel.h"
#define _TIMER_M1284P_KERNEL_ 

# 1 "..\\..\\AntonAvrLib/kernel/devices/../kernel_init.h" 1
# 12 "..\\..\\AntonAvrLib/kernel/devices/timer_m1284P.kernel.h" 2
# 1 "..\\..\\AntonAvrLib/kernel/devices/timer_m1284P.h" 1
# 9 "..\\..\\AntonAvrLib/kernel/devices/timer_m1284P.h"
#define TIMER_M1284P_H_ 

# 1 "..\\..\\AntonAvrLib/kernel/devices/timer.h" 1
# 9 "..\\..\\AntonAvrLib/kernel/devices/timer.h"
#define _TIMER_H_ 
# 19 "..\\..\\AntonAvrLib/kernel/devices/timer.h"
typedef enum {
 wgm_normal,
 clear_timer_on_match,


 pwm_fast_FF,
 pwm_phase_correct_FF,




 pwm_phase_correct,
 pwm_fast,


 pwm_phase_and_frequency_correct
} WaveformGenerationMode;

typedef enum {

 no_output,
 toggle_on_match,
 clear_on_match,
 set_on_match
} CompareMatchOutputMode;

typedef enum {
 no_clock,
 prescale_1,
 prescale_8,
 prescale_32,
 prescale_64,
 prescale_128,
 prescale_256,
 prescale_1024,
 external_falling_edge,
 external_rising_edge
} TimerClockSelect;

#define TIMER_NORMAL 0
#define TIMER_ASYNCHRONOUS (1 << 1)
#define TIMER_16bit (1 << 2)




#define TIMER_RESOLUTION_9bit (1 << 4)
#define TIMER_RESOLUTION_10bit (1 << 5)

typedef struct {
 uint8_t flags;
 volatile uint8_t *controlRegisterA;
 volatile uint8_t *controlRegisterB;
 volatile uint8_t *interruptMaskRegister;
} TimerPair, *PTimerPair;

typedef enum {
 TIMER_A,
 TIMER_B
} TIMER_TYPE;

typedef struct {
 PTimerPair timer;
 volatile uint8_t *outputCompareRegister;
 TIMER_TYPE type;
 PPin outputComparePin;
} Timer, *PTimer;


void setTimerClockSelect(PTimerPair timer, TimerClockSelect cs);
void setWaveformGenerationMode(PTimerPair timer, WaveformGenerationMode wgm);

void setCompareMatchOutputMode(PTimer timer, CompareMatchOutputMode com);

void enableTimerInterrupt(PTimer timer);
void disableTimerInterrupt(PTimer timer);
void enableOutputCompare(PTimer timer);
void disableOutputCompare(PTimer timer);


void setTimerCompareValue(PTimer timer, uint16_t value);


uint16_t getTimerCompareValue(PTimer timer);


#define DEFINE_TIMER_CONFIG(configName) TimerPair configName ##_; const PTimerPair configName = &configName ##_;


#define DEFINE_TIMER(timerName) Timer timerName ##_; const PTimer timerName = &timerName ##_;


#define INIT_TIMER_CONFIG(configName,flags,regA,regB,interrReg) configName ##_ = (TimerPair) {flags, (uint8_t*) &regA, (uint8_t*) &regB, &interrReg};

#define INIT_TIMER(timerName,configName,ocr,timerType,ocPin) timerName ##_ = (Timer) {configName, (uint8_t*) &ocr, timerType, ocPin};
# 12 "..\\..\\AntonAvrLib/kernel/devices/timer_m1284P.h" 2
# 1 "..\\..\\AntonAvrLib/kernel/devices/port_m1284P.h" 1
# 9 "..\\..\\AntonAvrLib/kernel/devices/port_m1284P.h"
#define PORT_M1284P_H_ 



Port PortA_; const PPort PortA = &PortA_; Pin PinA0_; const PPin PinA0 = &PinA0_; Pin PinA1_; const PPin PinA1 = &PinA1_; Pin PinA2_; const PPin PinA2 = &PinA2_; Pin PinA3_; const PPin PinA3 = &PinA3_; Pin PinA4_; const PPin PinA4 = &PinA4_; Pin PinA5_; const PPin PinA5 = &PinA5_; Pin PinA6_; const PPin PinA6 = &PinA6_; Pin PinA7_; const PPin PinA7 = &PinA7_;
Port PortB_; const PPort PortB = &PortB_; Pin PinB0_; const PPin PinB0 = &PinB0_; Pin PinB1_; const PPin PinB1 = &PinB1_; Pin PinB2_; const PPin PinB2 = &PinB2_; Pin PinB3_; const PPin PinB3 = &PinB3_; Pin PinB4_; const PPin PinB4 = &PinB4_; Pin PinB5_; const PPin PinB5 = &PinB5_; Pin PinB6_; const PPin PinB6 = &PinB6_; Pin PinB7_; const PPin PinB7 = &PinB7_;
Port PortC_; const PPort PortC = &PortC_; Pin PinC0_; const PPin PinC0 = &PinC0_; Pin PinC1_; const PPin PinC1 = &PinC1_; Pin PinC2_; const PPin PinC2 = &PinC2_; Pin PinC3_; const PPin PinC3 = &PinC3_; Pin PinC4_; const PPin PinC4 = &PinC4_; Pin PinC5_; const PPin PinC5 = &PinC5_; Pin PinC6_; const PPin PinC6 = &PinC6_; Pin PinC7_; const PPin PinC7 = &PinC7_;
Port PortD_; const PPort PortD = &PortD_; Pin PinD0_; const PPin PinD0 = &PinD0_; Pin PinD1_; const PPin PinD1 = &PinD1_; Pin PinD2_; const PPin PinD2 = &PinD2_; Pin PinD3_; const PPin PinD3 = &PinD3_; Pin PinD4_; const PPin PinD4 = &PinD4_; Pin PinD5_; const PPin PinD5 = &PinD5_; Pin PinD6_; const PPin PinD6 = &PinD6_; Pin PinD7_; const PPin PinD7 = &PinD7_;
# 13 "..\\..\\AntonAvrLib/kernel/devices/timer_m1284P.h" 2

TimerPair Timer0_; const PTimerPair Timer0 = &Timer0_;
TimerPair Timer1_; const PTimerPair Timer1 = &Timer1_;
TimerPair Timer2_; const PTimerPair Timer2 = &Timer2_;
TimerPair Timer3_; const PTimerPair Timer3 = &Timer3_;

Timer Timer0A_; const PTimer Timer0A = &Timer0A_;
Timer Timer0B_; const PTimer Timer0B = &Timer0B_;
Timer Timer1A_; const PTimer Timer1A = &Timer1A_;
Timer Timer1B_; const PTimer Timer1B = &Timer1B_;
Timer Timer2A_; const PTimer Timer2A = &Timer2A_;
Timer Timer2B_; const PTimer Timer2B = &Timer2B_;
Timer Timer3A_; const PTimer Timer3A = &Timer3A_;
Timer Timer3B_; const PTimer Timer3B = &Timer3B_;
# 13 "..\\..\\AntonAvrLib/kernel/devices/timer_m1284P.kernel.h" 2
# 1 "..\\..\\AntonAvrLib/kernel/devices/port_m1284P.kernel.h" 1
# 9 "..\\..\\AntonAvrLib/kernel/devices/port_m1284P.kernel.h"
#define _PORT_M1284P_KERNEL_ 




void init_ports_m1284P() {
 PortA_ = (Port) { &(*(volatile uint8_t *)((0x02) + 0x20)), &(*(volatile uint8_t *)((0x00) + 0x20)), &(*(volatile uint8_t *)((0x01) + 0x20)) }; PinA0_ = (Pin) { PortA, (1 << (0)) }; PinA1_ = (Pin) { PortA, (1 << (1)) }; PinA2_ = (Pin) { PortA, (1 << (2)) }; PinA3_ = (Pin) { PortA, (1 << (3)) }; PinA4_ = (Pin) { PortA, (1 << (4)) }; PinA5_ = (Pin) { PortA, (1 << (5)) }; PinA6_ = (Pin) { PortA, (1 << (6)) }; PinA7_ = (Pin) { PortA, (1 << (7)) };;
 PortB_ = (Port) { &(*(volatile uint8_t *)((0x05) + 0x20)), &(*(volatile uint8_t *)((0x03) + 0x20)), &(*(volatile uint8_t *)((0x04) + 0x20)) }; PinB0_ = (Pin) { PortB, (1 << (0)) }; PinB1_ = (Pin) { PortB, (1 << (1)) }; PinB2_ = (Pin) { PortB, (1 << (2)) }; PinB3_ = (Pin) { PortB, (1 << (3)) }; PinB4_ = (Pin) { PortB, (1 << (4)) }; PinB5_ = (Pin) { PortB, (1 << (5)) }; PinB6_ = (Pin) { PortB, (1 << (6)) }; PinB7_ = (Pin) { PortB, (1 << (7)) };;
 PortC_ = (Port) { &(*(volatile uint8_t *)((0x08) + 0x20)), &(*(volatile uint8_t *)((0x06) + 0x20)), &(*(volatile uint8_t *)((0x07) + 0x20)) }; PinC0_ = (Pin) { PortC, (1 << (0)) }; PinC1_ = (Pin) { PortC, (1 << (1)) }; PinC2_ = (Pin) { PortC, (1 << (2)) }; PinC3_ = (Pin) { PortC, (1 << (3)) }; PinC4_ = (Pin) { PortC, (1 << (4)) }; PinC5_ = (Pin) { PortC, (1 << (5)) }; PinC6_ = (Pin) { PortC, (1 << (6)) }; PinC7_ = (Pin) { PortC, (1 << (7)) };;
 PortD_ = (Port) { &(*(volatile uint8_t *)((0x0B) + 0x20)), &(*(volatile uint8_t *)((0x09) + 0x20)), &(*(volatile uint8_t *)((0x0A) + 0x20)) }; PinD0_ = (Pin) { PortD, (1 << (0)) }; PinD1_ = (Pin) { PortD, (1 << (1)) }; PinD2_ = (Pin) { PortD, (1 << (2)) }; PinD3_ = (Pin) { PortD, (1 << (3)) }; PinD4_ = (Pin) { PortD, (1 << (4)) }; PinD5_ = (Pin) { PortD, (1 << (5)) }; PinD6_ = (Pin) { PortD, (1 << (6)) }; PinD7_ = (Pin) { PortD, (1 << (7)) };;
}
void init_ports_m1284P_kernel_init() __attribute__((naked, section(".init8"))); void init_ports_m1284P_kernel_init() { init_ports_m1284P(); }
# 14 "..\\..\\AntonAvrLib/kernel/devices/timer_m1284P.kernel.h" 2

void init_timer_m1284P() {
 Timer0_ = (TimerPair) {0, (uint8_t*) &(*(volatile uint8_t *)((0x24) + 0x20)), (uint8_t*) &(*(volatile uint8_t *)((0x25) + 0x20)), &(*(volatile uint8_t *)(0x6E))};
 Timer1_ = (TimerPair) {(1 << 2), (uint8_t*) &(*(volatile uint8_t *)(0x80)), (uint8_t*) &(*(volatile uint8_t *)(0x81)), &(*(volatile uint8_t *)(0x6F))};
 Timer2_ = (TimerPair) {(1 << 1), (uint8_t*) &(*(volatile uint8_t *)(0xB0)), (uint8_t*) &(*(volatile uint8_t *)(0xB1)), &(*(volatile uint8_t *)(0x70))};
 Timer3_ = (TimerPair) {(1 << 2), (uint8_t*) &(*(volatile uint8_t *)(0x90)), (uint8_t*) &(*(volatile uint8_t *)(0x91)), &(*(volatile uint8_t *)(0x71))};

 Timer0A_ = (Timer) {Timer0, (uint8_t*) &(*(volatile uint8_t *)((0x27) + 0x20)), TIMER_A, PinB3};
 Timer0B_ = (Timer) {Timer0, (uint8_t*) &(*(volatile uint8_t *)((0x28) + 0x20)), TIMER_B, PinB4};
 Timer1A_ = (Timer) {Timer1, (uint8_t*) &(*(volatile uint16_t *)(0x88)), TIMER_A, PinD5};
 Timer1B_ = (Timer) {Timer1, (uint8_t*) &(*(volatile uint16_t *)(0x8A)), TIMER_B, PinD4};
 Timer2A_ = (Timer) {Timer2, (uint8_t*) &(*(volatile uint8_t *)(0xB3)), TIMER_A, PinD7};
 Timer2B_ = (Timer) {Timer2, (uint8_t*) &(*(volatile uint8_t *)(0xB4)), TIMER_B, PinD6};
 Timer3A_ = (Timer) {Timer3, (uint8_t*) &(*(volatile uint16_t *)(0x98)), TIMER_A, PinB6};
 Timer3B_ = (Timer) {Timer3, (uint8_t*) &(*(volatile uint16_t *)(0x9A)), TIMER_B, PinB7};
}
void init_timer_m1284P_kernel_init() __attribute__((naked, section(".init8"))); void init_timer_m1284P_kernel_init() { init_timer_m1284P(); }
# 8 ".././shared/timer.kernel.h" 2

#define CLOCKISR_A TIMER3_COMPA_vect
#define CLOCKISR_B TIMER3_COMPB_vect
#define CLOCKTIMER_A Timer3A
#define CLOCKTIMER_B Timer3B

void init_timer() {
 setWaveformGenerationMode(Timer3, clear_timer_on_match);
 setTimerClockSelect(Timer3, prescale_8);



#define MILLISECOND_TIMER_VALUE ((uint16_t) 2500)

 setTimerCompareValue(Timer3A, ((uint16_t) 2500));
 setTimerCompareValue(Timer3B, ((uint16_t) 2500));
}
void init_timer_kernel_init() __attribute__((naked, section(".init8"))); void init_timer_kernel_init() { init_timer(); }
# 28 ".././shared/base_before.kernel.h" 2
#define CLOCKISR CLOCKISR_A
#define TIMER_INTERRUPT_A 
# 1 "..\\..\\AntonAvrLib/kernel/timer_base.kernel.h" 1
# 9 "..\\..\\AntonAvrLib/kernel/timer_base.kernel.h"
#define _TIMER_BASE_KERNEL_ 
# 23 "..\\..\\AntonAvrLib/kernel/timer_base.kernel.h"
# 1 "..\\..\\AntonAvrLib/kernel/millisecond_clock.h" 1
# 24 "..\\..\\AntonAvrLib/kernel/timer_base.kernel.h" 2
#define TIMER_TICK_ISR_NAKED ISR(CLOCKISR, __attribute__((naked)))
#define TIMER_TICK_ISR ISR(CLOCKISR)


void in_timer_tick() __attribute__((weak));
void in_timer_tick() {};


#define TIMER_TICK_ACTION milliseconds_running++; in_timer_tick();
# 31 ".././shared/base_before.kernel.h" 2





# 1 "..\\..\\AntonAvrLib/kernel/simple_timer.kernel.h" 1

#define _SIMPLE_TIMER_KERNEL_ 




void __vector_32 (void) __attribute__ ((signal,used, externally_visible)) ; void __vector_32 (void) {
 milliseconds_running++; in_timer_tick();
}
# 37 ".././shared/base_before.kernel.h" 2
#define INITIALIZE_SCHEDULER 

# 1 "..\\..\\AntonAvrLib/kernel/processes/mutex/atomic_mutex.kernel.h" 1
# 9 "..\\..\\AntonAvrLib/kernel/processes/mutex/atomic_mutex.kernel.h"
#define _ATOMIC_MUTEX_KERNEL_ 




typedef struct {
 BOOL interruptsWereEnabled;
} AtomicMutex;

Mutex mutex_create() {
 return (Mutex) malloc(sizeof(AtomicMutex));
}

void mutex_lock(Mutex mutex) {
 ((AtomicMutex *) mutex)->interruptsWereEnabled = (*(volatile uint8_t *)((0x3F) + 0x20)) & (1 << (7));
 __asm__ __volatile__ ("cli" ::: "memory");
}

BOOL mutex_trylock(Mutex mutex) {
 mutex_lock(mutex);
 return TRUE;
}

void mutex_release(Mutex mutex) {

  __asm__ __volatile__ ("sei" ::: "memory");
}
# 40 ".././shared/base_before.kernel.h" 2


# 1 "..\\..\\AntonAvrLib/kernel/sleep_after_main.kernel.h" 1

#define _SLEEP_AFTER_MAIN_KERNEL_ 

# 1 "..\\..\\AntonAvrLib/kernel/../misc/idle.h" 1

#define IDLE_H_ 



void processor_idle();






void processor_loop_idle();
# 5 "..\\..\\AntonAvrLib/kernel/sleep_after_main.kernel.h" 2


void MainProcessEnd() __attribute__((section (".fini1")));
void MainProcessEnd() {
 processor_loop_idle();
}
# 43 ".././shared/base_before.kernel.h" 2
# 11 ".././kernel.c" 2
# 1 ".././tank_led.kernel.h" 1
# 9 ".././tank_led.kernel.h"
#define _TANK_LED_KERNEL_ 

# 1 "..\\..\\AntonAvrLib/kernel/devices/port_m1284P.kernel.h" 1
# 12 ".././tank_led.kernel.h" 2
# 1 "..\\..\\AntonAvrLib/kernel/devices/led.kernel.h" 1
# 9 "..\\..\\AntonAvrLib/kernel/devices/led.kernel.h"
#define _LED_KERNEL_ 


# 1 "..\\..\\AntonAvrLib/kernel/devices/led.h" 1
# 13 "..\\..\\AntonAvrLib/kernel/devices/led.kernel.h" 2

static void initLed(PLed led) {
 setPinOutput(led->pin);
}
# 13 ".././tank_led.kernel.h" 2
# 1 ".././tank_led.h" 1
# 14 ".././tank_led.kernel.h" 2


PLed redLedsArray[] = { &Red1_, &Red2_, &Red3_, &Red4_, &Red5_ };
PLed yellowLedsArray[] = { &Yellow1_, &Yellow2_ };
PLed whiteLedsArray[] = { &White1_, &White2_, &White3_, &White4_, &White5_ };
PLed greenLedsArray[] = { &Green1_, &Green2_, &Green3_ };
PLed middleLedsArray[] = { &Green1_, &Green2_, &Green3_, &Yellow1_, &Yellow2_ };
PLed allLedsArray[] = {
    &White1_, &White2_, &White3_, &White4_, &White5_,
    &Green1_, &Green2_, &Green3_, &Yellow1_, &Yellow2_,
    &Red1_, &Red2_, &Red3_, &Red4_, &Red5_ };

void init_tank_leds() {
 White1_ = (Led) { PinB0 }; initLed(White1);
 White2_ = (Led) { PinB1 }; initLed(White2);
 White3_ = (Led) { PinB2 }; initLed(White3);
 White4_ = (Led) { PinB3 }; initLed(White4);
 White5_ = (Led) { PinB4 }; initLed(White5);

 Green1_ = (Led) { PinB5 }; initLed(Green1);
 Green2_ = (Led) { PinB6 }; initLed(Green2);
 Green3_ = (Led) { PinB7 }; initLed(Green3);
 Yellow1_ = (Led) { PinD0 }; initLed(Yellow1);
 Yellow2_ = (Led) { PinD1 }; initLed(Yellow2);

 Red1_ = (Led) { PinD2 }; initLed(Red1);
 Red2_ = (Led) { PinD3 }; initLed(Red2);
 Red3_ = (Led) { PinD4 }; initLed(Red3);
 Red4_ = (Led) { PinD5 }; initLed(Red4);
 Red5_ = (Led) { PinD6 }; initLed(Red5);

 RedLeds_ = (LedGroup) { redLedsArray, 5 };
 YellowLeds_ = (LedGroup) { yellowLedsArray, 2 };
 WhiteLeds_ = (LedGroup) { whiteLedsArray, 5 };
 GreenLeds_ = (LedGroup) { greenLedsArray, 3 };
 MiddleLeds_ = (LedGroup) { middleLedsArray, 5 };
 AllLeds_ = (LedGroup) { allLedsArray, 15 };
}
void init_tank_leds_kernel_init() __attribute__((naked, section(".init8"))); void init_tank_leds_kernel_init() { init_tank_leds(); }
# 12 ".././kernel.c" 2
# 1 ".././tank_button.kernel.h" 1
# 9 ".././tank_button.kernel.h"
#define _TANK_BUTTON_KERNEL_ 



# 1 "..\\..\\AntonAvrLib/kernel/devices/button.kernel.h" 1
# 9 "..\\..\\AntonAvrLib/kernel/devices/button.kernel.h"
#define _BUTTON_KERNEL_ 





# 1 "..\\..\\AntonAvrLib/kernel/devices/external_interrupts.h" 1
# 9 "..\\..\\AntonAvrLib/kernel/devices/external_interrupts.h"
#define EXTERNAL_INTERRUPTS_H_ 





void enablePinChangeInterrupt(uint8_t pcNumber);
void disblePinChangeInterrupt(uint8_t pcNumber);
# 16 "..\\..\\AntonAvrLib/kernel/devices/button.kernel.h" 2
# 1 "..\\..\\AntonAvrLib/kernel/devices/button.h" 1
# 17 "..\\..\\AntonAvrLib/kernel/devices/button.kernel.h" 2

void initButton(PButton button) {
 setPinInput(button->pin);
 if (button->flags & (1 << (1)))
  setPinOne(button->pin);


 if (button->flags & (1 << (2)))

  enablePinChangeInterrupt(button->pinChangeInterruptNumber);
}
# 14 ".././tank_button.kernel.h" 2
# 1 ".././tank_button.h" 1
# 15 ".././tank_button.kernel.h" 2


Mutex buttonMutex;
uint8_t buttonsPressedSinceLastCall = 0;
uint8_t wasPressed = 0;

void init_tank_buttons() {
#define TANK_BUTTON BUTTON_INVERTED | BUTTON_NEEDS_PULLUP
 Button1_ = (Button) { (1 << (0)) | (1 << (1)), PinC5, 21 }; initButton(Button1);
 Button2_ = (Button) { (1 << (0)) | (1 << (1)), PinC4, 20 }; initButton(Button2);
 Button3_ = (Button) { (1 << (0)) | (1 << (1)), PinC3, 19 }; initButton(Button3);
 Button4_ = (Button) { (1 << (0)) | (1 << (1)), PinC2, 18 }; initButton(Button4);
 ButtonSwitch_ = (Button) { (1 << (0)) | (1 << (1)), PinD7, 31 }; initButton(ButtonSwitch);
 buttonMutex = mutex_create();
}
void init_tank_buttons_kernel_init() __attribute__((naked, section(".init8"))); void init_tank_buttons_kernel_init() { init_tank_buttons(); }

uint8_t buttonStatusMask() {
 uint8_t buttons = 0;
 if (buttonStatus(Button1)) buttons |= BUTTON_1;
 if (buttonStatus(Button2)) buttons |= BUTTON_2;
 if (buttonStatus(Button3)) buttons |= BUTTON_3;
 if (buttonStatus(Button4)) buttons |= BUTTON_4;
 if (buttonStatus(ButtonSwitch)) buttons |= BUTTON_SWITCH;
 return buttons;
}

uint8_t pressedButtons() {
 mutex_lock(buttonMutex);
 uint8_t result = buttonsPressedSinceLastCall;
 buttonsPressedSinceLastCall = 0;
 mutex_release(buttonMutex);
 return result;
}

void updateButtonStatus() {
 uint8_t pressedNow = buttonStatusMask();
 uint8_t newlyPressed = 0;

 if (!(wasPressed & BUTTON_1) && (pressedNow & BUTTON_1))
  newlyPressed |= BUTTON_1;
 if (!(wasPressed & BUTTON_2) && (pressedNow & BUTTON_2))
  newlyPressed |= BUTTON_2;
 if (!(wasPressed & BUTTON_3) && (pressedNow & BUTTON_3))
  newlyPressed |= BUTTON_3;
 if (!(wasPressed & BUTTON_4) && (pressedNow & BUTTON_4))
  newlyPressed |= BUTTON_4;
 if (!(wasPressed & BUTTON_SWITCH) && (pressedNow & BUTTON_SWITCH))
  newlyPressed |= BUTTON_SWITCH;

 mutex_lock(buttonMutex);
 buttonsPressedSinceLastCall |= newlyPressed;
 mutex_release(buttonMutex);

 wasPressed = pressedNow;
}
# 13 ".././kernel.c" 2
# 1 ".././tank_IO_server.kernel.h" 1
# 9 ".././tank_IO_server.kernel.h"
#define _TANK_IO_SERVER_KERNEL_ 



# 1 "..\\..\\AntonAvrLib/misc/hardware_reset.h" 1
# 9 "..\\..\\AntonAvrLib/misc/hardware_reset.h"
#define HARWARE_RESET_H_ 



void HARDWARE_RESET();
# 14 ".././tank_IO_server.kernel.h" 2

# 1 ".././shared/tank_IO_protocol.h" 1
# 16 ".././tank_IO_server.kernel.h" 2
#define TWI_Slave_Address TANK_IO_ADDRESS
#define TWI_Slave 




# 1 "..\\..\\AntonAvrLib/kernel/TWI/twi_rpc_hash_server.kernel.h" 1

#define _TWI_RPC_HASH_SERVER_KERNEL_ 



# 1 "..\\..\\AntonAvrLib/kernel/TWI/twi_rpc.kernel.h" 1

#define _TWI_RPC_KERNEL_ 

# 1 "..\\..\\AntonAvrLib/kernel/TWI/twi_raw.kernel.h" 1

#define _TWI_RAW_KERNEL_ 
# 14 "..\\..\\AntonAvrLib/kernel/TWI/twi_raw.kernel.h"
# 1 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/twi.h" 1 3
# 36 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/twi.h" 3
#define _UTIL_TWI_H_ 1
# 61 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/twi.h" 3
#define TW_START 0x08




#define TW_REP_START 0x10





#define TW_MT_SLA_ACK 0x18




#define TW_MT_SLA_NACK 0x20




#define TW_MT_DATA_ACK 0x28




#define TW_MT_DATA_NACK 0x30




#define TW_MT_ARB_LOST 0x38





#define TW_MR_ARB_LOST 0x38




#define TW_MR_SLA_ACK 0x40




#define TW_MR_SLA_NACK 0x48




#define TW_MR_DATA_ACK 0x50




#define TW_MR_DATA_NACK 0x58





#define TW_ST_SLA_ACK 0xA8




#define TW_ST_ARB_LOST_SLA_ACK 0xB0




#define TW_ST_DATA_ACK 0xB8




#define TW_ST_DATA_NACK 0xC0




#define TW_ST_LAST_DATA 0xC8





#define TW_SR_SLA_ACK 0x60




#define TW_SR_ARB_LOST_SLA_ACK 0x68




#define TW_SR_GCALL_ACK 0x70




#define TW_SR_ARB_LOST_GCALL_ACK 0x78




#define TW_SR_DATA_ACK 0x80




#define TW_SR_DATA_NACK 0x88




#define TW_SR_GCALL_DATA_ACK 0x90




#define TW_SR_GCALL_DATA_NACK 0x98




#define TW_SR_STOP 0xA0





#define TW_NO_INFO 0xF8




#define TW_BUS_ERROR 0x00
# 210 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/twi.h" 3
#define TW_STATUS_MASK (_BV(TWS7)|_BV(TWS6)|_BV(TWS5)|_BV(TWS4)| _BV(TWS3))







#define TW_STATUS (TWSR & TW_STATUS_MASK)
# 229 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/twi.h" 3
#define TW_READ 1




#define TW_WRITE 0
# 15 "..\\..\\AntonAvrLib/kernel/TWI/twi_raw.kernel.h" 2
# 1 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/atomic.h" 1 3
# 35 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/atomic.h" 3
#define _UTIL_ATOMIC_H_ 1






static __inline__ uint8_t __iSeiRetVal(void)
{
    __asm__ __volatile__ ("sei" ::: "memory");
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    __asm__ __volatile__ ("cli" ::: "memory");
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    __asm__ __volatile__ ("sei" ::: "memory");
    __asm__ volatile ("" ::: "memory");
    (void)__s;
}

static __inline__ void __iCliParam(const uint8_t *__s)
{
    __asm__ __volatile__ ("cli" ::: "memory");
    __asm__ volatile ("" ::: "memory");
    (void)__s;
}

static __inline__ void __iRestore(const uint8_t *__s)
{
    (*(volatile uint8_t *)((0x3F) + 0x20)) = *__s;
    __asm__ volatile ("" ::: "memory");
}
# 205 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/atomic.h" 3
#define ATOMIC_BLOCK(type) for ( type, __ToDo = __iCliRetVal(); __ToDo ; __ToDo = 0 )
# 226 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/atomic.h" 3
#define NONATOMIC_BLOCK(type) for ( type, __ToDo = __iSeiRetVal(); __ToDo ; __ToDo = 0 )
# 244 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/atomic.h" 3
#define ATOMIC_RESTORESTATE uint8_t sreg_save __attribute__((__cleanup__(__iRestore))) = SREG
# 265 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/atomic.h" 3
#define ATOMIC_FORCEON uint8_t sreg_save __attribute__((__cleanup__(__iSeiParam))) = 0
# 283 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/atomic.h" 3
#define NONATOMIC_RESTORESTATE uint8_t sreg_save __attribute__((__cleanup__(__iRestore))) = SREG
# 304 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/util/atomic.h" 3
#define NONATOMIC_FORCEOFF uint8_t sreg_save __attribute__((__cleanup__(__iCliParam))) = 0
# 16 "..\\..\\AntonAvrLib/kernel/TWI/twi_raw.kernel.h" 2



#define TWI_DEBUG_ERROR(error_code) 


#define TWI_DEBUG_BYTE_RECEIVED(data) 


#define TWI_DEBUG_BYTE_SENT(data) 


#define TWI_DEBUG_INTERRUPT(status) 


TWIDevice TWIBroadcast = { 0 };


 TWIBuffer twi_handleMasterRequest();
 void twi_handleMasterTransmission(TWIBuffer twi_buffer);
 byte twi_defaultSlaveBufferData[255];
 TWIBuffer twi_defaultSlaveBuffer = { twi_defaultSlaveBufferData, 255 };
# 46 "..\\..\\AntonAvrLib/kernel/TWI/twi_raw.kernel.h"
void twi_unexpectedCondition() __attribute__((weak));
void twi_unexpectedCondition() {

}
# 58 "..\\..\\AntonAvrLib/kernel/TWI/twi_raw.kernel.h"
volatile BOOL twi_running;
TWIDevice twi_address;
uint16_t alreadyHandled;
TWIBuffer twi_buffer;
TWIError twi_error;
TWIOperation furtherOperations[3];
int nextTwiOperation;

void init_twi() {
 (*(volatile uint8_t *)(0xBC)) = (1 << (0)) | (1 << (2));
 (*(volatile uint8_t *)(0xBB)) = 0xff;
 (*(volatile uint8_t *)(0xB8)) = 17;
 (*(volatile uint8_t *)(0xB9)) = 0;





  (*(volatile uint8_t *)(0xBA)) = (11 << 2);

}
void init_twi_kernel_init() __attribute__((naked, section(".init8"))); void init_twi_kernel_init() { init_twi(); }

#define twi_base TWCR = _BV(TWEN) | _BV(TWINT) | _BV(TWIE)
#define twi_start() twi_base | _BV(TWSTA)
#define twi_ack() twi_base | _BV(TWEA)
#define twi_continue() twi_base
#define twi_send_ack(data) TWDR = data; twi_ack()

static inline void twi_send(uint8_t data) {

 (*(volatile uint8_t *)(0xBB)) = data;
 (*(volatile uint8_t *)(0xBC)) = (1 << (2)) | (1 << (7)) | (1 << (0));
}

static inline void twi_stop() {

  (*(volatile uint8_t *)(0xBC)) = (1 << (2)) | (1 << (7)) | (1 << (0)) | (1 << (4)) | (1 << (6));
  twi_buffer = twi_defaultSlaveBuffer;



 twi_running = FALSE;
}

BOOL next_twi_operation() {
 TWIOperation current;

 if (nextTwiOperation >= 3) return FALSE;
 do {
  current = furtherOperations[nextTwiOperation++];
  if (current.operationMode != TWI_IllegalOperation) break;
 } while (nextTwiOperation < 3);
 if (nextTwiOperation >= 3) return FALSE;



 if (current.operationMode == TWI_Send) {
  twi_address.address = current.device.address & ~(1 << (0));
 } else if (current.operationMode == TWI_Receive) {
  twi_address.address = current.device.address | (1 << (0));
 }
 alreadyHandled = 0;
 twi_buffer = current.buffer;
 return TRUE;
}

static inline void twi_stop_or_next() {
 if (!next_twi_operation()) {
  twi_stop();
 } else {

  (*(volatile uint8_t *)(0xBC)) = (1 << (2)) | (1 << (7)) | (1 << (0)) | (1 << (5));
 }
}

static inline void twi_end() {

  (*(volatile uint8_t *)(0xBC)) = (1 << (2)) | (1 << (7)) | (1 << (0)) | (1 << (6));
  twi_buffer = twi_defaultSlaveBuffer;



 twi_running = FALSE;
}

void twi_start_master_operation() {
 twi_error = TWI_No_Error;
 twi_running = TRUE;
 nextTwiOperation = 0;
 if (next_twi_operation()) {
  (*(volatile uint8_t *)(0xBC)) = (1 << (2)) | (1 << (7)) | (1 << (0)) | (1 << (5));
 }
}

static inline void twi_ack_receive() {



 if (alreadyHandled + 1 < twi_buffer.size) {
  (*(volatile uint8_t *)(0xBC)) = (1 << (2)) | (1 << (7)) | (1 << (0)) | (1 << (6));
 } else {
  (*(volatile uint8_t *)(0xBC)) = (1 << (2)) | (1 << (7)) | (1 << (0));
 }
}

static inline void twi_read_byte() {






 if (alreadyHandled < twi_buffer.size)
  twi_buffer.data[alreadyHandled++] = (*(volatile uint8_t *)(0xBB));
}

void __vector_26 (void) __attribute__ ((signal,used, externally_visible)) ; void __vector_26 (void) {


 switch(((*(volatile uint8_t *)(0xB9)) & ((1 << (7))|(1 << (6))|(1 << (5))|(1 << (4))| (1 << (3))))) {

  case 0x08:
  case 0x10:

   twi_send(twi_address.address);
   break;
  case 0x38:
   twi_error = TWI_Arbitration_Lost;
   twi_end();
   break;

  case 0x28:
  case 0x18:


   if (alreadyHandled < twi_buffer.size) {
    twi_send(twi_buffer.data[alreadyHandled++]);
   } else {
    twi_stop_or_next();
   }
   break;
  case 0x20:
   twi_error = TWI_SlaveAddress_NoAck;
   twi_stop();
   break;
  case 0x30:
   twi_error = TWI_Master_TooMuchDataTransmitted;
   twi_stop();
   break;

  case 0x40:
   twi_ack_receive();
   break;
  case 0x50:
   twi_read_byte();
   twi_ack_receive();
   break;
  case 0x48:
   twi_error = TWI_SlaveAddress_NoAck;
   twi_stop();
   break;
  case 0x58:


   twi_read_byte();
   twi_stop_or_next();
   break;


  case 0xA8:
  case 0xB0:
   twi_buffer = twi_handleMasterRequest();
  case 0xB8:
   if (alreadyHandled < twi_buffer.size - 1) {

    (*(volatile uint8_t *)(0xBB)) = twi_buffer.data[alreadyHandled++]; (*(volatile uint8_t *)(0xBC)) = (1 << (2)) | (1 << (7)) | (1 << (0)) | (1 << (6));
   } else {

    twi_send(twi_buffer.data[alreadyHandled++]);
   }
   break;
  case 0xC8:
   twi_error = TWI_Slave_NotEnoughDataTransmitted;
   twi_end();
   break;
  case 0xC0:
   if (alreadyHandled < twi_buffer.size) {
    twi_error = TWI_Slave_TooMuchDataTransmitted;
   }
   twi_end();
   break;

  case 0x60:
  case 0x68:
  case 0x70:
  case 0x78:
   twi_ack_receive();
   break;
  case 0x80:
  case 0x90:
   twi_read_byte();
   twi_ack_receive();
   break;
  case 0xA0:

   twi_error = TWI_Slave_NotEnoughDataReceived;
  case 0x88:
  case 0x98:
   twi_read_byte();

   twi_handleMasterTransmission((TWIBuffer) { twi_buffer.data, alreadyHandled } );
   twi_end();
   break;


  case 0xF8:
   twi_error = TWI_No_Info_Interrupt;
   twi_unexpectedCondition();
   break;
  case 0x00:
   twi_error = TWI_Bus_Error;
   twi_unexpectedCondition();
   break;
  default:
   twi_error = TWI_Illegal_Status;
   twi_unexpectedCondition();
   break;
 }
}

void twiSend(TWIDevice targetDevice, TWIBuffer data) {
 TWIOperation op[1] = { (TWIOperation) { data, targetDevice, TWI_Send} };
 twiMultipleOperations(1, op);
}

void twiReceive(TWIDevice targetDevice, TWIBuffer receiveBuffer) {
 TWIOperation op[1] = { (TWIOperation) { receiveBuffer, targetDevice, TWI_Receive} };
 twiMultipleOperations(1, op);
}

void twiSendReceive(TWIDevice targetDevice, TWIBuffer sendData, TWIBuffer receiveBuffer) {
 TWIOperation ops[2] = {
  (TWIOperation) { sendData, targetDevice, TWI_Send },
  (TWIOperation) { receiveBuffer, targetDevice, TWI_Receive }
 };
 twiMultipleOperations(2, ops);
}

void twiMultipleOperations(int count, TWIOperation *operations) {
 int i = 0;
 for (; i < count && i < 3; i++) {
  furtherOperations[i] = operations[i];
 }
 for (; i < 3; i++) {
  furtherOperations[i].operationMode = TWI_IllegalOperation;
 }
 twi_start_master_operation();
}

void WAIT_FOR_TWI() {
 while (1) {
  uint8_t still_running;
  for ( uint8_t sreg_save __attribute__((__cleanup__(__iSeiParam))) = 0, __ToDo = __iCliRetVal(); __ToDo ; __ToDo = 0 ) {
   still_running = twi_running;
  }
  if (!still_running) {





   break;
  }
 }
}

void turn_word(uint16_t *word) {
 uint8_t temp = ((uint8_t*) word)[0];
 ((uint8_t*) word)[0] = ((uint8_t*) word)[1];
 ((uint8_t*) word)[1] = temp;
}
# 5 "..\\..\\AntonAvrLib/kernel/TWI/twi_rpc.kernel.h" 2

# 1 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/string.h" 1 3
# 41 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/string.h" 3
#define _STRING_H_ 1

#define __need_NULL 
#define __need_size_t 
# 1 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/include/stddef.h" 1 3 4
# 233 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/include/stddef.h" 3 4
#undef __need_size_t
# 395 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/include/stddef.h" 3 4
#undef NULL




#define NULL ((void *)0)





#undef __need_NULL
# 46 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/string.h" 2 3
# 91 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/string.h" 3
#define _FFS(x) (1 + (((x) & 1) == 0) + (((x) & 3) == 0) + (((x) & 7) == 0) + (((x) & 017) == 0) + (((x) & 037) == 0) + (((x) & 077) == 0) + (((x) & 0177) == 0) + (((x) & 0377) == 0) + (((x) & 0777) == 0) + (((x) & 01777) == 0) + (((x) & 03777) == 0) + (((x) & 07777) == 0) + (((x) & 017777) == 0) + (((x) & 037777) == 0) + (((x) & 077777) == 0) - (((x) & 0177777) == 0) * 16)
# 111 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/../../../../avr/include/string.h" 3
extern int ffs (int __val) __attribute__((__const__));
extern int ffsl (long __val) __attribute__((__const__));
extern int ffsll (long long __val) __attribute__((__const__));
extern void *memccpy(void *, const void *, int, size_t);
extern void *memchr(const void *, int, size_t) __attribute__((__pure__));
extern int memcmp(const void *, const void *, size_t) __attribute__((__pure__));
extern void *memcpy(void *, const void *, size_t);
extern void *memmem(const void *, size_t, const void *, size_t) __attribute__((__pure__));
extern void *memmove(void *, const void *, size_t);
extern void *memrchr(const void *, int, size_t) __attribute__((__pure__));
extern void *memset(void *, int, size_t);
extern char *strcat(char *, const char *);
extern char *strchr(const char *, int) __attribute__((__pure__));
extern char *strchrnul(const char *, int) __attribute__((__pure__));
extern int strcmp(const char *, const char *) __attribute__((__pure__));
extern char *strcpy(char *, const char *);
extern int strcasecmp(const char *, const char *) __attribute__((__pure__));
extern char *strcasestr(const char *, const char *) __attribute__((__pure__));
extern size_t strcspn(const char *__s, const char *__reject) __attribute__((__pure__));
extern char *strdup(const char *s1);
extern size_t strlcat(char *, const char *, size_t);
extern size_t strlcpy(char *, const char *, size_t);
extern size_t strlen(const char *) __attribute__((__pure__));
extern char *strlwr(char *);
extern char *strncat(char *, const char *, size_t);
extern int strncmp(const char *, const char *, size_t) __attribute__((__pure__));
extern char *strncpy(char *, const char *, size_t);
extern int strncasecmp(const char *, const char *, size_t) __attribute__((__pure__));
extern size_t strnlen(const char *, size_t) __attribute__((__pure__));
extern char *strpbrk(const char *__s, const char *__accept) __attribute__((__pure__));
extern char *strrchr(const char *, int) __attribute__((__pure__));
extern char *strrev(char *);
extern char *strsep(char **, const char *);
extern size_t strspn(const char *__s, const char *__accept) __attribute__((__pure__));
extern char *strstr(const char *, const char *) __attribute__((__pure__));
extern char *strtok(char *, const char *);
extern char *strtok_r(char *, const char *, char **);
extern char *strupr(char *);
# 7 "..\\..\\AntonAvrLib/kernel/TWI/twi_rpc.kernel.h" 2





byte sendBufferData[255];
TWIBuffer sendBuffer = { sendBufferData, 255 };





 TWIBuffer receiveBuffer;



 void twi_handleRpcRequest(byte operation, TWIBuffer *arguments);

 TWIBuffer twi_handleMasterRequest() {



  return receiveBuffer;
 }

 void twi_handleMasterTransmission(TWIBuffer twi_buffer) {
  byte operation = twi_buffer.data[0];
  twi_buffer.data++;
  twi_buffer.size--;
  twi_handleRpcRequest(operation, &twi_buffer);


  receiveBuffer = twi_buffer;
 }


static inline void fillSendBuffer(byte operation, TWIBuffer parameters) {
 sendBuffer.data[0] = operation;
 sendBuffer.size = parameters.size + 1;
 memcpy(sendBuffer.data + 1, parameters.data, parameters.size);
}

void twi_rpc_oneway(TWIDevice device, byte operation, TWIBuffer parameters) {
 fillSendBuffer(operation, parameters);
 twiSend(device, sendBuffer);
}

void twi_rpc_pseudo_oneway(TWIDevice device, byte operation, TWIBuffer parameters) {
 fillSendBuffer(operation, parameters);
 twiSendReceive(device, sendBuffer, (TWIBuffer) { 0, 0 });
}

void twi_rpc(TWIDevice device, byte operation, TWIBuffer parameters, TWIBuffer resultBuffer) {
 fillSendBuffer(operation, parameters);
 twiSendReceive(device, sendBuffer, resultBuffer);
}
# 7 "..\\..\\AntonAvrLib/kernel/TWI/twi_rpc_hash_server.kernel.h" 2
#define HASH_FUNCTION HASH_SAX
# 1 "..\\..\\AntonAvrLib/uthash/uthash.h" 1
# 25 "..\\..\\AntonAvrLib/uthash/uthash.h"
#define UTHASH_H 


# 1 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/include/stddef.h" 1 3 4
# 40 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/include/stddef.h" 3 4
#define _STDDEF_H 
#define _STDDEF_H_ 

#define _ANSI_STDDEF_H 

#define __STDDEF_H__ 
# 138 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/include/stddef.h" 3 4
#define _PTRDIFF_T 
#define _T_PTRDIFF_ 
#define _T_PTRDIFF 
#define __PTRDIFF_T 
#define _PTRDIFF_T_ 
#define _BSD_PTRDIFF_T_ 
#define ___int_ptrdiff_t_h 
#define _GCC_PTRDIFF_T 



typedef int ptrdiff_t;
# 160 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/include/stddef.h" 3 4
#undef __need_ptrdiff_t
# 233 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/include/stddef.h" 3 4
#undef __need_size_t
# 342 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/include/stddef.h" 3 4
#undef __need_wchar_t
# 395 "c:\\program files (x86)\\atmel\\atmel studio 6.0\\extensions\\atmel\\avrgcc\\3.3.2.31\\avrtoolchain\\bin\\../lib/gcc/avr/4.5.1/include/stddef.h" 3 4
#undef NULL




#define NULL ((void *)0)





#undef __need_NULL




#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)
# 29 "..\\..\\AntonAvrLib/uthash/uthash.h" 2
# 43 "..\\..\\AntonAvrLib/uthash/uthash.h"
#define DECLTYPE(x) (__typeof(x))
# 53 "..\\..\\AntonAvrLib/uthash/uthash.h"
#define DECLTYPE_ASSIGN(dst,src) do { (dst) = DECLTYPE(dst)(src); } while(0)
# 67 "..\\..\\AntonAvrLib/uthash/uthash.h"
#define UTHASH_VERSION 1.9.6


#define uthash_fatal(msg) exit(-1)


#define uthash_malloc(sz) malloc(sz)


#define uthash_free(ptr,sz) free(ptr)



#define uthash_noexpand_fyi(tbl) 


#define uthash_expand_fyi(tbl) 



#define HASH_INITIAL_NUM_BUCKETS 32
#define HASH_INITIAL_NUM_BUCKETS_LOG2 5
#define HASH_BKT_CAPACITY_THRESH 10


#define ELMT_FROM_HH(tbl,hhp) ((void*)(((char*)(hhp)) - ((tbl)->hho)))

#define HASH_FIND(hh,head,keyptr,keylen,out) do { unsigned _hf_bkt,_hf_hashv; out=NULL; if (head) { HASH_FCN(keyptr,keylen, (head)->hh.tbl->num_buckets, _hf_hashv, _hf_bkt); if (HASH_BLOOM_TEST((head)->hh.tbl, _hf_hashv)) { HASH_FIND_IN_BKT((head)->hh.tbl, hh, (head)->hh.tbl->buckets[ _hf_bkt ], keyptr,keylen,out); } } } while (0)
# 134 "..\\..\\AntonAvrLib/uthash/uthash.h"
#define HASH_BLOOM_MAKE(tbl) 
#define HASH_BLOOM_FREE(tbl) 
#define HASH_BLOOM_ADD(tbl,hashv) 
#define HASH_BLOOM_TEST(tbl,hashv) (1)


#define HASH_MAKE_TABLE(hh,head) do { (head)->hh.tbl = (UT_hash_table*)uthash_malloc( sizeof(UT_hash_table)); if (!((head)->hh.tbl)) { uthash_fatal( "out of memory"); } memset((head)->hh.tbl, 0, sizeof(UT_hash_table)); (head)->hh.tbl->tail = &((head)->hh); (head)->hh.tbl->num_buckets = HASH_INITIAL_NUM_BUCKETS; (head)->hh.tbl->log2_num_buckets = HASH_INITIAL_NUM_BUCKETS_LOG2; (head)->hh.tbl->hho = (char*)(&(head)->hh) - (char*)(head); (head)->hh.tbl->buckets = (UT_hash_bucket*)uthash_malloc( HASH_INITIAL_NUM_BUCKETS*sizeof(struct UT_hash_bucket)); if (! (head)->hh.tbl->buckets) { uthash_fatal( "out of memory"); } memset((head)->hh.tbl->buckets, 0, HASH_INITIAL_NUM_BUCKETS*sizeof(struct UT_hash_bucket)); HASH_BLOOM_MAKE((head)->hh.tbl); (head)->hh.tbl->signature = HASH_SIGNATURE; } while(0)
# 159 "..\\..\\AntonAvrLib/uthash/uthash.h"
#define HASH_ADD(hh,head,fieldname,keylen_in,add) HASH_ADD_KEYPTR(hh,head,&((add)->fieldname),keylen_in,add)


#define HASH_ADD_KEYPTR(hh,head,keyptr,keylen_in,add) do { unsigned _ha_bkt; (add)->hh.next = NULL; (add)->hh.key = (char*)keyptr; (add)->hh.keylen = (unsigned)keylen_in; if (!(head)) { head = (add); (head)->hh.prev = NULL; HASH_MAKE_TABLE(hh,head); } else { (head)->hh.tbl->tail->next = (add); (add)->hh.prev = ELMT_FROM_HH((head)->hh.tbl, (head)->hh.tbl->tail); (head)->hh.tbl->tail = &((add)->hh); } (head)->hh.tbl->num_items++; (add)->hh.tbl = (head)->hh.tbl; HASH_FCN(keyptr,keylen_in, (head)->hh.tbl->num_buckets, (add)->hh.hashv, _ha_bkt); HASH_ADD_TO_BKT((head)->hh.tbl->buckets[_ha_bkt],&(add)->hh); HASH_BLOOM_ADD((head)->hh.tbl,(add)->hh.hashv); HASH_EMIT_KEY(hh,head,keyptr,keylen_in); HASH_FSCK(hh,head); } while(0)
# 187 "..\\..\\AntonAvrLib/uthash/uthash.h"
#define HASH_TO_BKT(hashv,num_bkts,bkt) do { bkt = ((hashv) & ((num_bkts) - 1)); } while(0)
# 204 "..\\..\\AntonAvrLib/uthash/uthash.h"
#define HASH_DELETE(hh,head,delptr) do { unsigned _hd_bkt; struct UT_hash_handle *_hd_hh_del; if ( ((delptr)->hh.prev == NULL) && ((delptr)->hh.next == NULL) ) { uthash_free((head)->hh.tbl->buckets, (head)->hh.tbl->num_buckets*sizeof(struct UT_hash_bucket) ); HASH_BLOOM_FREE((head)->hh.tbl); uthash_free((head)->hh.tbl, sizeof(UT_hash_table)); head = NULL; } else { _hd_hh_del = &((delptr)->hh); if ((delptr) == ELMT_FROM_HH((head)->hh.tbl,(head)->hh.tbl->tail)) { (head)->hh.tbl->tail = (UT_hash_handle*)((char*)((delptr)->hh.prev) + (head)->hh.tbl->hho); } if ((delptr)->hh.prev) { ((UT_hash_handle*)((char*)((delptr)->hh.prev) + (head)->hh.tbl->hho))->next = (delptr)->hh.next; } else { DECLTYPE_ASSIGN(head,(delptr)->hh.next); } if (_hd_hh_del->next) { ((UT_hash_handle*)((char*)_hd_hh_del->next + (head)->hh.tbl->hho))->prev = _hd_hh_del->prev; } HASH_TO_BKT( _hd_hh_del->hashv, (head)->hh.tbl->num_buckets, _hd_bkt); HASH_DEL_IN_BKT(hh,(head)->hh.tbl->buckets[_hd_bkt], _hd_hh_del); (head)->hh.tbl->num_items--; } HASH_FSCK(hh,head); } while (0)
# 241 "..\\..\\AntonAvrLib/uthash/uthash.h"
#define HASH_FIND_STR(head,findstr,out) HASH_FIND(hh,head,findstr,strlen(findstr),out)

#define HASH_ADD_STR(head,strfield,add) HASH_ADD(hh,head,strfield,strlen(add->strfield),add)

#define HASH_FIND_INT(head,findint,out) HASH_FIND(hh,head,findint,sizeof(int),out)

#define HASH_ADD_INT(head,intfield,add) HASH_ADD(hh,head,intfield,sizeof(int),add)

#define HASH_FIND_PTR(head,findptr,out) HASH_FIND(hh,head,findptr,sizeof(void *),out)

#define HASH_ADD_PTR(head,ptrfield,add) HASH_ADD(hh,head,ptrfield,sizeof(void *),add)

#define HASH_DEL(head,delptr) HASH_DELETE(hh,head,delptr)
# 313 "..\\..\\AntonAvrLib/uthash/uthash.h"
#define HASH_FSCK(hh,head) 
# 327 "..\\..\\AntonAvrLib/uthash/uthash.h"
#define HASH_EMIT_KEY(hh,head,keyptr,fieldlen) 




#define HASH_FCN HASH_FUNCTION





#define HASH_BER(key,keylen,num_bkts,hashv,bkt) do { unsigned _hb_keylen=keylen; char *_hb_key=(char*)(key); (hashv) = 0; while (_hb_keylen--) { (hashv) = ((hashv) * 33) + *_hb_key++; } bkt = (hashv) & (num_bkts-1); } while (0)
# 350 "..\\..\\AntonAvrLib/uthash/uthash.h"
#define HASH_SAX(key,keylen,num_bkts,hashv,bkt) do { unsigned _sx_i; char *_hs_key=(char*)(key); hashv = 0; for(_sx_i=0; _sx_i < keylen; _sx_i++) hashv ^= (hashv << 5) + (hashv >> 2) + _hs_key[_sx_i]; bkt = hashv & (num_bkts-1); } while (0)
# 360 "..\\..\\AntonAvrLib/uthash/uthash.h"
#define HASH_FNV(key,keylen,num_bkts,hashv,bkt) do { unsigned _fn_i; char *_hf_key=(char*)(key); hashv = 2166136261UL; for(_fn_i=0; _fn_i < keylen; _fn_i++) hashv = (hashv * 16777619) ^ _hf_key[_fn_i]; bkt = hashv & (num_bkts-1); } while(0)
# 370 "..\\..\\AntonAvrLib/uthash/uthash.h"
#define HASH_OAT(key,keylen,num_bkts,hashv,bkt) do { unsigned _ho_i; char *_ho_key=(char*)(key); hashv = 0; for(_ho_i=0; _ho_i < keylen; _ho_i++) { hashv += _ho_key[_ho_i]; hashv += (hashv << 10); hashv ^= (hashv >> 6); } hashv += (hashv << 3); hashv ^= (hashv >> 11); hashv += (hashv << 15); bkt = hashv & (num_bkts-1); } while(0)
# 386 "..\\..\\AntonAvrLib/uthash/uthash.h"
#define HASH_JEN_MIX(a,b,c) do { a -= b; a -= c; a ^= ( c >> 13 ); b -= c; b -= a; b ^= ( a << 8 ); c -= a; c -= b; c ^= ( b >> 13 ); a -= b; a -= c; a ^= ( c >> 12 ); b -= c; b -= a; b ^= ( a << 16 ); c -= a; c -= b; c ^= ( b >> 5 ); a -= b; a -= c; a ^= ( c >> 3 ); b -= c; b -= a; b ^= ( a << 10 ); c -= a; c -= b; c ^= ( b >> 15 ); } while (0)
# 399 "..\\..\\AntonAvrLib/uthash/uthash.h"
#define HASH_JEN(key,keylen,num_bkts,hashv,bkt) do { unsigned _hj_i,_hj_j,_hj_k; char *_hj_key=(char*)(key); hashv = 0xfeedbeef; _hj_i = _hj_j = 0x9e3779b9; _hj_k = (unsigned)keylen; while (_hj_k >= 12) { _hj_i += (_hj_key[0] + ( (unsigned)_hj_key[1] << 8 ) + ( (unsigned)_hj_key[2] << 16 ) + ( (unsigned)_hj_key[3] << 24 ) ); _hj_j += (_hj_key[4] + ( (unsigned)_hj_key[5] << 8 ) + ( (unsigned)_hj_key[6] << 16 ) + ( (unsigned)_hj_key[7] << 24 ) ); hashv += (_hj_key[8] + ( (unsigned)_hj_key[9] << 8 ) + ( (unsigned)_hj_key[10] << 16 ) + ( (unsigned)_hj_key[11] << 24 ) ); HASH_JEN_MIX(_hj_i, _hj_j, hashv); _hj_key += 12; _hj_k -= 12; } hashv += keylen; switch ( _hj_k ) { case 11: hashv += ( (unsigned)_hj_key[10] << 24 ); case 10: hashv += ( (unsigned)_hj_key[9] << 16 ); case 9: hashv += ( (unsigned)_hj_key[8] << 8 ); case 8: _hj_j += ( (unsigned)_hj_key[7] << 24 ); case 7: _hj_j += ( (unsigned)_hj_key[6] << 16 ); case 6: _hj_j += ( (unsigned)_hj_key[5] << 8 ); case 5: _hj_j += _hj_key[4]; case 4: _hj_i += ( (unsigned)_hj_key[3] << 24 ); case 3: _hj_i += ( (unsigned)_hj_key[2] << 16 ); case 2: _hj_i += ( (unsigned)_hj_key[1] << 8 ); case 1: _hj_i += _hj_key[0]; } HASH_JEN_MIX(_hj_i, _hj_j, hashv); bkt = hashv & (num_bkts-1); } while(0)
# 441 "..\\..\\AntonAvrLib/uthash/uthash.h"
#undef get16bits






#define get16bits(d) ((((uint32_t)(((const uint8_t *)(d))[1])) << 8) +(uint32_t)(((const uint8_t *)(d))[0]) )


#define HASH_SFH(key,keylen,num_bkts,hashv,bkt) do { char *_sfh_key=(char*)(key); uint32_t _sfh_tmp, _sfh_len = keylen; int _sfh_rem = _sfh_len & 3; _sfh_len >>= 2; hashv = 0xcafebabe; for (;_sfh_len > 0; _sfh_len--) { hashv += get16bits (_sfh_key); _sfh_tmp = (get16bits (_sfh_key+2) << 11) ^ hashv; hashv = (hashv << 16) ^ _sfh_tmp; _sfh_key += 2*sizeof (uint16_t); hashv += hashv >> 11; } switch (_sfh_rem) { case 3: hashv += get16bits (_sfh_key); hashv ^= hashv << 16; hashv ^= _sfh_key[sizeof (uint16_t)] << 18; hashv += hashv >> 11; break; case 2: hashv += get16bits (_sfh_key); hashv ^= hashv << 11; hashv += hashv >> 17; break; case 1: hashv += *_sfh_key; hashv ^= hashv << 10; hashv += hashv >> 1; } hashv ^= hashv << 3; hashv += hashv >> 5; hashv ^= hashv << 4; hashv += hashv >> 17; hashv ^= hashv << 25; hashv += hashv >> 6; bkt = hashv & (num_bkts-1); } while(0)
# 575 "..\\..\\AntonAvrLib/uthash/uthash.h"
#define HASH_KEYCMP(a,b,len) memcmp(a,b,len)


#define HASH_FIND_IN_BKT(tbl,hh,head,keyptr,keylen_in,out) do { if (head.hh_head) DECLTYPE_ASSIGN(out,ELMT_FROM_HH(tbl,head.hh_head)); else out=NULL; while (out) { if ((out)->hh.keylen == keylen_in) { if ((HASH_KEYCMP((out)->hh.key,keyptr,keylen_in)) == 0) break; } if ((out)->hh.hh_next) DECLTYPE_ASSIGN(out,ELMT_FROM_HH(tbl,(out)->hh.hh_next)); else out = NULL; } } while(0)
# 592 "..\\..\\AntonAvrLib/uthash/uthash.h"
#define HASH_ADD_TO_BKT(head,addhh) do { head.count++; (addhh)->hh_next = head.hh_head; (addhh)->hh_prev = NULL; if (head.hh_head) { (head).hh_head->hh_prev = (addhh); } (head).hh_head=addhh; if (head.count >= ((head.expand_mult+1) * HASH_BKT_CAPACITY_THRESH) && (addhh)->tbl->noexpand != 1) { HASH_EXPAND_BUCKETS((addhh)->tbl); } } while(0)
# 606 "..\\..\\AntonAvrLib/uthash/uthash.h"
#define HASH_DEL_IN_BKT(hh,head,hh_del) (head).count--; if ((head).hh_head == hh_del) { (head).hh_head = hh_del->hh_next; } if (hh_del->hh_prev) { hh_del->hh_prev->hh_next = hh_del->hh_next; } if (hh_del->hh_next) { hh_del->hh_next->hh_prev = hh_del->hh_prev; }
# 647 "..\\..\\AntonAvrLib/uthash/uthash.h"
#define HASH_EXPAND_BUCKETS(tbl) do { unsigned _he_bkt; unsigned _he_bkt_i; struct UT_hash_handle *_he_thh, *_he_hh_nxt; UT_hash_bucket *_he_new_buckets, *_he_newbkt; _he_new_buckets = (UT_hash_bucket*)uthash_malloc( 2 * tbl->num_buckets * sizeof(struct UT_hash_bucket)); if (!_he_new_buckets) { uthash_fatal( "out of memory"); } memset(_he_new_buckets, 0, 2 * tbl->num_buckets * sizeof(struct UT_hash_bucket)); tbl->ideal_chain_maxlen = (tbl->num_items >> (tbl->log2_num_buckets+1)) + ((tbl->num_items & ((tbl->num_buckets*2)-1)) ? 1 : 0); tbl->nonideal_items = 0; for(_he_bkt_i = 0; _he_bkt_i < tbl->num_buckets; _he_bkt_i++) { _he_thh = tbl->buckets[ _he_bkt_i ].hh_head; while (_he_thh) { _he_hh_nxt = _he_thh->hh_next; HASH_TO_BKT( _he_thh->hashv, tbl->num_buckets*2, _he_bkt); _he_newbkt = &(_he_new_buckets[ _he_bkt ]); if (++(_he_newbkt->count) > tbl->ideal_chain_maxlen) { tbl->nonideal_items++; _he_newbkt->expand_mult = _he_newbkt->count / tbl->ideal_chain_maxlen; } _he_thh->hh_prev = NULL; _he_thh->hh_next = _he_newbkt->hh_head; if (_he_newbkt->hh_head) _he_newbkt->hh_head->hh_prev = _he_thh; _he_newbkt->hh_head = _he_thh; _he_thh = _he_hh_nxt; } } uthash_free( tbl->buckets, tbl->num_buckets*sizeof(struct UT_hash_bucket) ); tbl->num_buckets *= 2; tbl->log2_num_buckets++; tbl->buckets = _he_new_buckets; tbl->ineff_expands = (tbl->nonideal_items > (tbl->num_items >> 1)) ? (tbl->ineff_expands+1) : 0; if (tbl->ineff_expands > 1) { tbl->noexpand=1; uthash_noexpand_fyi(tbl); } uthash_expand_fyi(tbl); } while(0)
# 699 "..\\..\\AntonAvrLib/uthash/uthash.h"
#define HASH_SORT(head,cmpfcn) HASH_SRT(hh,head,cmpfcn)
#define HASH_SRT(hh,head,cmpfcn) do { unsigned _hs_i; unsigned _hs_looping,_hs_nmerges,_hs_insize,_hs_psize,_hs_qsize; struct UT_hash_handle *_hs_p, *_hs_q, *_hs_e, *_hs_list, *_hs_tail; if (head) { _hs_insize = 1; _hs_looping = 1; _hs_list = &((head)->hh); while (_hs_looping) { _hs_p = _hs_list; _hs_list = NULL; _hs_tail = NULL; _hs_nmerges = 0; while (_hs_p) { _hs_nmerges++; _hs_q = _hs_p; _hs_psize = 0; for ( _hs_i = 0; _hs_i < _hs_insize; _hs_i++ ) { _hs_psize++; _hs_q = (UT_hash_handle*)((_hs_q->next) ? ((void*)((char*)(_hs_q->next) + (head)->hh.tbl->hho)) : NULL); if (! (_hs_q) ) break; } _hs_qsize = _hs_insize; while ((_hs_psize > 0) || ((_hs_qsize > 0) && _hs_q )) { if (_hs_psize == 0) { _hs_e = _hs_q; _hs_q = (UT_hash_handle*)((_hs_q->next) ? ((void*)((char*)(_hs_q->next) + (head)->hh.tbl->hho)) : NULL); _hs_qsize--; } else if ( (_hs_qsize == 0) || !(_hs_q) ) { _hs_e = _hs_p; _hs_p = (UT_hash_handle*)((_hs_p->next) ? ((void*)((char*)(_hs_p->next) + (head)->hh.tbl->hho)) : NULL); _hs_psize--; } else if (( cmpfcn(DECLTYPE(head)(ELMT_FROM_HH((head)->hh.tbl,_hs_p)), DECLTYPE(head)(ELMT_FROM_HH((head)->hh.tbl,_hs_q))) ) <= 0) { _hs_e = _hs_p; _hs_p = (UT_hash_handle*)((_hs_p->next) ? ((void*)((char*)(_hs_p->next) + (head)->hh.tbl->hho)) : NULL); _hs_psize--; } else { _hs_e = _hs_q; _hs_q = (UT_hash_handle*)((_hs_q->next) ? ((void*)((char*)(_hs_q->next) + (head)->hh.tbl->hho)) : NULL); _hs_qsize--; } if ( _hs_tail ) { _hs_tail->next = ((_hs_e) ? ELMT_FROM_HH((head)->hh.tbl,_hs_e) : NULL); } else { _hs_list = _hs_e; } _hs_e->prev = ((_hs_tail) ? ELMT_FROM_HH((head)->hh.tbl,_hs_tail) : NULL); _hs_tail = _hs_e; } _hs_p = _hs_q; } _hs_tail->next = NULL; if ( _hs_nmerges <= 1 ) { _hs_looping=0; (head)->hh.tbl->tail = _hs_tail; DECLTYPE_ASSIGN(head,ELMT_FROM_HH((head)->hh.tbl, _hs_list)); } _hs_insize *= 2; } HASH_FSCK(hh,head); } } while (0)
# 784 "..\\..\\AntonAvrLib/uthash/uthash.h"
#define HASH_SELECT(hh_dst,dst,hh_src,src,cond) do { unsigned _src_bkt, _dst_bkt; void *_last_elt=NULL, *_elt; UT_hash_handle *_src_hh, *_dst_hh, *_last_elt_hh=NULL; ptrdiff_t _dst_hho = ((char*)(&(dst)->hh_dst) - (char*)(dst)); if (src) { for(_src_bkt=0; _src_bkt < (src)->hh_src.tbl->num_buckets; _src_bkt++) { for(_src_hh = (src)->hh_src.tbl->buckets[_src_bkt].hh_head; _src_hh; _src_hh = _src_hh->hh_next) { _elt = ELMT_FROM_HH((src)->hh_src.tbl, _src_hh); if (cond(_elt)) { _dst_hh = (UT_hash_handle*)(((char*)_elt) + _dst_hho); _dst_hh->key = _src_hh->key; _dst_hh->keylen = _src_hh->keylen; _dst_hh->hashv = _src_hh->hashv; _dst_hh->prev = _last_elt; _dst_hh->next = NULL; if (_last_elt_hh) { _last_elt_hh->next = _elt; } if (!dst) { DECLTYPE_ASSIGN(dst,_elt); HASH_MAKE_TABLE(hh_dst,dst); } else { _dst_hh->tbl = (dst)->hh_dst.tbl; } HASH_TO_BKT(_dst_hh->hashv, _dst_hh->tbl->num_buckets, _dst_bkt); HASH_ADD_TO_BKT(_dst_hh->tbl->buckets[_dst_bkt],_dst_hh); (dst)->hh_dst.tbl->num_items++; _last_elt = _elt; _last_elt_hh = _dst_hh; } } } } HASH_FSCK(hh_dst,dst); } while (0)
# 822 "..\\..\\AntonAvrLib/uthash/uthash.h"
#define HASH_CLEAR(hh,head) do { if (head) { uthash_free((head)->hh.tbl->buckets, (head)->hh.tbl->num_buckets*sizeof(struct UT_hash_bucket)); HASH_BLOOM_FREE((head)->hh.tbl); uthash_free((head)->hh.tbl, sizeof(UT_hash_table)); (head)=NULL; } } while(0)
# 838 "..\\..\\AntonAvrLib/uthash/uthash.h"
#define HASH_ITER(hh,head,el,tmp) for((el)=(head),(tmp)=DECLTYPE(el)((head)?(head)->hh.next:NULL); el; (el)=(tmp),(tmp)=DECLTYPE(el)((tmp)?(tmp)->hh.next:NULL))





#define HASH_COUNT(head) HASH_CNT(hh,head)
#define HASH_CNT(hh,head) ((head)?((head)->hh.tbl->num_items):0)

typedef struct UT_hash_bucket {
   struct UT_hash_handle *hh_head;
   unsigned count;
# 863 "..\\..\\AntonAvrLib/uthash/uthash.h"
   unsigned expand_mult;

} UT_hash_bucket;


#define HASH_SIGNATURE 0xa0111fe1
#define HASH_BLOOM_SIGNATURE 0xb12220f2

typedef struct UT_hash_table {
   UT_hash_bucket *buckets;
   unsigned num_buckets, log2_num_buckets;
   unsigned num_items;
   struct UT_hash_handle *tail;
   ptrdiff_t hho;



   unsigned ideal_chain_maxlen;




   unsigned nonideal_items;







   unsigned ineff_expands, noexpand;

   uint32_t signature;






} UT_hash_table;

typedef struct UT_hash_handle {
   struct UT_hash_table *tbl;
   void *prev;
   void *next;
   struct UT_hash_handle *hh_prev;
   struct UT_hash_handle *hh_next;
   void *key;
   unsigned keylen;
   unsigned hashv;
} UT_hash_handle;
# 9 "..\\..\\AntonAvrLib/kernel/TWI/twi_rpc_hash_server.kernel.h" 2



typedef void TwiRpcFunction(TWIBuffer *buffer);

typedef struct {
 byte operation;
 TwiRpcFunction *associatedFunction;
 UT_hash_handle hh;
} TwiFunction, *PTwiFunction;


PTwiFunction twiRpcFunctions = ((void *)0);


void twi_handleRpcRequest(byte operation, TWIBuffer *buffer) {
 PTwiFunction result;
 do { unsigned _hf_bkt,_hf_hashv; result=((void *)0); if (twiRpcFunctions) { do { unsigned _sx_i; char *_hs_key=(char*)(&operation); _hf_hashv = 0; for(_sx_i=0; _sx_i < sizeof(int); _sx_i++) _hf_hashv ^= (_hf_hashv << 5) + (_hf_hashv >> 2) + _hs_key[_sx_i]; _hf_bkt = _hf_hashv & ((twiRpcFunctions)->hh.tbl->num_buckets-1); } while (0); if ((1)) { do { if ((twiRpcFunctions)->hh.tbl->buckets[ _hf_bkt ].hh_head) do { (result) = (__typeof(result))(((void*)(((char*)((twiRpcFunctions)->hh.tbl->buckets[ _hf_bkt ].hh_head)) - (((twiRpcFunctions)->hh.tbl)->hho)))); } while(0); else result=((void *)0); while (result) { if ((result)->hh.keylen == sizeof(int)) { if ((memcmp((result)->hh.key,&operation,sizeof(int))) == 0) break; } if ((result)->hh.hh_next) do { (result) = (__typeof(result))(((void*)(((char*)((result)->hh.hh_next)) - (((twiRpcFunctions)->hh.tbl)->hho)))); } while(0); else result = ((void *)0); } } while(0); } } } while (0);
 if (result)
  result->associatedFunction(buffer);
 else


  buffer->size = 0;
}



#define TWI_RPC_SERVER_FUNCTION_BASE(funcName,operationByte) TwiFunction funcName ##_function = { operationByte, funcName ##_handler, {0} }; void funcName ##_register_function() { HASH_ADD_INT(twiRpcFunctions, operation, &funcName ##_function); } KERNEL_INIT(funcName ##_register_function)
# 49 "..\\..\\AntonAvrLib/kernel/TWI/twi_rpc_hash_server.kernel.h"
#define TWI_RPC_SERVER_FUNCTION(funcName,operationByte,ArgStruct,ResultStruct) void funcName ##_handler(TWIBuffer *buffer) { ArgStruct *args = (ArgStruct*) buffer->data; funcName(args, buffer->size, buffer); } TWI_RPC_SERVER_FUNCTION_BASE(funcName, operationByte)







#define TWI_RPC_SERVER_FUNCTION_VOID(funcName,operationByte,ArgStruct) void funcName ##_handler(TWIBuffer *buffer) { funcName((ArgStruct*) buffer->data, buffer->size); buffer->size = 0; } TWI_RPC_SERVER_FUNCTION_BASE(funcName, operationByte)







#define TWI_RPC_SERVER_FUNCTION_NOARGS(funcName,operationByte,ResultStruct) void funcName ##_handler(TWIBuffer *buffer) { funcName(buffer); } TWI_RPC_SERVER_FUNCTION_BASE(funcName, operationByte)






#define TWI_RPC_SERVER_FUNCTION_NOTIFY(funcName,operationByte) void funcName ##_handler(TWIBuffer *buffer) { funcName(); buffer->size = 0; } TWI_RPC_SERVER_FUNCTION_BASE(funcName, operationByte)







#define TWI_RPC_SERVER_FUNCTION_ASYNC_VOID(a,b,c) TWI_RPC_SERVER_FUNCTION_VOID(a, b, c)
#define TWI_RPC_SERVER_FUNCTION_ASYNC_NOTIFY(a,b) TWI_RPC_SERVER_FUNCTION_NOTIFY(a, b)






#define FILL_RESULT(resultBuffer,result,ResultType) *(ResultType*) resultBuffer->data = result; resultBuffer->size = sizeof(ResultType);




#define FILL_VAR_RESULT(resultBuffer,result,size) memcpy(resultBuffer->data, result, size); resultBuffer->size = size;
# 23 ".././tank_IO_server.kernel.h" 2


byte initialized = 0;

void tankIO_system_initialized() {
 initialized = 214;
}





void tankIO_server_reset() {
 initialized = FALSE;
 HARDWARE_RESET();
}

void tankIO_server_reset_handler(TWIBuffer *buffer) { tankIO_server_reset(); buffer->size = 0; } TwiFunction tankIO_server_reset_function = { TANK_IO_reset, tankIO_server_reset_handler, {0} }; void tankIO_server_reset_register_function() { do { unsigned _ha_bkt; (&tankIO_server_reset_function)->hh.next = ((void *)0); (&tankIO_server_reset_function)->hh.key = (char*)&((&tankIO_server_reset_function)->operation); (&tankIO_server_reset_function)->hh.keylen = (unsigned)sizeof(int); if (!(twiRpcFunctions)) { twiRpcFunctions = (&tankIO_server_reset_function); (twiRpcFunctions)->hh.prev = ((void *)0); do { (twiRpcFunctions)->hh.tbl = (UT_hash_table*)malloc(sizeof(UT_hash_table)); if (!((twiRpcFunctions)->hh.tbl)) { exit(-1); } memset((twiRpcFunctions)->hh.tbl, 0, sizeof(UT_hash_table)); (twiRpcFunctions)->hh.tbl->tail = &((twiRpcFunctions)->hh); (twiRpcFunctions)->hh.tbl->num_buckets = 32; (twiRpcFunctions)->hh.tbl->log2_num_buckets = 5; (twiRpcFunctions)->hh.tbl->hho = (char*)(&(twiRpcFunctions)->hh) - (char*)(twiRpcFunctions); (twiRpcFunctions)->hh.tbl->buckets = (UT_hash_bucket*)malloc(32*sizeof(struct UT_hash_bucket)); if (! (twiRpcFunctions)->hh.tbl->buckets) { exit(-1); } memset((twiRpcFunctions)->hh.tbl->buckets, 0, 32*sizeof(struct UT_hash_bucket)); ; (twiRpcFunctions)->hh.tbl->signature = 0xa0111fe1; } while(0); } else { (twiRpcFunctions)->hh.tbl->tail->next = (&tankIO_server_reset_function); (&tankIO_server_reset_function)->hh.prev = ((void*)(((char*)((twiRpcFunctions)->hh.tbl->tail)) - (((twiRpcFunctions)->hh.tbl)->hho))); (twiRpcFunctions)->hh.tbl->tail = &((&tankIO_server_reset_function)->hh); } (twiRpcFunctions)->hh.tbl->num_items++; (&tankIO_server_reset_function)->hh.tbl = (twiRpcFunctions)->hh.tbl; do { unsigned _sx_i; char *_hs_key=(char*)(&((&tankIO_server_reset_function)->operation)); (&tankIO_server_reset_function)->hh.hashv = 0; for(_sx_i=0; _sx_i < sizeof(int); _sx_i++) (&tankIO_server_reset_function)->hh.hashv ^= ((&tankIO_server_reset_function)->hh.hashv << 5) + ((&tankIO_server_reset_function)->hh.hashv >> 2) + _hs_key[_sx_i]; _ha_bkt = (&tankIO_server_reset_function)->hh.hashv & ((twiRpcFunctions)->hh.tbl->num_buckets-1); } while (0); do { (twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].count++; (&(&tankIO_server_reset_function)->hh)->hh_next = (twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].hh_head; (&(&tankIO_server_reset_function)->hh)->hh_prev = ((void *)0); if ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].hh_head) { ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt]).hh_head->hh_prev = (&(&tankIO_server_reset_function)->hh); } ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt]).hh_head=&(&tankIO_server_reset_function)->hh; if ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].count >= (((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].expand_mult+1) * 10) && (&(&tankIO_server_reset_function)->hh)->tbl->noexpand != 1) { do { unsigned _he_bkt; unsigned _he_bkt_i; struct UT_hash_handle *_he_thh, *_he_hh_nxt; UT_hash_bucket *_he_new_buckets, *_he_newbkt; _he_new_buckets = (UT_hash_bucket*)malloc(2 * (&(&tankIO_server_reset_function)->hh)->tbl->num_buckets * sizeof(struct UT_hash_bucket)); if (!_he_new_buckets) { exit(-1); } memset(_he_new_buckets, 0, 2 * (&(&tankIO_server_reset_function)->hh)->tbl->num_buckets * sizeof(struct UT_hash_bucket)); (&(&tankIO_server_reset_function)->hh)->tbl->ideal_chain_maxlen = ((&(&tankIO_server_reset_function)->hh)->tbl->num_items >> ((&(&tankIO_server_reset_function)->hh)->tbl->log2_num_buckets+1)) + (((&(&tankIO_server_reset_function)->hh)->tbl->num_items & (((&(&tankIO_server_reset_function)->hh)->tbl->num_buckets*2)-1)) ? 1 : 0); (&(&tankIO_server_reset_function)->hh)->tbl->nonideal_items = 0; for(_he_bkt_i = 0; _he_bkt_i < (&(&tankIO_server_reset_function)->hh)->tbl->num_buckets; _he_bkt_i++) { _he_thh = (&(&tankIO_server_reset_function)->hh)->tbl->buckets[ _he_bkt_i ].hh_head; while (_he_thh) { _he_hh_nxt = _he_thh->hh_next; do { _he_bkt = ((_he_thh->hashv) & (((&(&tankIO_server_reset_function)->hh)->tbl->num_buckets*2) - 1)); } while(0); _he_newbkt = &(_he_new_buckets[ _he_bkt ]); if (++(_he_newbkt->count) > (&(&tankIO_server_reset_function)->hh)->tbl->ideal_chain_maxlen) { (&(&tankIO_server_reset_function)->hh)->tbl->nonideal_items++; _he_newbkt->expand_mult = _he_newbkt->count / (&(&tankIO_server_reset_function)->hh)->tbl->ideal_chain_maxlen; } _he_thh->hh_prev = ((void *)0); _he_thh->hh_next = _he_newbkt->hh_head; if (_he_newbkt->hh_head) _he_newbkt->hh_head->hh_prev = _he_thh; _he_newbkt->hh_head = _he_thh; _he_thh = _he_hh_nxt; } } free((&(&tankIO_server_reset_function)->hh)->tbl->buckets); (&(&tankIO_server_reset_function)->hh)->tbl->num_buckets *= 2; (&(&tankIO_server_reset_function)->hh)->tbl->log2_num_buckets++; (&(&tankIO_server_reset_function)->hh)->tbl->buckets = _he_new_buckets; (&(&tankIO_server_reset_function)->hh)->tbl->ineff_expands = ((&(&tankIO_server_reset_function)->hh)->tbl->nonideal_items > ((&(&tankIO_server_reset_function)->hh)->tbl->num_items >> 1)) ? ((&(&tankIO_server_reset_function)->hh)->tbl->ineff_expands+1) : 0; if ((&(&tankIO_server_reset_function)->hh)->tbl->ineff_expands > 1) { (&(&tankIO_server_reset_function)->hh)->tbl->noexpand=1; ; } ; } while(0); } } while(0); ; ; ; } while(0); } void tankIO_server_reset_register_function_kernel_init() __attribute__((naked, section(".init8"))); void tankIO_server_reset_register_function_kernel_init() { tankIO_server_reset_register_function(); }

void TANKIO_server_isInitialized(TWIBuffer *result) {
 *(BOOL*) result->data = initialized; result->size = sizeof(BOOL);
}
void TANKIO_server_isInitialized_handler(TWIBuffer *buffer) { TANKIO_server_isInitialized(buffer); } TwiFunction TANKIO_server_isInitialized_function = { TANK_IO_isInitialized, TANKIO_server_isInitialized_handler, {0} }; void TANKIO_server_isInitialized_register_function() { do { unsigned _ha_bkt; (&TANKIO_server_isInitialized_function)->hh.next = ((void *)0); (&TANKIO_server_isInitialized_function)->hh.key = (char*)&((&TANKIO_server_isInitialized_function)->operation); (&TANKIO_server_isInitialized_function)->hh.keylen = (unsigned)sizeof(int); if (!(twiRpcFunctions)) { twiRpcFunctions = (&TANKIO_server_isInitialized_function); (twiRpcFunctions)->hh.prev = ((void *)0); do { (twiRpcFunctions)->hh.tbl = (UT_hash_table*)malloc(sizeof(UT_hash_table)); if (!((twiRpcFunctions)->hh.tbl)) { exit(-1); } memset((twiRpcFunctions)->hh.tbl, 0, sizeof(UT_hash_table)); (twiRpcFunctions)->hh.tbl->tail = &((twiRpcFunctions)->hh); (twiRpcFunctions)->hh.tbl->num_buckets = 32; (twiRpcFunctions)->hh.tbl->log2_num_buckets = 5; (twiRpcFunctions)->hh.tbl->hho = (char*)(&(twiRpcFunctions)->hh) - (char*)(twiRpcFunctions); (twiRpcFunctions)->hh.tbl->buckets = (UT_hash_bucket*)malloc(32*sizeof(struct UT_hash_bucket)); if (! (twiRpcFunctions)->hh.tbl->buckets) { exit(-1); } memset((twiRpcFunctions)->hh.tbl->buckets, 0, 32*sizeof(struct UT_hash_bucket)); ; (twiRpcFunctions)->hh.tbl->signature = 0xa0111fe1; } while(0); } else { (twiRpcFunctions)->hh.tbl->tail->next = (&TANKIO_server_isInitialized_function); (&TANKIO_server_isInitialized_function)->hh.prev = ((void*)(((char*)((twiRpcFunctions)->hh.tbl->tail)) - (((twiRpcFunctions)->hh.tbl)->hho))); (twiRpcFunctions)->hh.tbl->tail = &((&TANKIO_server_isInitialized_function)->hh); } (twiRpcFunctions)->hh.tbl->num_items++; (&TANKIO_server_isInitialized_function)->hh.tbl = (twiRpcFunctions)->hh.tbl; do { unsigned _sx_i; char *_hs_key=(char*)(&((&TANKIO_server_isInitialized_function)->operation)); (&TANKIO_server_isInitialized_function)->hh.hashv = 0; for(_sx_i=0; _sx_i < sizeof(int); _sx_i++) (&TANKIO_server_isInitialized_function)->hh.hashv ^= ((&TANKIO_server_isInitialized_function)->hh.hashv << 5) + ((&TANKIO_server_isInitialized_function)->hh.hashv >> 2) + _hs_key[_sx_i]; _ha_bkt = (&TANKIO_server_isInitialized_function)->hh.hashv & ((twiRpcFunctions)->hh.tbl->num_buckets-1); } while (0); do { (twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].count++; (&(&TANKIO_server_isInitialized_function)->hh)->hh_next = (twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].hh_head; (&(&TANKIO_server_isInitialized_function)->hh)->hh_prev = ((void *)0); if ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].hh_head) { ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt]).hh_head->hh_prev = (&(&TANKIO_server_isInitialized_function)->hh); } ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt]).hh_head=&(&TANKIO_server_isInitialized_function)->hh; if ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].count >= (((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].expand_mult+1) * 10) && (&(&TANKIO_server_isInitialized_function)->hh)->tbl->noexpand != 1) { do { unsigned _he_bkt; unsigned _he_bkt_i; struct UT_hash_handle *_he_thh, *_he_hh_nxt; UT_hash_bucket *_he_new_buckets, *_he_newbkt; _he_new_buckets = (UT_hash_bucket*)malloc(2 * (&(&TANKIO_server_isInitialized_function)->hh)->tbl->num_buckets * sizeof(struct UT_hash_bucket)); if (!_he_new_buckets) { exit(-1); } memset(_he_new_buckets, 0, 2 * (&(&TANKIO_server_isInitialized_function)->hh)->tbl->num_buckets * sizeof(struct UT_hash_bucket)); (&(&TANKIO_server_isInitialized_function)->hh)->tbl->ideal_chain_maxlen = ((&(&TANKIO_server_isInitialized_function)->hh)->tbl->num_items >> ((&(&TANKIO_server_isInitialized_function)->hh)->tbl->log2_num_buckets+1)) + (((&(&TANKIO_server_isInitialized_function)->hh)->tbl->num_items & (((&(&TANKIO_server_isInitialized_function)->hh)->tbl->num_buckets*2)-1)) ? 1 : 0); (&(&TANKIO_server_isInitialized_function)->hh)->tbl->nonideal_items = 0; for(_he_bkt_i = 0; _he_bkt_i < (&(&TANKIO_server_isInitialized_function)->hh)->tbl->num_buckets; _he_bkt_i++) { _he_thh = (&(&TANKIO_server_isInitialized_function)->hh)->tbl->buckets[ _he_bkt_i ].hh_head; while (_he_thh) { _he_hh_nxt = _he_thh->hh_next; do { _he_bkt = ((_he_thh->hashv) & (((&(&TANKIO_server_isInitialized_function)->hh)->tbl->num_buckets*2) - 1)); } while(0); _he_newbkt = &(_he_new_buckets[ _he_bkt ]); if (++(_he_newbkt->count) > (&(&TANKIO_server_isInitialized_function)->hh)->tbl->ideal_chain_maxlen) { (&(&TANKIO_server_isInitialized_function)->hh)->tbl->nonideal_items++; _he_newbkt->expand_mult = _he_newbkt->count / (&(&TANKIO_server_isInitialized_function)->hh)->tbl->ideal_chain_maxlen; } _he_thh->hh_prev = ((void *)0); _he_thh->hh_next = _he_newbkt->hh_head; if (_he_newbkt->hh_head) _he_newbkt->hh_head->hh_prev = _he_thh; _he_newbkt->hh_head = _he_thh; _he_thh = _he_hh_nxt; } } free((&(&TANKIO_server_isInitialized_function)->hh)->tbl->buckets); (&(&TANKIO_server_isInitialized_function)->hh)->tbl->num_buckets *= 2; (&(&TANKIO_server_isInitialized_function)->hh)->tbl->log2_num_buckets++; (&(&TANKIO_server_isInitialized_function)->hh)->tbl->buckets = _he_new_buckets; (&(&TANKIO_server_isInitialized_function)->hh)->tbl->ineff_expands = ((&(&TANKIO_server_isInitialized_function)->hh)->tbl->nonideal_items > ((&(&TANKIO_server_isInitialized_function)->hh)->tbl->num_items >> 1)) ? ((&(&TANKIO_server_isInitialized_function)->hh)->tbl->ineff_expands+1) : 0; if ((&(&TANKIO_server_isInitialized_function)->hh)->tbl->ineff_expands > 1) { (&(&TANKIO_server_isInitialized_function)->hh)->tbl->noexpand=1; ; } ; } while(0); } } while(0); ; ; ; } while(0); } void TANKIO_server_isInitialized_register_function_kernel_init() __attribute__((naked, section(".init8"))); void TANKIO_server_isInitialized_register_function_kernel_init() { TANKIO_server_isInitialized_register_function(); }





void tankIO_server_buttonStatus(TWIBuffer *result) {
 uint8_t buttons = buttonStatusMask();
 *(uint8_t*) result->data = buttons; result->size = sizeof(uint8_t);
}
void tankIO_server_buttonStatus_handler(TWIBuffer *buffer) { tankIO_server_buttonStatus(buffer); } TwiFunction tankIO_server_buttonStatus_function = { TANK_IO_buttonStatus, tankIO_server_buttonStatus_handler, {0} }; void tankIO_server_buttonStatus_register_function() { do { unsigned _ha_bkt; (&tankIO_server_buttonStatus_function)->hh.next = ((void *)0); (&tankIO_server_buttonStatus_function)->hh.key = (char*)&((&tankIO_server_buttonStatus_function)->operation); (&tankIO_server_buttonStatus_function)->hh.keylen = (unsigned)sizeof(int); if (!(twiRpcFunctions)) { twiRpcFunctions = (&tankIO_server_buttonStatus_function); (twiRpcFunctions)->hh.prev = ((void *)0); do { (twiRpcFunctions)->hh.tbl = (UT_hash_table*)malloc(sizeof(UT_hash_table)); if (!((twiRpcFunctions)->hh.tbl)) { exit(-1); } memset((twiRpcFunctions)->hh.tbl, 0, sizeof(UT_hash_table)); (twiRpcFunctions)->hh.tbl->tail = &((twiRpcFunctions)->hh); (twiRpcFunctions)->hh.tbl->num_buckets = 32; (twiRpcFunctions)->hh.tbl->log2_num_buckets = 5; (twiRpcFunctions)->hh.tbl->hho = (char*)(&(twiRpcFunctions)->hh) - (char*)(twiRpcFunctions); (twiRpcFunctions)->hh.tbl->buckets = (UT_hash_bucket*)malloc(32*sizeof(struct UT_hash_bucket)); if (! (twiRpcFunctions)->hh.tbl->buckets) { exit(-1); } memset((twiRpcFunctions)->hh.tbl->buckets, 0, 32*sizeof(struct UT_hash_bucket)); ; (twiRpcFunctions)->hh.tbl->signature = 0xa0111fe1; } while(0); } else { (twiRpcFunctions)->hh.tbl->tail->next = (&tankIO_server_buttonStatus_function); (&tankIO_server_buttonStatus_function)->hh.prev = ((void*)(((char*)((twiRpcFunctions)->hh.tbl->tail)) - (((twiRpcFunctions)->hh.tbl)->hho))); (twiRpcFunctions)->hh.tbl->tail = &((&tankIO_server_buttonStatus_function)->hh); } (twiRpcFunctions)->hh.tbl->num_items++; (&tankIO_server_buttonStatus_function)->hh.tbl = (twiRpcFunctions)->hh.tbl; do { unsigned _sx_i; char *_hs_key=(char*)(&((&tankIO_server_buttonStatus_function)->operation)); (&tankIO_server_buttonStatus_function)->hh.hashv = 0; for(_sx_i=0; _sx_i < sizeof(int); _sx_i++) (&tankIO_server_buttonStatus_function)->hh.hashv ^= ((&tankIO_server_buttonStatus_function)->hh.hashv << 5) + ((&tankIO_server_buttonStatus_function)->hh.hashv >> 2) + _hs_key[_sx_i]; _ha_bkt = (&tankIO_server_buttonStatus_function)->hh.hashv & ((twiRpcFunctions)->hh.tbl->num_buckets-1); } while (0); do { (twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].count++; (&(&tankIO_server_buttonStatus_function)->hh)->hh_next = (twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].hh_head; (&(&tankIO_server_buttonStatus_function)->hh)->hh_prev = ((void *)0); if ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].hh_head) { ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt]).hh_head->hh_prev = (&(&tankIO_server_buttonStatus_function)->hh); } ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt]).hh_head=&(&tankIO_server_buttonStatus_function)->hh; if ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].count >= (((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].expand_mult+1) * 10) && (&(&tankIO_server_buttonStatus_function)->hh)->tbl->noexpand != 1) { do { unsigned _he_bkt; unsigned _he_bkt_i; struct UT_hash_handle *_he_thh, *_he_hh_nxt; UT_hash_bucket *_he_new_buckets, *_he_newbkt; _he_new_buckets = (UT_hash_bucket*)malloc(2 * (&(&tankIO_server_buttonStatus_function)->hh)->tbl->num_buckets * sizeof(struct UT_hash_bucket)); if (!_he_new_buckets) { exit(-1); } memset(_he_new_buckets, 0, 2 * (&(&tankIO_server_buttonStatus_function)->hh)->tbl->num_buckets * sizeof(struct UT_hash_bucket)); (&(&tankIO_server_buttonStatus_function)->hh)->tbl->ideal_chain_maxlen = ((&(&tankIO_server_buttonStatus_function)->hh)->tbl->num_items >> ((&(&tankIO_server_buttonStatus_function)->hh)->tbl->log2_num_buckets+1)) + (((&(&tankIO_server_buttonStatus_function)->hh)->tbl->num_items & (((&(&tankIO_server_buttonStatus_function)->hh)->tbl->num_buckets*2)-1)) ? 1 : 0); (&(&tankIO_server_buttonStatus_function)->hh)->tbl->nonideal_items = 0; for(_he_bkt_i = 0; _he_bkt_i < (&(&tankIO_server_buttonStatus_function)->hh)->tbl->num_buckets; _he_bkt_i++) { _he_thh = (&(&tankIO_server_buttonStatus_function)->hh)->tbl->buckets[ _he_bkt_i ].hh_head; while (_he_thh) { _he_hh_nxt = _he_thh->hh_next; do { _he_bkt = ((_he_thh->hashv) & (((&(&tankIO_server_buttonStatus_function)->hh)->tbl->num_buckets*2) - 1)); } while(0); _he_newbkt = &(_he_new_buckets[ _he_bkt ]); if (++(_he_newbkt->count) > (&(&tankIO_server_buttonStatus_function)->hh)->tbl->ideal_chain_maxlen) { (&(&tankIO_server_buttonStatus_function)->hh)->tbl->nonideal_items++; _he_newbkt->expand_mult = _he_newbkt->count / (&(&tankIO_server_buttonStatus_function)->hh)->tbl->ideal_chain_maxlen; } _he_thh->hh_prev = ((void *)0); _he_thh->hh_next = _he_newbkt->hh_head; if (_he_newbkt->hh_head) _he_newbkt->hh_head->hh_prev = _he_thh; _he_newbkt->hh_head = _he_thh; _he_thh = _he_hh_nxt; } } free((&(&tankIO_server_buttonStatus_function)->hh)->tbl->buckets); (&(&tankIO_server_buttonStatus_function)->hh)->tbl->num_buckets *= 2; (&(&tankIO_server_buttonStatus_function)->hh)->tbl->log2_num_buckets++; (&(&tankIO_server_buttonStatus_function)->hh)->tbl->buckets = _he_new_buckets; (&(&tankIO_server_buttonStatus_function)->hh)->tbl->ineff_expands = ((&(&tankIO_server_buttonStatus_function)->hh)->tbl->nonideal_items > ((&(&tankIO_server_buttonStatus_function)->hh)->tbl->num_items >> 1)) ? ((&(&tankIO_server_buttonStatus_function)->hh)->tbl->ineff_expands+1) : 0; if ((&(&tankIO_server_buttonStatus_function)->hh)->tbl->ineff_expands > 1) { (&(&tankIO_server_buttonStatus_function)->hh)->tbl->noexpand=1; ; } ; } while(0); } } while(0); ; ; ; } while(0); } void tankIO_server_buttonStatus_register_function_kernel_init() __attribute__((naked, section(".init8"))); void tankIO_server_buttonStatus_register_function_kernel_init() { tankIO_server_buttonStatus_register_function(); }

void tankIO_server_pressedButtons(TWIBuffer *result) {
 uint8_t buttons = pressedButtons();
 *(uint8_t*) result->data = buttons; result->size = sizeof(uint8_t);
}
void tankIO_server_pressedButtons_handler(TWIBuffer *buffer) { tankIO_server_pressedButtons(buffer); } TwiFunction tankIO_server_pressedButtons_function = { TANK_IO_pressedButtons, tankIO_server_pressedButtons_handler, {0} }; void tankIO_server_pressedButtons_register_function() { do { unsigned _ha_bkt; (&tankIO_server_pressedButtons_function)->hh.next = ((void *)0); (&tankIO_server_pressedButtons_function)->hh.key = (char*)&((&tankIO_server_pressedButtons_function)->operation); (&tankIO_server_pressedButtons_function)->hh.keylen = (unsigned)sizeof(int); if (!(twiRpcFunctions)) { twiRpcFunctions = (&tankIO_server_pressedButtons_function); (twiRpcFunctions)->hh.prev = ((void *)0); do { (twiRpcFunctions)->hh.tbl = (UT_hash_table*)malloc(sizeof(UT_hash_table)); if (!((twiRpcFunctions)->hh.tbl)) { exit(-1); } memset((twiRpcFunctions)->hh.tbl, 0, sizeof(UT_hash_table)); (twiRpcFunctions)->hh.tbl->tail = &((twiRpcFunctions)->hh); (twiRpcFunctions)->hh.tbl->num_buckets = 32; (twiRpcFunctions)->hh.tbl->log2_num_buckets = 5; (twiRpcFunctions)->hh.tbl->hho = (char*)(&(twiRpcFunctions)->hh) - (char*)(twiRpcFunctions); (twiRpcFunctions)->hh.tbl->buckets = (UT_hash_bucket*)malloc(32*sizeof(struct UT_hash_bucket)); if (! (twiRpcFunctions)->hh.tbl->buckets) { exit(-1); } memset((twiRpcFunctions)->hh.tbl->buckets, 0, 32*sizeof(struct UT_hash_bucket)); ; (twiRpcFunctions)->hh.tbl->signature = 0xa0111fe1; } while(0); } else { (twiRpcFunctions)->hh.tbl->tail->next = (&tankIO_server_pressedButtons_function); (&tankIO_server_pressedButtons_function)->hh.prev = ((void*)(((char*)((twiRpcFunctions)->hh.tbl->tail)) - (((twiRpcFunctions)->hh.tbl)->hho))); (twiRpcFunctions)->hh.tbl->tail = &((&tankIO_server_pressedButtons_function)->hh); } (twiRpcFunctions)->hh.tbl->num_items++; (&tankIO_server_pressedButtons_function)->hh.tbl = (twiRpcFunctions)->hh.tbl; do { unsigned _sx_i; char *_hs_key=(char*)(&((&tankIO_server_pressedButtons_function)->operation)); (&tankIO_server_pressedButtons_function)->hh.hashv = 0; for(_sx_i=0; _sx_i < sizeof(int); _sx_i++) (&tankIO_server_pressedButtons_function)->hh.hashv ^= ((&tankIO_server_pressedButtons_function)->hh.hashv << 5) + ((&tankIO_server_pressedButtons_function)->hh.hashv >> 2) + _hs_key[_sx_i]; _ha_bkt = (&tankIO_server_pressedButtons_function)->hh.hashv & ((twiRpcFunctions)->hh.tbl->num_buckets-1); } while (0); do { (twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].count++; (&(&tankIO_server_pressedButtons_function)->hh)->hh_next = (twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].hh_head; (&(&tankIO_server_pressedButtons_function)->hh)->hh_prev = ((void *)0); if ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].hh_head) { ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt]).hh_head->hh_prev = (&(&tankIO_server_pressedButtons_function)->hh); } ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt]).hh_head=&(&tankIO_server_pressedButtons_function)->hh; if ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].count >= (((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].expand_mult+1) * 10) && (&(&tankIO_server_pressedButtons_function)->hh)->tbl->noexpand != 1) { do { unsigned _he_bkt; unsigned _he_bkt_i; struct UT_hash_handle *_he_thh, *_he_hh_nxt; UT_hash_bucket *_he_new_buckets, *_he_newbkt; _he_new_buckets = (UT_hash_bucket*)malloc(2 * (&(&tankIO_server_pressedButtons_function)->hh)->tbl->num_buckets * sizeof(struct UT_hash_bucket)); if (!_he_new_buckets) { exit(-1); } memset(_he_new_buckets, 0, 2 * (&(&tankIO_server_pressedButtons_function)->hh)->tbl->num_buckets * sizeof(struct UT_hash_bucket)); (&(&tankIO_server_pressedButtons_function)->hh)->tbl->ideal_chain_maxlen = ((&(&tankIO_server_pressedButtons_function)->hh)->tbl->num_items >> ((&(&tankIO_server_pressedButtons_function)->hh)->tbl->log2_num_buckets+1)) + (((&(&tankIO_server_pressedButtons_function)->hh)->tbl->num_items & (((&(&tankIO_server_pressedButtons_function)->hh)->tbl->num_buckets*2)-1)) ? 1 : 0); (&(&tankIO_server_pressedButtons_function)->hh)->tbl->nonideal_items = 0; for(_he_bkt_i = 0; _he_bkt_i < (&(&tankIO_server_pressedButtons_function)->hh)->tbl->num_buckets; _he_bkt_i++) { _he_thh = (&(&tankIO_server_pressedButtons_function)->hh)->tbl->buckets[ _he_bkt_i ].hh_head; while (_he_thh) { _he_hh_nxt = _he_thh->hh_next; do { _he_bkt = ((_he_thh->hashv) & (((&(&tankIO_server_pressedButtons_function)->hh)->tbl->num_buckets*2) - 1)); } while(0); _he_newbkt = &(_he_new_buckets[ _he_bkt ]); if (++(_he_newbkt->count) > (&(&tankIO_server_pressedButtons_function)->hh)->tbl->ideal_chain_maxlen) { (&(&tankIO_server_pressedButtons_function)->hh)->tbl->nonideal_items++; _he_newbkt->expand_mult = _he_newbkt->count / (&(&tankIO_server_pressedButtons_function)->hh)->tbl->ideal_chain_maxlen; } _he_thh->hh_prev = ((void *)0); _he_thh->hh_next = _he_newbkt->hh_head; if (_he_newbkt->hh_head) _he_newbkt->hh_head->hh_prev = _he_thh; _he_newbkt->hh_head = _he_thh; _he_thh = _he_hh_nxt; } } free((&(&tankIO_server_pressedButtons_function)->hh)->tbl->buckets); (&(&tankIO_server_pressedButtons_function)->hh)->tbl->num_buckets *= 2; (&(&tankIO_server_pressedButtons_function)->hh)->tbl->log2_num_buckets++; (&(&tankIO_server_pressedButtons_function)->hh)->tbl->buckets = _he_new_buckets; (&(&tankIO_server_pressedButtons_function)->hh)->tbl->ineff_expands = ((&(&tankIO_server_pressedButtons_function)->hh)->tbl->nonideal_items > ((&(&tankIO_server_pressedButtons_function)->hh)->tbl->num_items >> 1)) ? ((&(&tankIO_server_pressedButtons_function)->hh)->tbl->ineff_expands+1) : 0; if ((&(&tankIO_server_pressedButtons_function)->hh)->tbl->ineff_expands > 1) { (&(&tankIO_server_pressedButtons_function)->hh)->tbl->noexpand=1; ; } ; } while(0); } } while(0); ; ; ; } while(0); } void tankIO_server_pressedButtons_register_function_kernel_init() __attribute__((naked, section(".init8"))); void tankIO_server_pressedButtons_register_function_kernel_init() { tankIO_server_pressedButtons_register_function(); }





PLedGroup toLedGroup(TankIoLeds leds) {
 switch (leds) {
  case LEDS_ALL:
   return AllLeds;
  case LEDS_LEFT:
   return WhiteLeds;
  case LEDS_RIGHT:
   return RedLeds;
  case LEDS_MIDDLE:
   return MiddleLeds;
  case LEDS_RED:
   return RedLeds;
  case LEDS_YELLOW:
   return YellowLeds;
  case LEDS_WHITE:
   return WhiteLeds;
  case LEDS_GREEN:
   return GreenLeds;
  default:
   return ((void *)0);
 }
}

PLed toLed(SingleLed led) {
 return toLedGroup(led.leds)->leds[led.index];
}





void tankIO_server_enableLed(SingleLed *led, uint16_t size) {
 enableLed(toLed(*led));
}
void tankIO_server_enableLed_handler(TWIBuffer *buffer) { tankIO_server_enableLed((SingleLed*) buffer->data, buffer->size); buffer->size = 0; } TwiFunction tankIO_server_enableLed_function = { TANK_IO_enableLed, tankIO_server_enableLed_handler, {0} }; void tankIO_server_enableLed_register_function() { do { unsigned _ha_bkt; (&tankIO_server_enableLed_function)->hh.next = ((void *)0); (&tankIO_server_enableLed_function)->hh.key = (char*)&((&tankIO_server_enableLed_function)->operation); (&tankIO_server_enableLed_function)->hh.keylen = (unsigned)sizeof(int); if (!(twiRpcFunctions)) { twiRpcFunctions = (&tankIO_server_enableLed_function); (twiRpcFunctions)->hh.prev = ((void *)0); do { (twiRpcFunctions)->hh.tbl = (UT_hash_table*)malloc(sizeof(UT_hash_table)); if (!((twiRpcFunctions)->hh.tbl)) { exit(-1); } memset((twiRpcFunctions)->hh.tbl, 0, sizeof(UT_hash_table)); (twiRpcFunctions)->hh.tbl->tail = &((twiRpcFunctions)->hh); (twiRpcFunctions)->hh.tbl->num_buckets = 32; (twiRpcFunctions)->hh.tbl->log2_num_buckets = 5; (twiRpcFunctions)->hh.tbl->hho = (char*)(&(twiRpcFunctions)->hh) - (char*)(twiRpcFunctions); (twiRpcFunctions)->hh.tbl->buckets = (UT_hash_bucket*)malloc(32*sizeof(struct UT_hash_bucket)); if (! (twiRpcFunctions)->hh.tbl->buckets) { exit(-1); } memset((twiRpcFunctions)->hh.tbl->buckets, 0, 32*sizeof(struct UT_hash_bucket)); ; (twiRpcFunctions)->hh.tbl->signature = 0xa0111fe1; } while(0); } else { (twiRpcFunctions)->hh.tbl->tail->next = (&tankIO_server_enableLed_function); (&tankIO_server_enableLed_function)->hh.prev = ((void*)(((char*)((twiRpcFunctions)->hh.tbl->tail)) - (((twiRpcFunctions)->hh.tbl)->hho))); (twiRpcFunctions)->hh.tbl->tail = &((&tankIO_server_enableLed_function)->hh); } (twiRpcFunctions)->hh.tbl->num_items++; (&tankIO_server_enableLed_function)->hh.tbl = (twiRpcFunctions)->hh.tbl; do { unsigned _sx_i; char *_hs_key=(char*)(&((&tankIO_server_enableLed_function)->operation)); (&tankIO_server_enableLed_function)->hh.hashv = 0; for(_sx_i=0; _sx_i < sizeof(int); _sx_i++) (&tankIO_server_enableLed_function)->hh.hashv ^= ((&tankIO_server_enableLed_function)->hh.hashv << 5) + ((&tankIO_server_enableLed_function)->hh.hashv >> 2) + _hs_key[_sx_i]; _ha_bkt = (&tankIO_server_enableLed_function)->hh.hashv & ((twiRpcFunctions)->hh.tbl->num_buckets-1); } while (0); do { (twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].count++; (&(&tankIO_server_enableLed_function)->hh)->hh_next = (twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].hh_head; (&(&tankIO_server_enableLed_function)->hh)->hh_prev = ((void *)0); if ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].hh_head) { ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt]).hh_head->hh_prev = (&(&tankIO_server_enableLed_function)->hh); } ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt]).hh_head=&(&tankIO_server_enableLed_function)->hh; if ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].count >= (((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].expand_mult+1) * 10) && (&(&tankIO_server_enableLed_function)->hh)->tbl->noexpand != 1) { do { unsigned _he_bkt; unsigned _he_bkt_i; struct UT_hash_handle *_he_thh, *_he_hh_nxt; UT_hash_bucket *_he_new_buckets, *_he_newbkt; _he_new_buckets = (UT_hash_bucket*)malloc(2 * (&(&tankIO_server_enableLed_function)->hh)->tbl->num_buckets * sizeof(struct UT_hash_bucket)); if (!_he_new_buckets) { exit(-1); } memset(_he_new_buckets, 0, 2 * (&(&tankIO_server_enableLed_function)->hh)->tbl->num_buckets * sizeof(struct UT_hash_bucket)); (&(&tankIO_server_enableLed_function)->hh)->tbl->ideal_chain_maxlen = ((&(&tankIO_server_enableLed_function)->hh)->tbl->num_items >> ((&(&tankIO_server_enableLed_function)->hh)->tbl->log2_num_buckets+1)) + (((&(&tankIO_server_enableLed_function)->hh)->tbl->num_items & (((&(&tankIO_server_enableLed_function)->hh)->tbl->num_buckets*2)-1)) ? 1 : 0); (&(&tankIO_server_enableLed_function)->hh)->tbl->nonideal_items = 0; for(_he_bkt_i = 0; _he_bkt_i < (&(&tankIO_server_enableLed_function)->hh)->tbl->num_buckets; _he_bkt_i++) { _he_thh = (&(&tankIO_server_enableLed_function)->hh)->tbl->buckets[ _he_bkt_i ].hh_head; while (_he_thh) { _he_hh_nxt = _he_thh->hh_next; do { _he_bkt = ((_he_thh->hashv) & (((&(&tankIO_server_enableLed_function)->hh)->tbl->num_buckets*2) - 1)); } while(0); _he_newbkt = &(_he_new_buckets[ _he_bkt ]); if (++(_he_newbkt->count) > (&(&tankIO_server_enableLed_function)->hh)->tbl->ideal_chain_maxlen) { (&(&tankIO_server_enableLed_function)->hh)->tbl->nonideal_items++; _he_newbkt->expand_mult = _he_newbkt->count / (&(&tankIO_server_enableLed_function)->hh)->tbl->ideal_chain_maxlen; } _he_thh->hh_prev = ((void *)0); _he_thh->hh_next = _he_newbkt->hh_head; if (_he_newbkt->hh_head) _he_newbkt->hh_head->hh_prev = _he_thh; _he_newbkt->hh_head = _he_thh; _he_thh = _he_hh_nxt; } } free((&(&tankIO_server_enableLed_function)->hh)->tbl->buckets); (&(&tankIO_server_enableLed_function)->hh)->tbl->num_buckets *= 2; (&(&tankIO_server_enableLed_function)->hh)->tbl->log2_num_buckets++; (&(&tankIO_server_enableLed_function)->hh)->tbl->buckets = _he_new_buckets; (&(&tankIO_server_enableLed_function)->hh)->tbl->ineff_expands = ((&(&tankIO_server_enableLed_function)->hh)->tbl->nonideal_items > ((&(&tankIO_server_enableLed_function)->hh)->tbl->num_items >> 1)) ? ((&(&tankIO_server_enableLed_function)->hh)->tbl->ineff_expands+1) : 0; if ((&(&tankIO_server_enableLed_function)->hh)->tbl->ineff_expands > 1) { (&(&tankIO_server_enableLed_function)->hh)->tbl->noexpand=1; ; } ; } while(0); } } while(0); ; ; ; } while(0); } void tankIO_server_enableLed_register_function_kernel_init() __attribute__((naked, section(".init8"))); void tankIO_server_enableLed_register_function_kernel_init() { tankIO_server_enableLed_register_function(); }

void tankIO_server_disableLed(SingleLed *led, uint16_t size) {
 disableLed(toLed(*led));
}
void tankIO_server_disableLed_handler(TWIBuffer *buffer) { tankIO_server_disableLed((SingleLed*) buffer->data, buffer->size); buffer->size = 0; } TwiFunction tankIO_server_disableLed_function = { TANK_IO_disableLed, tankIO_server_disableLed_handler, {0} }; void tankIO_server_disableLed_register_function() { do { unsigned _ha_bkt; (&tankIO_server_disableLed_function)->hh.next = ((void *)0); (&tankIO_server_disableLed_function)->hh.key = (char*)&((&tankIO_server_disableLed_function)->operation); (&tankIO_server_disableLed_function)->hh.keylen = (unsigned)sizeof(int); if (!(twiRpcFunctions)) { twiRpcFunctions = (&tankIO_server_disableLed_function); (twiRpcFunctions)->hh.prev = ((void *)0); do { (twiRpcFunctions)->hh.tbl = (UT_hash_table*)malloc(sizeof(UT_hash_table)); if (!((twiRpcFunctions)->hh.tbl)) { exit(-1); } memset((twiRpcFunctions)->hh.tbl, 0, sizeof(UT_hash_table)); (twiRpcFunctions)->hh.tbl->tail = &((twiRpcFunctions)->hh); (twiRpcFunctions)->hh.tbl->num_buckets = 32; (twiRpcFunctions)->hh.tbl->log2_num_buckets = 5; (twiRpcFunctions)->hh.tbl->hho = (char*)(&(twiRpcFunctions)->hh) - (char*)(twiRpcFunctions); (twiRpcFunctions)->hh.tbl->buckets = (UT_hash_bucket*)malloc(32*sizeof(struct UT_hash_bucket)); if (! (twiRpcFunctions)->hh.tbl->buckets) { exit(-1); } memset((twiRpcFunctions)->hh.tbl->buckets, 0, 32*sizeof(struct UT_hash_bucket)); ; (twiRpcFunctions)->hh.tbl->signature = 0xa0111fe1; } while(0); } else { (twiRpcFunctions)->hh.tbl->tail->next = (&tankIO_server_disableLed_function); (&tankIO_server_disableLed_function)->hh.prev = ((void*)(((char*)((twiRpcFunctions)->hh.tbl->tail)) - (((twiRpcFunctions)->hh.tbl)->hho))); (twiRpcFunctions)->hh.tbl->tail = &((&tankIO_server_disableLed_function)->hh); } (twiRpcFunctions)->hh.tbl->num_items++; (&tankIO_server_disableLed_function)->hh.tbl = (twiRpcFunctions)->hh.tbl; do { unsigned _sx_i; char *_hs_key=(char*)(&((&tankIO_server_disableLed_function)->operation)); (&tankIO_server_disableLed_function)->hh.hashv = 0; for(_sx_i=0; _sx_i < sizeof(int); _sx_i++) (&tankIO_server_disableLed_function)->hh.hashv ^= ((&tankIO_server_disableLed_function)->hh.hashv << 5) + ((&tankIO_server_disableLed_function)->hh.hashv >> 2) + _hs_key[_sx_i]; _ha_bkt = (&tankIO_server_disableLed_function)->hh.hashv & ((twiRpcFunctions)->hh.tbl->num_buckets-1); } while (0); do { (twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].count++; (&(&tankIO_server_disableLed_function)->hh)->hh_next = (twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].hh_head; (&(&tankIO_server_disableLed_function)->hh)->hh_prev = ((void *)0); if ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].hh_head) { ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt]).hh_head->hh_prev = (&(&tankIO_server_disableLed_function)->hh); } ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt]).hh_head=&(&tankIO_server_disableLed_function)->hh; if ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].count >= (((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].expand_mult+1) * 10) && (&(&tankIO_server_disableLed_function)->hh)->tbl->noexpand != 1) { do { unsigned _he_bkt; unsigned _he_bkt_i; struct UT_hash_handle *_he_thh, *_he_hh_nxt; UT_hash_bucket *_he_new_buckets, *_he_newbkt; _he_new_buckets = (UT_hash_bucket*)malloc(2 * (&(&tankIO_server_disableLed_function)->hh)->tbl->num_buckets * sizeof(struct UT_hash_bucket)); if (!_he_new_buckets) { exit(-1); } memset(_he_new_buckets, 0, 2 * (&(&tankIO_server_disableLed_function)->hh)->tbl->num_buckets * sizeof(struct UT_hash_bucket)); (&(&tankIO_server_disableLed_function)->hh)->tbl->ideal_chain_maxlen = ((&(&tankIO_server_disableLed_function)->hh)->tbl->num_items >> ((&(&tankIO_server_disableLed_function)->hh)->tbl->log2_num_buckets+1)) + (((&(&tankIO_server_disableLed_function)->hh)->tbl->num_items & (((&(&tankIO_server_disableLed_function)->hh)->tbl->num_buckets*2)-1)) ? 1 : 0); (&(&tankIO_server_disableLed_function)->hh)->tbl->nonideal_items = 0; for(_he_bkt_i = 0; _he_bkt_i < (&(&tankIO_server_disableLed_function)->hh)->tbl->num_buckets; _he_bkt_i++) { _he_thh = (&(&tankIO_server_disableLed_function)->hh)->tbl->buckets[ _he_bkt_i ].hh_head; while (_he_thh) { _he_hh_nxt = _he_thh->hh_next; do { _he_bkt = ((_he_thh->hashv) & (((&(&tankIO_server_disableLed_function)->hh)->tbl->num_buckets*2) - 1)); } while(0); _he_newbkt = &(_he_new_buckets[ _he_bkt ]); if (++(_he_newbkt->count) > (&(&tankIO_server_disableLed_function)->hh)->tbl->ideal_chain_maxlen) { (&(&tankIO_server_disableLed_function)->hh)->tbl->nonideal_items++; _he_newbkt->expand_mult = _he_newbkt->count / (&(&tankIO_server_disableLed_function)->hh)->tbl->ideal_chain_maxlen; } _he_thh->hh_prev = ((void *)0); _he_thh->hh_next = _he_newbkt->hh_head; if (_he_newbkt->hh_head) _he_newbkt->hh_head->hh_prev = _he_thh; _he_newbkt->hh_head = _he_thh; _he_thh = _he_hh_nxt; } } free((&(&tankIO_server_disableLed_function)->hh)->tbl->buckets); (&(&tankIO_server_disableLed_function)->hh)->tbl->num_buckets *= 2; (&(&tankIO_server_disableLed_function)->hh)->tbl->log2_num_buckets++; (&(&tankIO_server_disableLed_function)->hh)->tbl->buckets = _he_new_buckets; (&(&tankIO_server_disableLed_function)->hh)->tbl->ineff_expands = ((&(&tankIO_server_disableLed_function)->hh)->tbl->nonideal_items > ((&(&tankIO_server_disableLed_function)->hh)->tbl->num_items >> 1)) ? ((&(&tankIO_server_disableLed_function)->hh)->tbl->ineff_expands+1) : 0; if ((&(&tankIO_server_disableLed_function)->hh)->tbl->ineff_expands > 1) { (&(&tankIO_server_disableLed_function)->hh)->tbl->noexpand=1; ; } ; } while(0); } } while(0); ; ; ; } while(0); } void tankIO_server_disableLed_register_function_kernel_init() __attribute__((naked, section(".init8"))); void tankIO_server_disableLed_register_function_kernel_init() { tankIO_server_disableLed_register_function(); }

void tankIO_server_setLed(SetLedParam *param, uint16_t size) {
 setLed(toLed(param->led), param->value);
}
void tankIO_server_setLed_handler(TWIBuffer *buffer) { tankIO_server_setLed((SetLedParam*) buffer->data, buffer->size); buffer->size = 0; } TwiFunction tankIO_server_setLed_function = { TANK_IO_setLed, tankIO_server_setLed_handler, {0} }; void tankIO_server_setLed_register_function() { do { unsigned _ha_bkt; (&tankIO_server_setLed_function)->hh.next = ((void *)0); (&tankIO_server_setLed_function)->hh.key = (char*)&((&tankIO_server_setLed_function)->operation); (&tankIO_server_setLed_function)->hh.keylen = (unsigned)sizeof(int); if (!(twiRpcFunctions)) { twiRpcFunctions = (&tankIO_server_setLed_function); (twiRpcFunctions)->hh.prev = ((void *)0); do { (twiRpcFunctions)->hh.tbl = (UT_hash_table*)malloc(sizeof(UT_hash_table)); if (!((twiRpcFunctions)->hh.tbl)) { exit(-1); } memset((twiRpcFunctions)->hh.tbl, 0, sizeof(UT_hash_table)); (twiRpcFunctions)->hh.tbl->tail = &((twiRpcFunctions)->hh); (twiRpcFunctions)->hh.tbl->num_buckets = 32; (twiRpcFunctions)->hh.tbl->log2_num_buckets = 5; (twiRpcFunctions)->hh.tbl->hho = (char*)(&(twiRpcFunctions)->hh) - (char*)(twiRpcFunctions); (twiRpcFunctions)->hh.tbl->buckets = (UT_hash_bucket*)malloc(32*sizeof(struct UT_hash_bucket)); if (! (twiRpcFunctions)->hh.tbl->buckets) { exit(-1); } memset((twiRpcFunctions)->hh.tbl->buckets, 0, 32*sizeof(struct UT_hash_bucket)); ; (twiRpcFunctions)->hh.tbl->signature = 0xa0111fe1; } while(0); } else { (twiRpcFunctions)->hh.tbl->tail->next = (&tankIO_server_setLed_function); (&tankIO_server_setLed_function)->hh.prev = ((void*)(((char*)((twiRpcFunctions)->hh.tbl->tail)) - (((twiRpcFunctions)->hh.tbl)->hho))); (twiRpcFunctions)->hh.tbl->tail = &((&tankIO_server_setLed_function)->hh); } (twiRpcFunctions)->hh.tbl->num_items++; (&tankIO_server_setLed_function)->hh.tbl = (twiRpcFunctions)->hh.tbl; do { unsigned _sx_i; char *_hs_key=(char*)(&((&tankIO_server_setLed_function)->operation)); (&tankIO_server_setLed_function)->hh.hashv = 0; for(_sx_i=0; _sx_i < sizeof(int); _sx_i++) (&tankIO_server_setLed_function)->hh.hashv ^= ((&tankIO_server_setLed_function)->hh.hashv << 5) + ((&tankIO_server_setLed_function)->hh.hashv >> 2) + _hs_key[_sx_i]; _ha_bkt = (&tankIO_server_setLed_function)->hh.hashv & ((twiRpcFunctions)->hh.tbl->num_buckets-1); } while (0); do { (twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].count++; (&(&tankIO_server_setLed_function)->hh)->hh_next = (twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].hh_head; (&(&tankIO_server_setLed_function)->hh)->hh_prev = ((void *)0); if ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].hh_head) { ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt]).hh_head->hh_prev = (&(&tankIO_server_setLed_function)->hh); } ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt]).hh_head=&(&tankIO_server_setLed_function)->hh; if ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].count >= (((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].expand_mult+1) * 10) && (&(&tankIO_server_setLed_function)->hh)->tbl->noexpand != 1) { do { unsigned _he_bkt; unsigned _he_bkt_i; struct UT_hash_handle *_he_thh, *_he_hh_nxt; UT_hash_bucket *_he_new_buckets, *_he_newbkt; _he_new_buckets = (UT_hash_bucket*)malloc(2 * (&(&tankIO_server_setLed_function)->hh)->tbl->num_buckets * sizeof(struct UT_hash_bucket)); if (!_he_new_buckets) { exit(-1); } memset(_he_new_buckets, 0, 2 * (&(&tankIO_server_setLed_function)->hh)->tbl->num_buckets * sizeof(struct UT_hash_bucket)); (&(&tankIO_server_setLed_function)->hh)->tbl->ideal_chain_maxlen = ((&(&tankIO_server_setLed_function)->hh)->tbl->num_items >> ((&(&tankIO_server_setLed_function)->hh)->tbl->log2_num_buckets+1)) + (((&(&tankIO_server_setLed_function)->hh)->tbl->num_items & (((&(&tankIO_server_setLed_function)->hh)->tbl->num_buckets*2)-1)) ? 1 : 0); (&(&tankIO_server_setLed_function)->hh)->tbl->nonideal_items = 0; for(_he_bkt_i = 0; _he_bkt_i < (&(&tankIO_server_setLed_function)->hh)->tbl->num_buckets; _he_bkt_i++) { _he_thh = (&(&tankIO_server_setLed_function)->hh)->tbl->buckets[ _he_bkt_i ].hh_head; while (_he_thh) { _he_hh_nxt = _he_thh->hh_next; do { _he_bkt = ((_he_thh->hashv) & (((&(&tankIO_server_setLed_function)->hh)->tbl->num_buckets*2) - 1)); } while(0); _he_newbkt = &(_he_new_buckets[ _he_bkt ]); if (++(_he_newbkt->count) > (&(&tankIO_server_setLed_function)->hh)->tbl->ideal_chain_maxlen) { (&(&tankIO_server_setLed_function)->hh)->tbl->nonideal_items++; _he_newbkt->expand_mult = _he_newbkt->count / (&(&tankIO_server_setLed_function)->hh)->tbl->ideal_chain_maxlen; } _he_thh->hh_prev = ((void *)0); _he_thh->hh_next = _he_newbkt->hh_head; if (_he_newbkt->hh_head) _he_newbkt->hh_head->hh_prev = _he_thh; _he_newbkt->hh_head = _he_thh; _he_thh = _he_hh_nxt; } } free((&(&tankIO_server_setLed_function)->hh)->tbl->buckets); (&(&tankIO_server_setLed_function)->hh)->tbl->num_buckets *= 2; (&(&tankIO_server_setLed_function)->hh)->tbl->log2_num_buckets++; (&(&tankIO_server_setLed_function)->hh)->tbl->buckets = _he_new_buckets; (&(&tankIO_server_setLed_function)->hh)->tbl->ineff_expands = ((&(&tankIO_server_setLed_function)->hh)->tbl->nonideal_items > ((&(&tankIO_server_setLed_function)->hh)->tbl->num_items >> 1)) ? ((&(&tankIO_server_setLed_function)->hh)->tbl->ineff_expands+1) : 0; if ((&(&tankIO_server_setLed_function)->hh)->tbl->ineff_expands > 1) { (&(&tankIO_server_setLed_function)->hh)->tbl->noexpand=1; ; } ; } while(0); } } while(0); ; ; ; } while(0); } void tankIO_server_setLed_register_function_kernel_init() __attribute__((naked, section(".init8"))); void tankIO_server_setLed_register_function_kernel_init() { tankIO_server_setLed_register_function(); }





void tankIO_server_setLeds(MaskedLeds *leds, uint16_t size) {
 setLeds(toLedGroup(leds->leds), leds->mask);
}
void tankIO_server_setLeds_handler(TWIBuffer *buffer) { tankIO_server_setLeds((MaskedLeds*) buffer->data, buffer->size); buffer->size = 0; } TwiFunction tankIO_server_setLeds_function = { TANK_IO_setLeds, tankIO_server_setLeds_handler, {0} }; void tankIO_server_setLeds_register_function() { do { unsigned _ha_bkt; (&tankIO_server_setLeds_function)->hh.next = ((void *)0); (&tankIO_server_setLeds_function)->hh.key = (char*)&((&tankIO_server_setLeds_function)->operation); (&tankIO_server_setLeds_function)->hh.keylen = (unsigned)sizeof(int); if (!(twiRpcFunctions)) { twiRpcFunctions = (&tankIO_server_setLeds_function); (twiRpcFunctions)->hh.prev = ((void *)0); do { (twiRpcFunctions)->hh.tbl = (UT_hash_table*)malloc(sizeof(UT_hash_table)); if (!((twiRpcFunctions)->hh.tbl)) { exit(-1); } memset((twiRpcFunctions)->hh.tbl, 0, sizeof(UT_hash_table)); (twiRpcFunctions)->hh.tbl->tail = &((twiRpcFunctions)->hh); (twiRpcFunctions)->hh.tbl->num_buckets = 32; (twiRpcFunctions)->hh.tbl->log2_num_buckets = 5; (twiRpcFunctions)->hh.tbl->hho = (char*)(&(twiRpcFunctions)->hh) - (char*)(twiRpcFunctions); (twiRpcFunctions)->hh.tbl->buckets = (UT_hash_bucket*)malloc(32*sizeof(struct UT_hash_bucket)); if (! (twiRpcFunctions)->hh.tbl->buckets) { exit(-1); } memset((twiRpcFunctions)->hh.tbl->buckets, 0, 32*sizeof(struct UT_hash_bucket)); ; (twiRpcFunctions)->hh.tbl->signature = 0xa0111fe1; } while(0); } else { (twiRpcFunctions)->hh.tbl->tail->next = (&tankIO_server_setLeds_function); (&tankIO_server_setLeds_function)->hh.prev = ((void*)(((char*)((twiRpcFunctions)->hh.tbl->tail)) - (((twiRpcFunctions)->hh.tbl)->hho))); (twiRpcFunctions)->hh.tbl->tail = &((&tankIO_server_setLeds_function)->hh); } (twiRpcFunctions)->hh.tbl->num_items++; (&tankIO_server_setLeds_function)->hh.tbl = (twiRpcFunctions)->hh.tbl; do { unsigned _sx_i; char *_hs_key=(char*)(&((&tankIO_server_setLeds_function)->operation)); (&tankIO_server_setLeds_function)->hh.hashv = 0; for(_sx_i=0; _sx_i < sizeof(int); _sx_i++) (&tankIO_server_setLeds_function)->hh.hashv ^= ((&tankIO_server_setLeds_function)->hh.hashv << 5) + ((&tankIO_server_setLeds_function)->hh.hashv >> 2) + _hs_key[_sx_i]; _ha_bkt = (&tankIO_server_setLeds_function)->hh.hashv & ((twiRpcFunctions)->hh.tbl->num_buckets-1); } while (0); do { (twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].count++; (&(&tankIO_server_setLeds_function)->hh)->hh_next = (twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].hh_head; (&(&tankIO_server_setLeds_function)->hh)->hh_prev = ((void *)0); if ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].hh_head) { ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt]).hh_head->hh_prev = (&(&tankIO_server_setLeds_function)->hh); } ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt]).hh_head=&(&tankIO_server_setLeds_function)->hh; if ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].count >= (((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].expand_mult+1) * 10) && (&(&tankIO_server_setLeds_function)->hh)->tbl->noexpand != 1) { do { unsigned _he_bkt; unsigned _he_bkt_i; struct UT_hash_handle *_he_thh, *_he_hh_nxt; UT_hash_bucket *_he_new_buckets, *_he_newbkt; _he_new_buckets = (UT_hash_bucket*)malloc(2 * (&(&tankIO_server_setLeds_function)->hh)->tbl->num_buckets * sizeof(struct UT_hash_bucket)); if (!_he_new_buckets) { exit(-1); } memset(_he_new_buckets, 0, 2 * (&(&tankIO_server_setLeds_function)->hh)->tbl->num_buckets * sizeof(struct UT_hash_bucket)); (&(&tankIO_server_setLeds_function)->hh)->tbl->ideal_chain_maxlen = ((&(&tankIO_server_setLeds_function)->hh)->tbl->num_items >> ((&(&tankIO_server_setLeds_function)->hh)->tbl->log2_num_buckets+1)) + (((&(&tankIO_server_setLeds_function)->hh)->tbl->num_items & (((&(&tankIO_server_setLeds_function)->hh)->tbl->num_buckets*2)-1)) ? 1 : 0); (&(&tankIO_server_setLeds_function)->hh)->tbl->nonideal_items = 0; for(_he_bkt_i = 0; _he_bkt_i < (&(&tankIO_server_setLeds_function)->hh)->tbl->num_buckets; _he_bkt_i++) { _he_thh = (&(&tankIO_server_setLeds_function)->hh)->tbl->buckets[ _he_bkt_i ].hh_head; while (_he_thh) { _he_hh_nxt = _he_thh->hh_next; do { _he_bkt = ((_he_thh->hashv) & (((&(&tankIO_server_setLeds_function)->hh)->tbl->num_buckets*2) - 1)); } while(0); _he_newbkt = &(_he_new_buckets[ _he_bkt ]); if (++(_he_newbkt->count) > (&(&tankIO_server_setLeds_function)->hh)->tbl->ideal_chain_maxlen) { (&(&tankIO_server_setLeds_function)->hh)->tbl->nonideal_items++; _he_newbkt->expand_mult = _he_newbkt->count / (&(&tankIO_server_setLeds_function)->hh)->tbl->ideal_chain_maxlen; } _he_thh->hh_prev = ((void *)0); _he_thh->hh_next = _he_newbkt->hh_head; if (_he_newbkt->hh_head) _he_newbkt->hh_head->hh_prev = _he_thh; _he_newbkt->hh_head = _he_thh; _he_thh = _he_hh_nxt; } } free((&(&tankIO_server_setLeds_function)->hh)->tbl->buckets); (&(&tankIO_server_setLeds_function)->hh)->tbl->num_buckets *= 2; (&(&tankIO_server_setLeds_function)->hh)->tbl->log2_num_buckets++; (&(&tankIO_server_setLeds_function)->hh)->tbl->buckets = _he_new_buckets; (&(&tankIO_server_setLeds_function)->hh)->tbl->ineff_expands = ((&(&tankIO_server_setLeds_function)->hh)->tbl->nonideal_items > ((&(&tankIO_server_setLeds_function)->hh)->tbl->num_items >> 1)) ? ((&(&tankIO_server_setLeds_function)->hh)->tbl->ineff_expands+1) : 0; if ((&(&tankIO_server_setLeds_function)->hh)->tbl->ineff_expands > 1) { (&(&tankIO_server_setLeds_function)->hh)->tbl->noexpand=1; ; } ; } while(0); } } while(0); ; ; ; } while(0); } void tankIO_server_setLeds_register_function_kernel_init() __attribute__((naked, section(".init8"))); void tankIO_server_setLeds_register_function_kernel_init() { tankIO_server_setLeds_register_function(); }

void tankIO_server_enableLeds(TankIoLeds *leds, uint16_t size) {
 enableLeds(toLedGroup(*leds));
}
void tankIO_server_enableLeds_handler(TWIBuffer *buffer) { tankIO_server_enableLeds((TankIoLeds*) buffer->data, buffer->size); buffer->size = 0; } TwiFunction tankIO_server_enableLeds_function = { TANK_IO_enableLeds, tankIO_server_enableLeds_handler, {0} }; void tankIO_server_enableLeds_register_function() { do { unsigned _ha_bkt; (&tankIO_server_enableLeds_function)->hh.next = ((void *)0); (&tankIO_server_enableLeds_function)->hh.key = (char*)&((&tankIO_server_enableLeds_function)->operation); (&tankIO_server_enableLeds_function)->hh.keylen = (unsigned)sizeof(int); if (!(twiRpcFunctions)) { twiRpcFunctions = (&tankIO_server_enableLeds_function); (twiRpcFunctions)->hh.prev = ((void *)0); do { (twiRpcFunctions)->hh.tbl = (UT_hash_table*)malloc(sizeof(UT_hash_table)); if (!((twiRpcFunctions)->hh.tbl)) { exit(-1); } memset((twiRpcFunctions)->hh.tbl, 0, sizeof(UT_hash_table)); (twiRpcFunctions)->hh.tbl->tail = &((twiRpcFunctions)->hh); (twiRpcFunctions)->hh.tbl->num_buckets = 32; (twiRpcFunctions)->hh.tbl->log2_num_buckets = 5; (twiRpcFunctions)->hh.tbl->hho = (char*)(&(twiRpcFunctions)->hh) - (char*)(twiRpcFunctions); (twiRpcFunctions)->hh.tbl->buckets = (UT_hash_bucket*)malloc(32*sizeof(struct UT_hash_bucket)); if (! (twiRpcFunctions)->hh.tbl->buckets) { exit(-1); } memset((twiRpcFunctions)->hh.tbl->buckets, 0, 32*sizeof(struct UT_hash_bucket)); ; (twiRpcFunctions)->hh.tbl->signature = 0xa0111fe1; } while(0); } else { (twiRpcFunctions)->hh.tbl->tail->next = (&tankIO_server_enableLeds_function); (&tankIO_server_enableLeds_function)->hh.prev = ((void*)(((char*)((twiRpcFunctions)->hh.tbl->tail)) - (((twiRpcFunctions)->hh.tbl)->hho))); (twiRpcFunctions)->hh.tbl->tail = &((&tankIO_server_enableLeds_function)->hh); } (twiRpcFunctions)->hh.tbl->num_items++; (&tankIO_server_enableLeds_function)->hh.tbl = (twiRpcFunctions)->hh.tbl; do { unsigned _sx_i; char *_hs_key=(char*)(&((&tankIO_server_enableLeds_function)->operation)); (&tankIO_server_enableLeds_function)->hh.hashv = 0; for(_sx_i=0; _sx_i < sizeof(int); _sx_i++) (&tankIO_server_enableLeds_function)->hh.hashv ^= ((&tankIO_server_enableLeds_function)->hh.hashv << 5) + ((&tankIO_server_enableLeds_function)->hh.hashv >> 2) + _hs_key[_sx_i]; _ha_bkt = (&tankIO_server_enableLeds_function)->hh.hashv & ((twiRpcFunctions)->hh.tbl->num_buckets-1); } while (0); do { (twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].count++; (&(&tankIO_server_enableLeds_function)->hh)->hh_next = (twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].hh_head; (&(&tankIO_server_enableLeds_function)->hh)->hh_prev = ((void *)0); if ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].hh_head) { ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt]).hh_head->hh_prev = (&(&tankIO_server_enableLeds_function)->hh); } ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt]).hh_head=&(&tankIO_server_enableLeds_function)->hh; if ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].count >= (((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].expand_mult+1) * 10) && (&(&tankIO_server_enableLeds_function)->hh)->tbl->noexpand != 1) { do { unsigned _he_bkt; unsigned _he_bkt_i; struct UT_hash_handle *_he_thh, *_he_hh_nxt; UT_hash_bucket *_he_new_buckets, *_he_newbkt; _he_new_buckets = (UT_hash_bucket*)malloc(2 * (&(&tankIO_server_enableLeds_function)->hh)->tbl->num_buckets * sizeof(struct UT_hash_bucket)); if (!_he_new_buckets) { exit(-1); } memset(_he_new_buckets, 0, 2 * (&(&tankIO_server_enableLeds_function)->hh)->tbl->num_buckets * sizeof(struct UT_hash_bucket)); (&(&tankIO_server_enableLeds_function)->hh)->tbl->ideal_chain_maxlen = ((&(&tankIO_server_enableLeds_function)->hh)->tbl->num_items >> ((&(&tankIO_server_enableLeds_function)->hh)->tbl->log2_num_buckets+1)) + (((&(&tankIO_server_enableLeds_function)->hh)->tbl->num_items & (((&(&tankIO_server_enableLeds_function)->hh)->tbl->num_buckets*2)-1)) ? 1 : 0); (&(&tankIO_server_enableLeds_function)->hh)->tbl->nonideal_items = 0; for(_he_bkt_i = 0; _he_bkt_i < (&(&tankIO_server_enableLeds_function)->hh)->tbl->num_buckets; _he_bkt_i++) { _he_thh = (&(&tankIO_server_enableLeds_function)->hh)->tbl->buckets[ _he_bkt_i ].hh_head; while (_he_thh) { _he_hh_nxt = _he_thh->hh_next; do { _he_bkt = ((_he_thh->hashv) & (((&(&tankIO_server_enableLeds_function)->hh)->tbl->num_buckets*2) - 1)); } while(0); _he_newbkt = &(_he_new_buckets[ _he_bkt ]); if (++(_he_newbkt->count) > (&(&tankIO_server_enableLeds_function)->hh)->tbl->ideal_chain_maxlen) { (&(&tankIO_server_enableLeds_function)->hh)->tbl->nonideal_items++; _he_newbkt->expand_mult = _he_newbkt->count / (&(&tankIO_server_enableLeds_function)->hh)->tbl->ideal_chain_maxlen; } _he_thh->hh_prev = ((void *)0); _he_thh->hh_next = _he_newbkt->hh_head; if (_he_newbkt->hh_head) _he_newbkt->hh_head->hh_prev = _he_thh; _he_newbkt->hh_head = _he_thh; _he_thh = _he_hh_nxt; } } free((&(&tankIO_server_enableLeds_function)->hh)->tbl->buckets); (&(&tankIO_server_enableLeds_function)->hh)->tbl->num_buckets *= 2; (&(&tankIO_server_enableLeds_function)->hh)->tbl->log2_num_buckets++; (&(&tankIO_server_enableLeds_function)->hh)->tbl->buckets = _he_new_buckets; (&(&tankIO_server_enableLeds_function)->hh)->tbl->ineff_expands = ((&(&tankIO_server_enableLeds_function)->hh)->tbl->nonideal_items > ((&(&tankIO_server_enableLeds_function)->hh)->tbl->num_items >> 1)) ? ((&(&tankIO_server_enableLeds_function)->hh)->tbl->ineff_expands+1) : 0; if ((&(&tankIO_server_enableLeds_function)->hh)->tbl->ineff_expands > 1) { (&(&tankIO_server_enableLeds_function)->hh)->tbl->noexpand=1; ; } ; } while(0); } } while(0); ; ; ; } while(0); } void tankIO_server_enableLeds_register_function_kernel_init() __attribute__((naked, section(".init8"))); void tankIO_server_enableLeds_register_function_kernel_init() { tankIO_server_enableLeds_register_function(); }

void tankIO_server_disableLeds(TankIoLeds *leds, uint16_t size) {
 disableLeds(toLedGroup(*leds));
}
void tankIO_server_disableLeds_handler(TWIBuffer *buffer) { tankIO_server_disableLeds((TankIoLeds*) buffer->data, buffer->size); buffer->size = 0; } TwiFunction tankIO_server_disableLeds_function = { TANK_IO_disableLeds, tankIO_server_disableLeds_handler, {0} }; void tankIO_server_disableLeds_register_function() { do { unsigned _ha_bkt; (&tankIO_server_disableLeds_function)->hh.next = ((void *)0); (&tankIO_server_disableLeds_function)->hh.key = (char*)&((&tankIO_server_disableLeds_function)->operation); (&tankIO_server_disableLeds_function)->hh.keylen = (unsigned)sizeof(int); if (!(twiRpcFunctions)) { twiRpcFunctions = (&tankIO_server_disableLeds_function); (twiRpcFunctions)->hh.prev = ((void *)0); do { (twiRpcFunctions)->hh.tbl = (UT_hash_table*)malloc(sizeof(UT_hash_table)); if (!((twiRpcFunctions)->hh.tbl)) { exit(-1); } memset((twiRpcFunctions)->hh.tbl, 0, sizeof(UT_hash_table)); (twiRpcFunctions)->hh.tbl->tail = &((twiRpcFunctions)->hh); (twiRpcFunctions)->hh.tbl->num_buckets = 32; (twiRpcFunctions)->hh.tbl->log2_num_buckets = 5; (twiRpcFunctions)->hh.tbl->hho = (char*)(&(twiRpcFunctions)->hh) - (char*)(twiRpcFunctions); (twiRpcFunctions)->hh.tbl->buckets = (UT_hash_bucket*)malloc(32*sizeof(struct UT_hash_bucket)); if (! (twiRpcFunctions)->hh.tbl->buckets) { exit(-1); } memset((twiRpcFunctions)->hh.tbl->buckets, 0, 32*sizeof(struct UT_hash_bucket)); ; (twiRpcFunctions)->hh.tbl->signature = 0xa0111fe1; } while(0); } else { (twiRpcFunctions)->hh.tbl->tail->next = (&tankIO_server_disableLeds_function); (&tankIO_server_disableLeds_function)->hh.prev = ((void*)(((char*)((twiRpcFunctions)->hh.tbl->tail)) - (((twiRpcFunctions)->hh.tbl)->hho))); (twiRpcFunctions)->hh.tbl->tail = &((&tankIO_server_disableLeds_function)->hh); } (twiRpcFunctions)->hh.tbl->num_items++; (&tankIO_server_disableLeds_function)->hh.tbl = (twiRpcFunctions)->hh.tbl; do { unsigned _sx_i; char *_hs_key=(char*)(&((&tankIO_server_disableLeds_function)->operation)); (&tankIO_server_disableLeds_function)->hh.hashv = 0; for(_sx_i=0; _sx_i < sizeof(int); _sx_i++) (&tankIO_server_disableLeds_function)->hh.hashv ^= ((&tankIO_server_disableLeds_function)->hh.hashv << 5) + ((&tankIO_server_disableLeds_function)->hh.hashv >> 2) + _hs_key[_sx_i]; _ha_bkt = (&tankIO_server_disableLeds_function)->hh.hashv & ((twiRpcFunctions)->hh.tbl->num_buckets-1); } while (0); do { (twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].count++; (&(&tankIO_server_disableLeds_function)->hh)->hh_next = (twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].hh_head; (&(&tankIO_server_disableLeds_function)->hh)->hh_prev = ((void *)0); if ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].hh_head) { ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt]).hh_head->hh_prev = (&(&tankIO_server_disableLeds_function)->hh); } ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt]).hh_head=&(&tankIO_server_disableLeds_function)->hh; if ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].count >= (((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].expand_mult+1) * 10) && (&(&tankIO_server_disableLeds_function)->hh)->tbl->noexpand != 1) { do { unsigned _he_bkt; unsigned _he_bkt_i; struct UT_hash_handle *_he_thh, *_he_hh_nxt; UT_hash_bucket *_he_new_buckets, *_he_newbkt; _he_new_buckets = (UT_hash_bucket*)malloc(2 * (&(&tankIO_server_disableLeds_function)->hh)->tbl->num_buckets * sizeof(struct UT_hash_bucket)); if (!_he_new_buckets) { exit(-1); } memset(_he_new_buckets, 0, 2 * (&(&tankIO_server_disableLeds_function)->hh)->tbl->num_buckets * sizeof(struct UT_hash_bucket)); (&(&tankIO_server_disableLeds_function)->hh)->tbl->ideal_chain_maxlen = ((&(&tankIO_server_disableLeds_function)->hh)->tbl->num_items >> ((&(&tankIO_server_disableLeds_function)->hh)->tbl->log2_num_buckets+1)) + (((&(&tankIO_server_disableLeds_function)->hh)->tbl->num_items & (((&(&tankIO_server_disableLeds_function)->hh)->tbl->num_buckets*2)-1)) ? 1 : 0); (&(&tankIO_server_disableLeds_function)->hh)->tbl->nonideal_items = 0; for(_he_bkt_i = 0; _he_bkt_i < (&(&tankIO_server_disableLeds_function)->hh)->tbl->num_buckets; _he_bkt_i++) { _he_thh = (&(&tankIO_server_disableLeds_function)->hh)->tbl->buckets[ _he_bkt_i ].hh_head; while (_he_thh) { _he_hh_nxt = _he_thh->hh_next; do { _he_bkt = ((_he_thh->hashv) & (((&(&tankIO_server_disableLeds_function)->hh)->tbl->num_buckets*2) - 1)); } while(0); _he_newbkt = &(_he_new_buckets[ _he_bkt ]); if (++(_he_newbkt->count) > (&(&tankIO_server_disableLeds_function)->hh)->tbl->ideal_chain_maxlen) { (&(&tankIO_server_disableLeds_function)->hh)->tbl->nonideal_items++; _he_newbkt->expand_mult = _he_newbkt->count / (&(&tankIO_server_disableLeds_function)->hh)->tbl->ideal_chain_maxlen; } _he_thh->hh_prev = ((void *)0); _he_thh->hh_next = _he_newbkt->hh_head; if (_he_newbkt->hh_head) _he_newbkt->hh_head->hh_prev = _he_thh; _he_newbkt->hh_head = _he_thh; _he_thh = _he_hh_nxt; } } free((&(&tankIO_server_disableLeds_function)->hh)->tbl->buckets); (&(&tankIO_server_disableLeds_function)->hh)->tbl->num_buckets *= 2; (&(&tankIO_server_disableLeds_function)->hh)->tbl->log2_num_buckets++; (&(&tankIO_server_disableLeds_function)->hh)->tbl->buckets = _he_new_buckets; (&(&tankIO_server_disableLeds_function)->hh)->tbl->ineff_expands = ((&(&tankIO_server_disableLeds_function)->hh)->tbl->nonideal_items > ((&(&tankIO_server_disableLeds_function)->hh)->tbl->num_items >> 1)) ? ((&(&tankIO_server_disableLeds_function)->hh)->tbl->ineff_expands+1) : 0; if ((&(&tankIO_server_disableLeds_function)->hh)->tbl->ineff_expands > 1) { (&(&tankIO_server_disableLeds_function)->hh)->tbl->noexpand=1; ; } ; } while(0); } } while(0); ; ; ; } while(0); } void tankIO_server_disableLeds_register_function_kernel_init() __attribute__((naked, section(".init8"))); void tankIO_server_disableLeds_register_function_kernel_init() { tankIO_server_disableLeds_register_function(); }





void tankIO_server_blinkLed(BlinkLedParam *param, uint16_t size) {
 blinkLed(toLed(param->led), param->times);
}
void tankIO_server_blinkLed_handler(TWIBuffer *buffer) { tankIO_server_blinkLed((BlinkLedParam*) buffer->data, buffer->size); buffer->size = 0; } TwiFunction tankIO_server_blinkLed_function = { TANK_IO_blinkLed, tankIO_server_blinkLed_handler, {0} }; void tankIO_server_blinkLed_register_function() { do { unsigned _ha_bkt; (&tankIO_server_blinkLed_function)->hh.next = ((void *)0); (&tankIO_server_blinkLed_function)->hh.key = (char*)&((&tankIO_server_blinkLed_function)->operation); (&tankIO_server_blinkLed_function)->hh.keylen = (unsigned)sizeof(int); if (!(twiRpcFunctions)) { twiRpcFunctions = (&tankIO_server_blinkLed_function); (twiRpcFunctions)->hh.prev = ((void *)0); do { (twiRpcFunctions)->hh.tbl = (UT_hash_table*)malloc(sizeof(UT_hash_table)); if (!((twiRpcFunctions)->hh.tbl)) { exit(-1); } memset((twiRpcFunctions)->hh.tbl, 0, sizeof(UT_hash_table)); (twiRpcFunctions)->hh.tbl->tail = &((twiRpcFunctions)->hh); (twiRpcFunctions)->hh.tbl->num_buckets = 32; (twiRpcFunctions)->hh.tbl->log2_num_buckets = 5; (twiRpcFunctions)->hh.tbl->hho = (char*)(&(twiRpcFunctions)->hh) - (char*)(twiRpcFunctions); (twiRpcFunctions)->hh.tbl->buckets = (UT_hash_bucket*)malloc(32*sizeof(struct UT_hash_bucket)); if (! (twiRpcFunctions)->hh.tbl->buckets) { exit(-1); } memset((twiRpcFunctions)->hh.tbl->buckets, 0, 32*sizeof(struct UT_hash_bucket)); ; (twiRpcFunctions)->hh.tbl->signature = 0xa0111fe1; } while(0); } else { (twiRpcFunctions)->hh.tbl->tail->next = (&tankIO_server_blinkLed_function); (&tankIO_server_blinkLed_function)->hh.prev = ((void*)(((char*)((twiRpcFunctions)->hh.tbl->tail)) - (((twiRpcFunctions)->hh.tbl)->hho))); (twiRpcFunctions)->hh.tbl->tail = &((&tankIO_server_blinkLed_function)->hh); } (twiRpcFunctions)->hh.tbl->num_items++; (&tankIO_server_blinkLed_function)->hh.tbl = (twiRpcFunctions)->hh.tbl; do { unsigned _sx_i; char *_hs_key=(char*)(&((&tankIO_server_blinkLed_function)->operation)); (&tankIO_server_blinkLed_function)->hh.hashv = 0; for(_sx_i=0; _sx_i < sizeof(int); _sx_i++) (&tankIO_server_blinkLed_function)->hh.hashv ^= ((&tankIO_server_blinkLed_function)->hh.hashv << 5) + ((&tankIO_server_blinkLed_function)->hh.hashv >> 2) + _hs_key[_sx_i]; _ha_bkt = (&tankIO_server_blinkLed_function)->hh.hashv & ((twiRpcFunctions)->hh.tbl->num_buckets-1); } while (0); do { (twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].count++; (&(&tankIO_server_blinkLed_function)->hh)->hh_next = (twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].hh_head; (&(&tankIO_server_blinkLed_function)->hh)->hh_prev = ((void *)0); if ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].hh_head) { ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt]).hh_head->hh_prev = (&(&tankIO_server_blinkLed_function)->hh); } ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt]).hh_head=&(&tankIO_server_blinkLed_function)->hh; if ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].count >= (((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].expand_mult+1) * 10) && (&(&tankIO_server_blinkLed_function)->hh)->tbl->noexpand != 1) { do { unsigned _he_bkt; unsigned _he_bkt_i; struct UT_hash_handle *_he_thh, *_he_hh_nxt; UT_hash_bucket *_he_new_buckets, *_he_newbkt; _he_new_buckets = (UT_hash_bucket*)malloc(2 * (&(&tankIO_server_blinkLed_function)->hh)->tbl->num_buckets * sizeof(struct UT_hash_bucket)); if (!_he_new_buckets) { exit(-1); } memset(_he_new_buckets, 0, 2 * (&(&tankIO_server_blinkLed_function)->hh)->tbl->num_buckets * sizeof(struct UT_hash_bucket)); (&(&tankIO_server_blinkLed_function)->hh)->tbl->ideal_chain_maxlen = ((&(&tankIO_server_blinkLed_function)->hh)->tbl->num_items >> ((&(&tankIO_server_blinkLed_function)->hh)->tbl->log2_num_buckets+1)) + (((&(&tankIO_server_blinkLed_function)->hh)->tbl->num_items & (((&(&tankIO_server_blinkLed_function)->hh)->tbl->num_buckets*2)-1)) ? 1 : 0); (&(&tankIO_server_blinkLed_function)->hh)->tbl->nonideal_items = 0; for(_he_bkt_i = 0; _he_bkt_i < (&(&tankIO_server_blinkLed_function)->hh)->tbl->num_buckets; _he_bkt_i++) { _he_thh = (&(&tankIO_server_blinkLed_function)->hh)->tbl->buckets[ _he_bkt_i ].hh_head; while (_he_thh) { _he_hh_nxt = _he_thh->hh_next; do { _he_bkt = ((_he_thh->hashv) & (((&(&tankIO_server_blinkLed_function)->hh)->tbl->num_buckets*2) - 1)); } while(0); _he_newbkt = &(_he_new_buckets[ _he_bkt ]); if (++(_he_newbkt->count) > (&(&tankIO_server_blinkLed_function)->hh)->tbl->ideal_chain_maxlen) { (&(&tankIO_server_blinkLed_function)->hh)->tbl->nonideal_items++; _he_newbkt->expand_mult = _he_newbkt->count / (&(&tankIO_server_blinkLed_function)->hh)->tbl->ideal_chain_maxlen; } _he_thh->hh_prev = ((void *)0); _he_thh->hh_next = _he_newbkt->hh_head; if (_he_newbkt->hh_head) _he_newbkt->hh_head->hh_prev = _he_thh; _he_newbkt->hh_head = _he_thh; _he_thh = _he_hh_nxt; } } free((&(&tankIO_server_blinkLed_function)->hh)->tbl->buckets); (&(&tankIO_server_blinkLed_function)->hh)->tbl->num_buckets *= 2; (&(&tankIO_server_blinkLed_function)->hh)->tbl->log2_num_buckets++; (&(&tankIO_server_blinkLed_function)->hh)->tbl->buckets = _he_new_buckets; (&(&tankIO_server_blinkLed_function)->hh)->tbl->ineff_expands = ((&(&tankIO_server_blinkLed_function)->hh)->tbl->nonideal_items > ((&(&tankIO_server_blinkLed_function)->hh)->tbl->num_items >> 1)) ? ((&(&tankIO_server_blinkLed_function)->hh)->tbl->ineff_expands+1) : 0; if ((&(&tankIO_server_blinkLed_function)->hh)->tbl->ineff_expands > 1) { (&(&tankIO_server_blinkLed_function)->hh)->tbl->noexpand=1; ; } ; } while(0); } } while(0); ; ; ; } while(0); } void tankIO_server_blinkLed_register_function_kernel_init() __attribute__((naked, section(".init8"))); void tankIO_server_blinkLed_register_function_kernel_init() { tankIO_server_blinkLed_register_function(); }

void tankIO_server_blinkLeds(BlinkLedsParam *param, uint16_t size) {
 blinkLeds(toLedGroup(param->leds.leds), param->leds.mask, param->times);
}
void tankIO_server_blinkLeds_handler(TWIBuffer *buffer) { tankIO_server_blinkLeds((BlinkLedsParam*) buffer->data, buffer->size); buffer->size = 0; } TwiFunction tankIO_server_blinkLeds_function = { TANK_IO_blinkLeds, tankIO_server_blinkLeds_handler, {0} }; void tankIO_server_blinkLeds_register_function() { do { unsigned _ha_bkt; (&tankIO_server_blinkLeds_function)->hh.next = ((void *)0); (&tankIO_server_blinkLeds_function)->hh.key = (char*)&((&tankIO_server_blinkLeds_function)->operation); (&tankIO_server_blinkLeds_function)->hh.keylen = (unsigned)sizeof(int); if (!(twiRpcFunctions)) { twiRpcFunctions = (&tankIO_server_blinkLeds_function); (twiRpcFunctions)->hh.prev = ((void *)0); do { (twiRpcFunctions)->hh.tbl = (UT_hash_table*)malloc(sizeof(UT_hash_table)); if (!((twiRpcFunctions)->hh.tbl)) { exit(-1); } memset((twiRpcFunctions)->hh.tbl, 0, sizeof(UT_hash_table)); (twiRpcFunctions)->hh.tbl->tail = &((twiRpcFunctions)->hh); (twiRpcFunctions)->hh.tbl->num_buckets = 32; (twiRpcFunctions)->hh.tbl->log2_num_buckets = 5; (twiRpcFunctions)->hh.tbl->hho = (char*)(&(twiRpcFunctions)->hh) - (char*)(twiRpcFunctions); (twiRpcFunctions)->hh.tbl->buckets = (UT_hash_bucket*)malloc(32*sizeof(struct UT_hash_bucket)); if (! (twiRpcFunctions)->hh.tbl->buckets) { exit(-1); } memset((twiRpcFunctions)->hh.tbl->buckets, 0, 32*sizeof(struct UT_hash_bucket)); ; (twiRpcFunctions)->hh.tbl->signature = 0xa0111fe1; } while(0); } else { (twiRpcFunctions)->hh.tbl->tail->next = (&tankIO_server_blinkLeds_function); (&tankIO_server_blinkLeds_function)->hh.prev = ((void*)(((char*)((twiRpcFunctions)->hh.tbl->tail)) - (((twiRpcFunctions)->hh.tbl)->hho))); (twiRpcFunctions)->hh.tbl->tail = &((&tankIO_server_blinkLeds_function)->hh); } (twiRpcFunctions)->hh.tbl->num_items++; (&tankIO_server_blinkLeds_function)->hh.tbl = (twiRpcFunctions)->hh.tbl; do { unsigned _sx_i; char *_hs_key=(char*)(&((&tankIO_server_blinkLeds_function)->operation)); (&tankIO_server_blinkLeds_function)->hh.hashv = 0; for(_sx_i=0; _sx_i < sizeof(int); _sx_i++) (&tankIO_server_blinkLeds_function)->hh.hashv ^= ((&tankIO_server_blinkLeds_function)->hh.hashv << 5) + ((&tankIO_server_blinkLeds_function)->hh.hashv >> 2) + _hs_key[_sx_i]; _ha_bkt = (&tankIO_server_blinkLeds_function)->hh.hashv & ((twiRpcFunctions)->hh.tbl->num_buckets-1); } while (0); do { (twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].count++; (&(&tankIO_server_blinkLeds_function)->hh)->hh_next = (twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].hh_head; (&(&tankIO_server_blinkLeds_function)->hh)->hh_prev = ((void *)0); if ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].hh_head) { ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt]).hh_head->hh_prev = (&(&tankIO_server_blinkLeds_function)->hh); } ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt]).hh_head=&(&tankIO_server_blinkLeds_function)->hh; if ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].count >= (((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].expand_mult+1) * 10) && (&(&tankIO_server_blinkLeds_function)->hh)->tbl->noexpand != 1) { do { unsigned _he_bkt; unsigned _he_bkt_i; struct UT_hash_handle *_he_thh, *_he_hh_nxt; UT_hash_bucket *_he_new_buckets, *_he_newbkt; _he_new_buckets = (UT_hash_bucket*)malloc(2 * (&(&tankIO_server_blinkLeds_function)->hh)->tbl->num_buckets * sizeof(struct UT_hash_bucket)); if (!_he_new_buckets) { exit(-1); } memset(_he_new_buckets, 0, 2 * (&(&tankIO_server_blinkLeds_function)->hh)->tbl->num_buckets * sizeof(struct UT_hash_bucket)); (&(&tankIO_server_blinkLeds_function)->hh)->tbl->ideal_chain_maxlen = ((&(&tankIO_server_blinkLeds_function)->hh)->tbl->num_items >> ((&(&tankIO_server_blinkLeds_function)->hh)->tbl->log2_num_buckets+1)) + (((&(&tankIO_server_blinkLeds_function)->hh)->tbl->num_items & (((&(&tankIO_server_blinkLeds_function)->hh)->tbl->num_buckets*2)-1)) ? 1 : 0); (&(&tankIO_server_blinkLeds_function)->hh)->tbl->nonideal_items = 0; for(_he_bkt_i = 0; _he_bkt_i < (&(&tankIO_server_blinkLeds_function)->hh)->tbl->num_buckets; _he_bkt_i++) { _he_thh = (&(&tankIO_server_blinkLeds_function)->hh)->tbl->buckets[ _he_bkt_i ].hh_head; while (_he_thh) { _he_hh_nxt = _he_thh->hh_next; do { _he_bkt = ((_he_thh->hashv) & (((&(&tankIO_server_blinkLeds_function)->hh)->tbl->num_buckets*2) - 1)); } while(0); _he_newbkt = &(_he_new_buckets[ _he_bkt ]); if (++(_he_newbkt->count) > (&(&tankIO_server_blinkLeds_function)->hh)->tbl->ideal_chain_maxlen) { (&(&tankIO_server_blinkLeds_function)->hh)->tbl->nonideal_items++; _he_newbkt->expand_mult = _he_newbkt->count / (&(&tankIO_server_blinkLeds_function)->hh)->tbl->ideal_chain_maxlen; } _he_thh->hh_prev = ((void *)0); _he_thh->hh_next = _he_newbkt->hh_head; if (_he_newbkt->hh_head) _he_newbkt->hh_head->hh_prev = _he_thh; _he_newbkt->hh_head = _he_thh; _he_thh = _he_hh_nxt; } } free((&(&tankIO_server_blinkLeds_function)->hh)->tbl->buckets); (&(&tankIO_server_blinkLeds_function)->hh)->tbl->num_buckets *= 2; (&(&tankIO_server_blinkLeds_function)->hh)->tbl->log2_num_buckets++; (&(&tankIO_server_blinkLeds_function)->hh)->tbl->buckets = _he_new_buckets; (&(&tankIO_server_blinkLeds_function)->hh)->tbl->ineff_expands = ((&(&tankIO_server_blinkLeds_function)->hh)->tbl->nonideal_items > ((&(&tankIO_server_blinkLeds_function)->hh)->tbl->num_items >> 1)) ? ((&(&tankIO_server_blinkLeds_function)->hh)->tbl->ineff_expands+1) : 0; if ((&(&tankIO_server_blinkLeds_function)->hh)->tbl->ineff_expands > 1) { (&(&tankIO_server_blinkLeds_function)->hh)->tbl->noexpand=1; ; } ; } while(0); } } while(0); ; ; ; } while(0); } void tankIO_server_blinkLeds_register_function_kernel_init() __attribute__((naked, section(".init8"))); void tankIO_server_blinkLeds_register_function_kernel_init() { tankIO_server_blinkLeds_register_function(); }

void tankIO_server_blinkAllLeds(BlinkAllLedsParam *param, uint16_t size) {
 blinkAllLeds(toLedGroup(param->leds), param->times);
}
void tankIO_server_blinkAllLeds_handler(TWIBuffer *buffer) { tankIO_server_blinkAllLeds((BlinkAllLedsParam*) buffer->data, buffer->size); buffer->size = 0; } TwiFunction tankIO_server_blinkAllLeds_function = { TANK_IO_blinkAllLeds, tankIO_server_blinkAllLeds_handler, {0} }; void tankIO_server_blinkAllLeds_register_function() { do { unsigned _ha_bkt; (&tankIO_server_blinkAllLeds_function)->hh.next = ((void *)0); (&tankIO_server_blinkAllLeds_function)->hh.key = (char*)&((&tankIO_server_blinkAllLeds_function)->operation); (&tankIO_server_blinkAllLeds_function)->hh.keylen = (unsigned)sizeof(int); if (!(twiRpcFunctions)) { twiRpcFunctions = (&tankIO_server_blinkAllLeds_function); (twiRpcFunctions)->hh.prev = ((void *)0); do { (twiRpcFunctions)->hh.tbl = (UT_hash_table*)malloc(sizeof(UT_hash_table)); if (!((twiRpcFunctions)->hh.tbl)) { exit(-1); } memset((twiRpcFunctions)->hh.tbl, 0, sizeof(UT_hash_table)); (twiRpcFunctions)->hh.tbl->tail = &((twiRpcFunctions)->hh); (twiRpcFunctions)->hh.tbl->num_buckets = 32; (twiRpcFunctions)->hh.tbl->log2_num_buckets = 5; (twiRpcFunctions)->hh.tbl->hho = (char*)(&(twiRpcFunctions)->hh) - (char*)(twiRpcFunctions); (twiRpcFunctions)->hh.tbl->buckets = (UT_hash_bucket*)malloc(32*sizeof(struct UT_hash_bucket)); if (! (twiRpcFunctions)->hh.tbl->buckets) { exit(-1); } memset((twiRpcFunctions)->hh.tbl->buckets, 0, 32*sizeof(struct UT_hash_bucket)); ; (twiRpcFunctions)->hh.tbl->signature = 0xa0111fe1; } while(0); } else { (twiRpcFunctions)->hh.tbl->tail->next = (&tankIO_server_blinkAllLeds_function); (&tankIO_server_blinkAllLeds_function)->hh.prev = ((void*)(((char*)((twiRpcFunctions)->hh.tbl->tail)) - (((twiRpcFunctions)->hh.tbl)->hho))); (twiRpcFunctions)->hh.tbl->tail = &((&tankIO_server_blinkAllLeds_function)->hh); } (twiRpcFunctions)->hh.tbl->num_items++; (&tankIO_server_blinkAllLeds_function)->hh.tbl = (twiRpcFunctions)->hh.tbl; do { unsigned _sx_i; char *_hs_key=(char*)(&((&tankIO_server_blinkAllLeds_function)->operation)); (&tankIO_server_blinkAllLeds_function)->hh.hashv = 0; for(_sx_i=0; _sx_i < sizeof(int); _sx_i++) (&tankIO_server_blinkAllLeds_function)->hh.hashv ^= ((&tankIO_server_blinkAllLeds_function)->hh.hashv << 5) + ((&tankIO_server_blinkAllLeds_function)->hh.hashv >> 2) + _hs_key[_sx_i]; _ha_bkt = (&tankIO_server_blinkAllLeds_function)->hh.hashv & ((twiRpcFunctions)->hh.tbl->num_buckets-1); } while (0); do { (twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].count++; (&(&tankIO_server_blinkAllLeds_function)->hh)->hh_next = (twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].hh_head; (&(&tankIO_server_blinkAllLeds_function)->hh)->hh_prev = ((void *)0); if ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].hh_head) { ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt]).hh_head->hh_prev = (&(&tankIO_server_blinkAllLeds_function)->hh); } ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt]).hh_head=&(&tankIO_server_blinkAllLeds_function)->hh; if ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].count >= (((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].expand_mult+1) * 10) && (&(&tankIO_server_blinkAllLeds_function)->hh)->tbl->noexpand != 1) { do { unsigned _he_bkt; unsigned _he_bkt_i; struct UT_hash_handle *_he_thh, *_he_hh_nxt; UT_hash_bucket *_he_new_buckets, *_he_newbkt; _he_new_buckets = (UT_hash_bucket*)malloc(2 * (&(&tankIO_server_blinkAllLeds_function)->hh)->tbl->num_buckets * sizeof(struct UT_hash_bucket)); if (!_he_new_buckets) { exit(-1); } memset(_he_new_buckets, 0, 2 * (&(&tankIO_server_blinkAllLeds_function)->hh)->tbl->num_buckets * sizeof(struct UT_hash_bucket)); (&(&tankIO_server_blinkAllLeds_function)->hh)->tbl->ideal_chain_maxlen = ((&(&tankIO_server_blinkAllLeds_function)->hh)->tbl->num_items >> ((&(&tankIO_server_blinkAllLeds_function)->hh)->tbl->log2_num_buckets+1)) + (((&(&tankIO_server_blinkAllLeds_function)->hh)->tbl->num_items & (((&(&tankIO_server_blinkAllLeds_function)->hh)->tbl->num_buckets*2)-1)) ? 1 : 0); (&(&tankIO_server_blinkAllLeds_function)->hh)->tbl->nonideal_items = 0; for(_he_bkt_i = 0; _he_bkt_i < (&(&tankIO_server_blinkAllLeds_function)->hh)->tbl->num_buckets; _he_bkt_i++) { _he_thh = (&(&tankIO_server_blinkAllLeds_function)->hh)->tbl->buckets[ _he_bkt_i ].hh_head; while (_he_thh) { _he_hh_nxt = _he_thh->hh_next; do { _he_bkt = ((_he_thh->hashv) & (((&(&tankIO_server_blinkAllLeds_function)->hh)->tbl->num_buckets*2) - 1)); } while(0); _he_newbkt = &(_he_new_buckets[ _he_bkt ]); if (++(_he_newbkt->count) > (&(&tankIO_server_blinkAllLeds_function)->hh)->tbl->ideal_chain_maxlen) { (&(&tankIO_server_blinkAllLeds_function)->hh)->tbl->nonideal_items++; _he_newbkt->expand_mult = _he_newbkt->count / (&(&tankIO_server_blinkAllLeds_function)->hh)->tbl->ideal_chain_maxlen; } _he_thh->hh_prev = ((void *)0); _he_thh->hh_next = _he_newbkt->hh_head; if (_he_newbkt->hh_head) _he_newbkt->hh_head->hh_prev = _he_thh; _he_newbkt->hh_head = _he_thh; _he_thh = _he_hh_nxt; } } free((&(&tankIO_server_blinkAllLeds_function)->hh)->tbl->buckets); (&(&tankIO_server_blinkAllLeds_function)->hh)->tbl->num_buckets *= 2; (&(&tankIO_server_blinkAllLeds_function)->hh)->tbl->log2_num_buckets++; (&(&tankIO_server_blinkAllLeds_function)->hh)->tbl->buckets = _he_new_buckets; (&(&tankIO_server_blinkAllLeds_function)->hh)->tbl->ineff_expands = ((&(&tankIO_server_blinkAllLeds_function)->hh)->tbl->nonideal_items > ((&(&tankIO_server_blinkAllLeds_function)->hh)->tbl->num_items >> 1)) ? ((&(&tankIO_server_blinkAllLeds_function)->hh)->tbl->ineff_expands+1) : 0; if ((&(&tankIO_server_blinkAllLeds_function)->hh)->tbl->ineff_expands > 1) { (&(&tankIO_server_blinkAllLeds_function)->hh)->tbl->noexpand=1; ; } ; } while(0); } } while(0); ; ; ; } while(0); } void tankIO_server_blinkAllLeds_register_function_kernel_init() __attribute__((naked, section(".init8"))); void tankIO_server_blinkAllLeds_register_function_kernel_init() { tankIO_server_blinkAllLeds_register_function(); }





void tankIO_server_flashLed(FlashLedParam *param, uint16_t size) {
 flashLed(toLed(param->led), param->milliseconds);
}
void tankIO_server_flashLed_handler(TWIBuffer *buffer) { tankIO_server_flashLed((FlashLedParam*) buffer->data, buffer->size); buffer->size = 0; } TwiFunction tankIO_server_flashLed_function = { TANK_IO_flashLed, tankIO_server_flashLed_handler, {0} }; void tankIO_server_flashLed_register_function() { do { unsigned _ha_bkt; (&tankIO_server_flashLed_function)->hh.next = ((void *)0); (&tankIO_server_flashLed_function)->hh.key = (char*)&((&tankIO_server_flashLed_function)->operation); (&tankIO_server_flashLed_function)->hh.keylen = (unsigned)sizeof(int); if (!(twiRpcFunctions)) { twiRpcFunctions = (&tankIO_server_flashLed_function); (twiRpcFunctions)->hh.prev = ((void *)0); do { (twiRpcFunctions)->hh.tbl = (UT_hash_table*)malloc(sizeof(UT_hash_table)); if (!((twiRpcFunctions)->hh.tbl)) { exit(-1); } memset((twiRpcFunctions)->hh.tbl, 0, sizeof(UT_hash_table)); (twiRpcFunctions)->hh.tbl->tail = &((twiRpcFunctions)->hh); (twiRpcFunctions)->hh.tbl->num_buckets = 32; (twiRpcFunctions)->hh.tbl->log2_num_buckets = 5; (twiRpcFunctions)->hh.tbl->hho = (char*)(&(twiRpcFunctions)->hh) - (char*)(twiRpcFunctions); (twiRpcFunctions)->hh.tbl->buckets = (UT_hash_bucket*)malloc(32*sizeof(struct UT_hash_bucket)); if (! (twiRpcFunctions)->hh.tbl->buckets) { exit(-1); } memset((twiRpcFunctions)->hh.tbl->buckets, 0, 32*sizeof(struct UT_hash_bucket)); ; (twiRpcFunctions)->hh.tbl->signature = 0xa0111fe1; } while(0); } else { (twiRpcFunctions)->hh.tbl->tail->next = (&tankIO_server_flashLed_function); (&tankIO_server_flashLed_function)->hh.prev = ((void*)(((char*)((twiRpcFunctions)->hh.tbl->tail)) - (((twiRpcFunctions)->hh.tbl)->hho))); (twiRpcFunctions)->hh.tbl->tail = &((&tankIO_server_flashLed_function)->hh); } (twiRpcFunctions)->hh.tbl->num_items++; (&tankIO_server_flashLed_function)->hh.tbl = (twiRpcFunctions)->hh.tbl; do { unsigned _sx_i; char *_hs_key=(char*)(&((&tankIO_server_flashLed_function)->operation)); (&tankIO_server_flashLed_function)->hh.hashv = 0; for(_sx_i=0; _sx_i < sizeof(int); _sx_i++) (&tankIO_server_flashLed_function)->hh.hashv ^= ((&tankIO_server_flashLed_function)->hh.hashv << 5) + ((&tankIO_server_flashLed_function)->hh.hashv >> 2) + _hs_key[_sx_i]; _ha_bkt = (&tankIO_server_flashLed_function)->hh.hashv & ((twiRpcFunctions)->hh.tbl->num_buckets-1); } while (0); do { (twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].count++; (&(&tankIO_server_flashLed_function)->hh)->hh_next = (twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].hh_head; (&(&tankIO_server_flashLed_function)->hh)->hh_prev = ((void *)0); if ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].hh_head) { ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt]).hh_head->hh_prev = (&(&tankIO_server_flashLed_function)->hh); } ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt]).hh_head=&(&tankIO_server_flashLed_function)->hh; if ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].count >= (((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].expand_mult+1) * 10) && (&(&tankIO_server_flashLed_function)->hh)->tbl->noexpand != 1) { do { unsigned _he_bkt; unsigned _he_bkt_i; struct UT_hash_handle *_he_thh, *_he_hh_nxt; UT_hash_bucket *_he_new_buckets, *_he_newbkt; _he_new_buckets = (UT_hash_bucket*)malloc(2 * (&(&tankIO_server_flashLed_function)->hh)->tbl->num_buckets * sizeof(struct UT_hash_bucket)); if (!_he_new_buckets) { exit(-1); } memset(_he_new_buckets, 0, 2 * (&(&tankIO_server_flashLed_function)->hh)->tbl->num_buckets * sizeof(struct UT_hash_bucket)); (&(&tankIO_server_flashLed_function)->hh)->tbl->ideal_chain_maxlen = ((&(&tankIO_server_flashLed_function)->hh)->tbl->num_items >> ((&(&tankIO_server_flashLed_function)->hh)->tbl->log2_num_buckets+1)) + (((&(&tankIO_server_flashLed_function)->hh)->tbl->num_items & (((&(&tankIO_server_flashLed_function)->hh)->tbl->num_buckets*2)-1)) ? 1 : 0); (&(&tankIO_server_flashLed_function)->hh)->tbl->nonideal_items = 0; for(_he_bkt_i = 0; _he_bkt_i < (&(&tankIO_server_flashLed_function)->hh)->tbl->num_buckets; _he_bkt_i++) { _he_thh = (&(&tankIO_server_flashLed_function)->hh)->tbl->buckets[ _he_bkt_i ].hh_head; while (_he_thh) { _he_hh_nxt = _he_thh->hh_next; do { _he_bkt = ((_he_thh->hashv) & (((&(&tankIO_server_flashLed_function)->hh)->tbl->num_buckets*2) - 1)); } while(0); _he_newbkt = &(_he_new_buckets[ _he_bkt ]); if (++(_he_newbkt->count) > (&(&tankIO_server_flashLed_function)->hh)->tbl->ideal_chain_maxlen) { (&(&tankIO_server_flashLed_function)->hh)->tbl->nonideal_items++; _he_newbkt->expand_mult = _he_newbkt->count / (&(&tankIO_server_flashLed_function)->hh)->tbl->ideal_chain_maxlen; } _he_thh->hh_prev = ((void *)0); _he_thh->hh_next = _he_newbkt->hh_head; if (_he_newbkt->hh_head) _he_newbkt->hh_head->hh_prev = _he_thh; _he_newbkt->hh_head = _he_thh; _he_thh = _he_hh_nxt; } } free((&(&tankIO_server_flashLed_function)->hh)->tbl->buckets); (&(&tankIO_server_flashLed_function)->hh)->tbl->num_buckets *= 2; (&(&tankIO_server_flashLed_function)->hh)->tbl->log2_num_buckets++; (&(&tankIO_server_flashLed_function)->hh)->tbl->buckets = _he_new_buckets; (&(&tankIO_server_flashLed_function)->hh)->tbl->ineff_expands = ((&(&tankIO_server_flashLed_function)->hh)->tbl->nonideal_items > ((&(&tankIO_server_flashLed_function)->hh)->tbl->num_items >> 1)) ? ((&(&tankIO_server_flashLed_function)->hh)->tbl->ineff_expands+1) : 0; if ((&(&tankIO_server_flashLed_function)->hh)->tbl->ineff_expands > 1) { (&(&tankIO_server_flashLed_function)->hh)->tbl->noexpand=1; ; } ; } while(0); } } while(0); ; ; ; } while(0); } void tankIO_server_flashLed_register_function_kernel_init() __attribute__((naked, section(".init8"))); void tankIO_server_flashLed_register_function_kernel_init() { tankIO_server_flashLed_register_function(); }

void tankIO_server_flashLeds(FlashLedsParam *param, uint16_t size) {
 flashLeds(toLedGroup(param->leds.leds), param->leds.mask, param->milliseconds);
}
void tankIO_server_flashLeds_handler(TWIBuffer *buffer) { tankIO_server_flashLeds((FlashLedsParam*) buffer->data, buffer->size); buffer->size = 0; } TwiFunction tankIO_server_flashLeds_function = { TANK_IO_flashLeds, tankIO_server_flashLeds_handler, {0} }; void tankIO_server_flashLeds_register_function() { do { unsigned _ha_bkt; (&tankIO_server_flashLeds_function)->hh.next = ((void *)0); (&tankIO_server_flashLeds_function)->hh.key = (char*)&((&tankIO_server_flashLeds_function)->operation); (&tankIO_server_flashLeds_function)->hh.keylen = (unsigned)sizeof(int); if (!(twiRpcFunctions)) { twiRpcFunctions = (&tankIO_server_flashLeds_function); (twiRpcFunctions)->hh.prev = ((void *)0); do { (twiRpcFunctions)->hh.tbl = (UT_hash_table*)malloc(sizeof(UT_hash_table)); if (!((twiRpcFunctions)->hh.tbl)) { exit(-1); } memset((twiRpcFunctions)->hh.tbl, 0, sizeof(UT_hash_table)); (twiRpcFunctions)->hh.tbl->tail = &((twiRpcFunctions)->hh); (twiRpcFunctions)->hh.tbl->num_buckets = 32; (twiRpcFunctions)->hh.tbl->log2_num_buckets = 5; (twiRpcFunctions)->hh.tbl->hho = (char*)(&(twiRpcFunctions)->hh) - (char*)(twiRpcFunctions); (twiRpcFunctions)->hh.tbl->buckets = (UT_hash_bucket*)malloc(32*sizeof(struct UT_hash_bucket)); if (! (twiRpcFunctions)->hh.tbl->buckets) { exit(-1); } memset((twiRpcFunctions)->hh.tbl->buckets, 0, 32*sizeof(struct UT_hash_bucket)); ; (twiRpcFunctions)->hh.tbl->signature = 0xa0111fe1; } while(0); } else { (twiRpcFunctions)->hh.tbl->tail->next = (&tankIO_server_flashLeds_function); (&tankIO_server_flashLeds_function)->hh.prev = ((void*)(((char*)((twiRpcFunctions)->hh.tbl->tail)) - (((twiRpcFunctions)->hh.tbl)->hho))); (twiRpcFunctions)->hh.tbl->tail = &((&tankIO_server_flashLeds_function)->hh); } (twiRpcFunctions)->hh.tbl->num_items++; (&tankIO_server_flashLeds_function)->hh.tbl = (twiRpcFunctions)->hh.tbl; do { unsigned _sx_i; char *_hs_key=(char*)(&((&tankIO_server_flashLeds_function)->operation)); (&tankIO_server_flashLeds_function)->hh.hashv = 0; for(_sx_i=0; _sx_i < sizeof(int); _sx_i++) (&tankIO_server_flashLeds_function)->hh.hashv ^= ((&tankIO_server_flashLeds_function)->hh.hashv << 5) + ((&tankIO_server_flashLeds_function)->hh.hashv >> 2) + _hs_key[_sx_i]; _ha_bkt = (&tankIO_server_flashLeds_function)->hh.hashv & ((twiRpcFunctions)->hh.tbl->num_buckets-1); } while (0); do { (twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].count++; (&(&tankIO_server_flashLeds_function)->hh)->hh_next = (twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].hh_head; (&(&tankIO_server_flashLeds_function)->hh)->hh_prev = ((void *)0); if ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].hh_head) { ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt]).hh_head->hh_prev = (&(&tankIO_server_flashLeds_function)->hh); } ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt]).hh_head=&(&tankIO_server_flashLeds_function)->hh; if ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].count >= (((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].expand_mult+1) * 10) && (&(&tankIO_server_flashLeds_function)->hh)->tbl->noexpand != 1) { do { unsigned _he_bkt; unsigned _he_bkt_i; struct UT_hash_handle *_he_thh, *_he_hh_nxt; UT_hash_bucket *_he_new_buckets, *_he_newbkt; _he_new_buckets = (UT_hash_bucket*)malloc(2 * (&(&tankIO_server_flashLeds_function)->hh)->tbl->num_buckets * sizeof(struct UT_hash_bucket)); if (!_he_new_buckets) { exit(-1); } memset(_he_new_buckets, 0, 2 * (&(&tankIO_server_flashLeds_function)->hh)->tbl->num_buckets * sizeof(struct UT_hash_bucket)); (&(&tankIO_server_flashLeds_function)->hh)->tbl->ideal_chain_maxlen = ((&(&tankIO_server_flashLeds_function)->hh)->tbl->num_items >> ((&(&tankIO_server_flashLeds_function)->hh)->tbl->log2_num_buckets+1)) + (((&(&tankIO_server_flashLeds_function)->hh)->tbl->num_items & (((&(&tankIO_server_flashLeds_function)->hh)->tbl->num_buckets*2)-1)) ? 1 : 0); (&(&tankIO_server_flashLeds_function)->hh)->tbl->nonideal_items = 0; for(_he_bkt_i = 0; _he_bkt_i < (&(&tankIO_server_flashLeds_function)->hh)->tbl->num_buckets; _he_bkt_i++) { _he_thh = (&(&tankIO_server_flashLeds_function)->hh)->tbl->buckets[ _he_bkt_i ].hh_head; while (_he_thh) { _he_hh_nxt = _he_thh->hh_next; do { _he_bkt = ((_he_thh->hashv) & (((&(&tankIO_server_flashLeds_function)->hh)->tbl->num_buckets*2) - 1)); } while(0); _he_newbkt = &(_he_new_buckets[ _he_bkt ]); if (++(_he_newbkt->count) > (&(&tankIO_server_flashLeds_function)->hh)->tbl->ideal_chain_maxlen) { (&(&tankIO_server_flashLeds_function)->hh)->tbl->nonideal_items++; _he_newbkt->expand_mult = _he_newbkt->count / (&(&tankIO_server_flashLeds_function)->hh)->tbl->ideal_chain_maxlen; } _he_thh->hh_prev = ((void *)0); _he_thh->hh_next = _he_newbkt->hh_head; if (_he_newbkt->hh_head) _he_newbkt->hh_head->hh_prev = _he_thh; _he_newbkt->hh_head = _he_thh; _he_thh = _he_hh_nxt; } } free((&(&tankIO_server_flashLeds_function)->hh)->tbl->buckets); (&(&tankIO_server_flashLeds_function)->hh)->tbl->num_buckets *= 2; (&(&tankIO_server_flashLeds_function)->hh)->tbl->log2_num_buckets++; (&(&tankIO_server_flashLeds_function)->hh)->tbl->buckets = _he_new_buckets; (&(&tankIO_server_flashLeds_function)->hh)->tbl->ineff_expands = ((&(&tankIO_server_flashLeds_function)->hh)->tbl->nonideal_items > ((&(&tankIO_server_flashLeds_function)->hh)->tbl->num_items >> 1)) ? ((&(&tankIO_server_flashLeds_function)->hh)->tbl->ineff_expands+1) : 0; if ((&(&tankIO_server_flashLeds_function)->hh)->tbl->ineff_expands > 1) { (&(&tankIO_server_flashLeds_function)->hh)->tbl->noexpand=1; ; } ; } while(0); } } while(0); ; ; ; } while(0); } void tankIO_server_flashLeds_register_function_kernel_init() __attribute__((naked, section(".init8"))); void tankIO_server_flashLeds_register_function_kernel_init() { tankIO_server_flashLeds_register_function(); }

void tankIO_server_flashAllLeds(FlashAllLedsParam *param, uint16_t size) {
 flashAllLeds(toLedGroup(param->leds), param->milliseconds);
}
void tankIO_server_flashAllLeds_handler(TWIBuffer *buffer) { tankIO_server_flashAllLeds((FlashAllLedsParam*) buffer->data, buffer->size); buffer->size = 0; } TwiFunction tankIO_server_flashAllLeds_function = { TANK_IO_flashAllLeds, tankIO_server_flashAllLeds_handler, {0} }; void tankIO_server_flashAllLeds_register_function() { do { unsigned _ha_bkt; (&tankIO_server_flashAllLeds_function)->hh.next = ((void *)0); (&tankIO_server_flashAllLeds_function)->hh.key = (char*)&((&tankIO_server_flashAllLeds_function)->operation); (&tankIO_server_flashAllLeds_function)->hh.keylen = (unsigned)sizeof(int); if (!(twiRpcFunctions)) { twiRpcFunctions = (&tankIO_server_flashAllLeds_function); (twiRpcFunctions)->hh.prev = ((void *)0); do { (twiRpcFunctions)->hh.tbl = (UT_hash_table*)malloc(sizeof(UT_hash_table)); if (!((twiRpcFunctions)->hh.tbl)) { exit(-1); } memset((twiRpcFunctions)->hh.tbl, 0, sizeof(UT_hash_table)); (twiRpcFunctions)->hh.tbl->tail = &((twiRpcFunctions)->hh); (twiRpcFunctions)->hh.tbl->num_buckets = 32; (twiRpcFunctions)->hh.tbl->log2_num_buckets = 5; (twiRpcFunctions)->hh.tbl->hho = (char*)(&(twiRpcFunctions)->hh) - (char*)(twiRpcFunctions); (twiRpcFunctions)->hh.tbl->buckets = (UT_hash_bucket*)malloc(32*sizeof(struct UT_hash_bucket)); if (! (twiRpcFunctions)->hh.tbl->buckets) { exit(-1); } memset((twiRpcFunctions)->hh.tbl->buckets, 0, 32*sizeof(struct UT_hash_bucket)); ; (twiRpcFunctions)->hh.tbl->signature = 0xa0111fe1; } while(0); } else { (twiRpcFunctions)->hh.tbl->tail->next = (&tankIO_server_flashAllLeds_function); (&tankIO_server_flashAllLeds_function)->hh.prev = ((void*)(((char*)((twiRpcFunctions)->hh.tbl->tail)) - (((twiRpcFunctions)->hh.tbl)->hho))); (twiRpcFunctions)->hh.tbl->tail = &((&tankIO_server_flashAllLeds_function)->hh); } (twiRpcFunctions)->hh.tbl->num_items++; (&tankIO_server_flashAllLeds_function)->hh.tbl = (twiRpcFunctions)->hh.tbl; do { unsigned _sx_i; char *_hs_key=(char*)(&((&tankIO_server_flashAllLeds_function)->operation)); (&tankIO_server_flashAllLeds_function)->hh.hashv = 0; for(_sx_i=0; _sx_i < sizeof(int); _sx_i++) (&tankIO_server_flashAllLeds_function)->hh.hashv ^= ((&tankIO_server_flashAllLeds_function)->hh.hashv << 5) + ((&tankIO_server_flashAllLeds_function)->hh.hashv >> 2) + _hs_key[_sx_i]; _ha_bkt = (&tankIO_server_flashAllLeds_function)->hh.hashv & ((twiRpcFunctions)->hh.tbl->num_buckets-1); } while (0); do { (twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].count++; (&(&tankIO_server_flashAllLeds_function)->hh)->hh_next = (twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].hh_head; (&(&tankIO_server_flashAllLeds_function)->hh)->hh_prev = ((void *)0); if ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].hh_head) { ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt]).hh_head->hh_prev = (&(&tankIO_server_flashAllLeds_function)->hh); } ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt]).hh_head=&(&tankIO_server_flashAllLeds_function)->hh; if ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].count >= (((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].expand_mult+1) * 10) && (&(&tankIO_server_flashAllLeds_function)->hh)->tbl->noexpand != 1) { do { unsigned _he_bkt; unsigned _he_bkt_i; struct UT_hash_handle *_he_thh, *_he_hh_nxt; UT_hash_bucket *_he_new_buckets, *_he_newbkt; _he_new_buckets = (UT_hash_bucket*)malloc(2 * (&(&tankIO_server_flashAllLeds_function)->hh)->tbl->num_buckets * sizeof(struct UT_hash_bucket)); if (!_he_new_buckets) { exit(-1); } memset(_he_new_buckets, 0, 2 * (&(&tankIO_server_flashAllLeds_function)->hh)->tbl->num_buckets * sizeof(struct UT_hash_bucket)); (&(&tankIO_server_flashAllLeds_function)->hh)->tbl->ideal_chain_maxlen = ((&(&tankIO_server_flashAllLeds_function)->hh)->tbl->num_items >> ((&(&tankIO_server_flashAllLeds_function)->hh)->tbl->log2_num_buckets+1)) + (((&(&tankIO_server_flashAllLeds_function)->hh)->tbl->num_items & (((&(&tankIO_server_flashAllLeds_function)->hh)->tbl->num_buckets*2)-1)) ? 1 : 0); (&(&tankIO_server_flashAllLeds_function)->hh)->tbl->nonideal_items = 0; for(_he_bkt_i = 0; _he_bkt_i < (&(&tankIO_server_flashAllLeds_function)->hh)->tbl->num_buckets; _he_bkt_i++) { _he_thh = (&(&tankIO_server_flashAllLeds_function)->hh)->tbl->buckets[ _he_bkt_i ].hh_head; while (_he_thh) { _he_hh_nxt = _he_thh->hh_next; do { _he_bkt = ((_he_thh->hashv) & (((&(&tankIO_server_flashAllLeds_function)->hh)->tbl->num_buckets*2) - 1)); } while(0); _he_newbkt = &(_he_new_buckets[ _he_bkt ]); if (++(_he_newbkt->count) > (&(&tankIO_server_flashAllLeds_function)->hh)->tbl->ideal_chain_maxlen) { (&(&tankIO_server_flashAllLeds_function)->hh)->tbl->nonideal_items++; _he_newbkt->expand_mult = _he_newbkt->count / (&(&tankIO_server_flashAllLeds_function)->hh)->tbl->ideal_chain_maxlen; } _he_thh->hh_prev = ((void *)0); _he_thh->hh_next = _he_newbkt->hh_head; if (_he_newbkt->hh_head) _he_newbkt->hh_head->hh_prev = _he_thh; _he_newbkt->hh_head = _he_thh; _he_thh = _he_hh_nxt; } } free((&(&tankIO_server_flashAllLeds_function)->hh)->tbl->buckets); (&(&tankIO_server_flashAllLeds_function)->hh)->tbl->num_buckets *= 2; (&(&tankIO_server_flashAllLeds_function)->hh)->tbl->log2_num_buckets++; (&(&tankIO_server_flashAllLeds_function)->hh)->tbl->buckets = _he_new_buckets; (&(&tankIO_server_flashAllLeds_function)->hh)->tbl->ineff_expands = ((&(&tankIO_server_flashAllLeds_function)->hh)->tbl->nonideal_items > ((&(&tankIO_server_flashAllLeds_function)->hh)->tbl->num_items >> 1)) ? ((&(&tankIO_server_flashAllLeds_function)->hh)->tbl->ineff_expands+1) : 0; if ((&(&tankIO_server_flashAllLeds_function)->hh)->tbl->ineff_expands > 1) { (&(&tankIO_server_flashAllLeds_function)->hh)->tbl->noexpand=1; ; } ; } while(0); } } while(0); ; ; ; } while(0); } void tankIO_server_flashAllLeds_register_function_kernel_init() __attribute__((naked, section(".init8"))); void tankIO_server_flashAllLeds_register_function_kernel_init() { tankIO_server_flashAllLeds_register_function(); }





void tankIO_server_blinkByte(BlinkByteParam *param, uint16_t size) {
 blinkByte(toLedGroup(param->display), toLedGroup(param->notifier), param->data);
}
void tankIO_server_blinkByte_handler(TWIBuffer *buffer) { tankIO_server_blinkByte((BlinkByteParam*) buffer->data, buffer->size); buffer->size = 0; } TwiFunction tankIO_server_blinkByte_function = { TANK_IO_blinkByte, tankIO_server_blinkByte_handler, {0} }; void tankIO_server_blinkByte_register_function() { do { unsigned _ha_bkt; (&tankIO_server_blinkByte_function)->hh.next = ((void *)0); (&tankIO_server_blinkByte_function)->hh.key = (char*)&((&tankIO_server_blinkByte_function)->operation); (&tankIO_server_blinkByte_function)->hh.keylen = (unsigned)sizeof(int); if (!(twiRpcFunctions)) { twiRpcFunctions = (&tankIO_server_blinkByte_function); (twiRpcFunctions)->hh.prev = ((void *)0); do { (twiRpcFunctions)->hh.tbl = (UT_hash_table*)malloc(sizeof(UT_hash_table)); if (!((twiRpcFunctions)->hh.tbl)) { exit(-1); } memset((twiRpcFunctions)->hh.tbl, 0, sizeof(UT_hash_table)); (twiRpcFunctions)->hh.tbl->tail = &((twiRpcFunctions)->hh); (twiRpcFunctions)->hh.tbl->num_buckets = 32; (twiRpcFunctions)->hh.tbl->log2_num_buckets = 5; (twiRpcFunctions)->hh.tbl->hho = (char*)(&(twiRpcFunctions)->hh) - (char*)(twiRpcFunctions); (twiRpcFunctions)->hh.tbl->buckets = (UT_hash_bucket*)malloc(32*sizeof(struct UT_hash_bucket)); if (! (twiRpcFunctions)->hh.tbl->buckets) { exit(-1); } memset((twiRpcFunctions)->hh.tbl->buckets, 0, 32*sizeof(struct UT_hash_bucket)); ; (twiRpcFunctions)->hh.tbl->signature = 0xa0111fe1; } while(0); } else { (twiRpcFunctions)->hh.tbl->tail->next = (&tankIO_server_blinkByte_function); (&tankIO_server_blinkByte_function)->hh.prev = ((void*)(((char*)((twiRpcFunctions)->hh.tbl->tail)) - (((twiRpcFunctions)->hh.tbl)->hho))); (twiRpcFunctions)->hh.tbl->tail = &((&tankIO_server_blinkByte_function)->hh); } (twiRpcFunctions)->hh.tbl->num_items++; (&tankIO_server_blinkByte_function)->hh.tbl = (twiRpcFunctions)->hh.tbl; do { unsigned _sx_i; char *_hs_key=(char*)(&((&tankIO_server_blinkByte_function)->operation)); (&tankIO_server_blinkByte_function)->hh.hashv = 0; for(_sx_i=0; _sx_i < sizeof(int); _sx_i++) (&tankIO_server_blinkByte_function)->hh.hashv ^= ((&tankIO_server_blinkByte_function)->hh.hashv << 5) + ((&tankIO_server_blinkByte_function)->hh.hashv >> 2) + _hs_key[_sx_i]; _ha_bkt = (&tankIO_server_blinkByte_function)->hh.hashv & ((twiRpcFunctions)->hh.tbl->num_buckets-1); } while (0); do { (twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].count++; (&(&tankIO_server_blinkByte_function)->hh)->hh_next = (twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].hh_head; (&(&tankIO_server_blinkByte_function)->hh)->hh_prev = ((void *)0); if ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].hh_head) { ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt]).hh_head->hh_prev = (&(&tankIO_server_blinkByte_function)->hh); } ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt]).hh_head=&(&tankIO_server_blinkByte_function)->hh; if ((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].count >= (((twiRpcFunctions)->hh.tbl->buckets[_ha_bkt].expand_mult+1) * 10) && (&(&tankIO_server_blinkByte_function)->hh)->tbl->noexpand != 1) { do { unsigned _he_bkt; unsigned _he_bkt_i; struct UT_hash_handle *_he_thh, *_he_hh_nxt; UT_hash_bucket *_he_new_buckets, *_he_newbkt; _he_new_buckets = (UT_hash_bucket*)malloc(2 * (&(&tankIO_server_blinkByte_function)->hh)->tbl->num_buckets * sizeof(struct UT_hash_bucket)); if (!_he_new_buckets) { exit(-1); } memset(_he_new_buckets, 0, 2 * (&(&tankIO_server_blinkByte_function)->hh)->tbl->num_buckets * sizeof(struct UT_hash_bucket)); (&(&tankIO_server_blinkByte_function)->hh)->tbl->ideal_chain_maxlen = ((&(&tankIO_server_blinkByte_function)->hh)->tbl->num_items >> ((&(&tankIO_server_blinkByte_function)->hh)->tbl->log2_num_buckets+1)) + (((&(&tankIO_server_blinkByte_function)->hh)->tbl->num_items & (((&(&tankIO_server_blinkByte_function)->hh)->tbl->num_buckets*2)-1)) ? 1 : 0); (&(&tankIO_server_blinkByte_function)->hh)->tbl->nonideal_items = 0; for(_he_bkt_i = 0; _he_bkt_i < (&(&tankIO_server_blinkByte_function)->hh)->tbl->num_buckets; _he_bkt_i++) { _he_thh = (&(&tankIO_server_blinkByte_function)->hh)->tbl->buckets[ _he_bkt_i ].hh_head; while (_he_thh) { _he_hh_nxt = _he_thh->hh_next; do { _he_bkt = ((_he_thh->hashv) & (((&(&tankIO_server_blinkByte_function)->hh)->tbl->num_buckets*2) - 1)); } while(0); _he_newbkt = &(_he_new_buckets[ _he_bkt ]); if (++(_he_newbkt->count) > (&(&tankIO_server_blinkByte_function)->hh)->tbl->ideal_chain_maxlen) { (&(&tankIO_server_blinkByte_function)->hh)->tbl->nonideal_items++; _he_newbkt->expand_mult = _he_newbkt->count / (&(&tankIO_server_blinkByte_function)->hh)->tbl->ideal_chain_maxlen; } _he_thh->hh_prev = ((void *)0); _he_thh->hh_next = _he_newbkt->hh_head; if (_he_newbkt->hh_head) _he_newbkt->hh_head->hh_prev = _he_thh; _he_newbkt->hh_head = _he_thh; _he_thh = _he_hh_nxt; } } free((&(&tankIO_server_blinkByte_function)->hh)->tbl->buckets); (&(&tankIO_server_blinkByte_function)->hh)->tbl->num_buckets *= 2; (&(&tankIO_server_blinkByte_function)->hh)->tbl->log2_num_buckets++; (&(&tankIO_server_blinkByte_function)->hh)->tbl->buckets = _he_new_buckets; (&(&tankIO_server_blinkByte_function)->hh)->tbl->ineff_expands = ((&(&tankIO_server_blinkByte_function)->hh)->tbl->nonideal_items > ((&(&tankIO_server_blinkByte_function)->hh)->tbl->num_items >> 1)) ? ((&(&tankIO_server_blinkByte_function)->hh)->tbl->ineff_expands+1) : 0; if ((&(&tankIO_server_blinkByte_function)->hh)->tbl->ineff_expands > 1) { (&(&tankIO_server_blinkByte_function)->hh)->tbl->noexpand=1; ; } ; } while(0); } } while(0); ; ; ; } while(0); } void tankIO_server_blinkByte_register_function_kernel_init() __attribute__((naked, section(".init8"))); void tankIO_server_blinkByte_register_function_kernel_init() { tankIO_server_blinkByte_register_function(); }
# 14 ".././kernel.c" 2
# 1 ".././shared/base_after.kernel.h" 1
# 9 ".././shared/base_after.kernel.h"
#define _BASE_AFTER_KERNEL_ 



void before_timer() __attribute__((weak));
void before_timer() {}


void init_kernel() {

 (*(volatile uint8_t *)((0x30) + 0x20)) |= (1 << (7));
 (*(volatile uint8_t *)(0x64)) |= (1 << (5)) | (1 << (6));
# 29 ".././shared/base_after.kernel.h"

 before_timer();

 enableTimerInterrupt(Timer3A);




 __asm__ __volatile__ ("sei" ::: "memory");
}
void init_kernel_kernel_init() __attribute__((naked, section(".init8"))); void init_kernel_kernel_init() { init_kernel(); }
# 15 ".././kernel.c" 2



void tankIO_system_initialized_kernel_init() __attribute__((naked, section(".init8"))); void tankIO_system_initialized_kernel_init() { tankIO_system_initialized(); }
